Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> list
Rule 2     list -> empty
Rule 3     list -> list NEWLINE
Rule 4     list -> list defn NEWLINE
Rule 5     list -> list asgn NEWLINE
Rule 6     list -> list stmt NEWLINE
Rule 7     list -> list expr NEWLINE
Rule 8     list -> list error NEWLINE
Rule 9     list -> list COMMENT NEWLINE
Rule 10    stmt -> expr
Rule 11    stmt -> RETURN
Rule 12    stmt -> RETURN expr
Rule 13    stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT
Rule 14    stmt -> PRINT prlist
Rule 15    stmt -> WHILE LPARENT cond RPARENT stmt END
Rule 16    stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END
Rule 17    stmt -> IF LPARENT cond RPARENT stmt END
Rule 18    stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END
Rule 19    stmt -> LBRACKET stmtlist RBRACKET
Rule 20    cond -> expr
Rule 21    stmtlist -> empty
Rule 22    stmtlist -> stmtlist NEWLINE
Rule 23    stmtlist -> stmtlist stmt
Rule 24    expr -> data
Rule 25    expr -> unaryop
Rule 26    expr -> binaryop
Rule 27    expr -> LPARENT expr RPARENT
Rule 28    expr -> callfunc
Rule 29    data -> FLOAT
Rule 30    data -> CONSTANT
Rule 31    data -> ID
Rule 32    unaryop -> MINUS expr
Rule 33    unaryop -> INC ID
Rule 34    unaryop -> DEC ID
Rule 35    unaryop -> ID INC
Rule 36    unaryop -> ID DEC
Rule 37    binaryop -> asgn
Rule 38    binaryop -> mathop
Rule 39    binaryop -> logicop
Rule 40    asgn -> ID ASSIGN expr
Rule 41    asgn -> ID ADDEQ expr
Rule 42    asgn -> ID SUBEQ expr
Rule 43    asgn -> ID MULEQ expr
Rule 44    asgn -> ID DIVEQ expr
Rule 45    asgn -> ID MODEQ expr
Rule 46    mathop -> expr EXP expr
Rule 47    mathop -> expr PLUS expr
Rule 48    mathop -> expr MINUS expr
Rule 49    mathop -> expr TIMES expr
Rule 50    mathop -> expr DIVIDE expr
Rule 51    mathop -> expr MOD expr
Rule 52    logicop -> expr LT expr
Rule 53    logicop -> expr GT expr
Rule 54    logicop -> expr LE expr
Rule 55    logicop -> expr GE expr
Rule 56    logicop -> expr EQ expr
Rule 57    logicop -> expr NE expr
Rule 58    logicop -> expr OR expr
Rule 59    logicop -> expr AND expr
Rule 60    logicop -> expr NOT expr
Rule 61    callfunc -> BLTIN LPARENT expr RPARENT
Rule 62    callfunc -> ID LPARENT expr RPARENT
Rule 63    prlist -> expr
Rule 64    prlist -> STRING
Rule 65    prlist -> prlist COMMA expr
Rule 66    prlist -> prlist COMMA STRING
Rule 67    defn -> FUNC procname LPARENT formals RPARENT
Rule 68    defn -> PROC procname LPARENT formals RPARENT
Rule 69    formals -> ID
Rule 70    formals -> ID COMMA formals
Rule 71    procname -> FUNCTION
Rule 72    procname -> ID
Rule 73    procname -> PROCEDURE
Rule 74    procname -> BLTIN
Rule 75    arglist -> empty
Rule 76    arglist -> expr
Rule 77    arglist -> arglist COMMA expr
Rule 78    empty -> <empty>

Terminals, with rules where they appear

ADDEQ                : 41
AND                  : 59
ASSIGN               : 40
BEGIN                : 13
BLTIN                : 61 74
COMMA                : 65 66 70 77
COMMENT              : 9
CONSTANT             : 30
DEC                  : 34 36
DIVEQ                : 44
DIVIDE               : 50
ELSE                 : 18
END                  : 15 16 17 18 18
EQ                   : 56
EXP                  : 46
FLOAT                : 29
FOR                  : 16
FUNC                 : 67
FUNCTION             : 71
GE                   : 55
GT                   : 53
ID                   : 31 33 34 35 36 40 41 42 43 44 45 62 69 70 72
IF                   : 17 18
INC                  : 33 35
LBRACKET             : 19
LE                   : 54
LPARENT              : 13 15 16 17 18 27 61 62 67 68
LT                   : 52
MINUS                : 32 48
MOD                  : 51
MODEQ                : 45
MULEQ                : 43
NE                   : 57
NEWLINE              : 3 4 5 6 7 8 9 22
NOT                  : 60
OR                   : 58
PLUS                 : 47
PRINT                : 14
PROC                 : 68
PROCEDURE            : 13 73
RBRACKET             : 19
RETURN               : 11 12
RPARENT              : 13 15 16 17 18 27 61 62 67 68
SEMICOLON            : 16 16
STRING               : 64 66
SUBEQ                : 42
TIMES                : 49
WHILE                : 15
error                : 8

Nonterminals, with rules where they appear

arglist              : 13 77
asgn                 : 5 37
binaryop             : 26
callfunc             : 28
cond                 : 15 16 16 16 17 18
data                 : 24
defn                 : 4
empty                : 2 21 75
expr                 : 7 10 12 20 27 32 40 41 42 43 44 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 62 63 65 76 77
formals              : 67 68 70
list                 : 1 3 4 5 6 7 8 9
logicop              : 39
mathop               : 38
prlist               : 14 65 66
procname             : 67 68
program              : 0
stmt                 : 6 15 16 17 18 18 23
stmtlist             : 19 22 23
unaryop              : 25

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . list
    (2) list -> . empty
    (3) list -> . list NEWLINE
    (4) list -> . list defn NEWLINE
    (5) list -> . list asgn NEWLINE
    (6) list -> . list stmt NEWLINE
    (7) list -> . list expr NEWLINE
    (8) list -> . list error NEWLINE
    (9) list -> . list COMMENT NEWLINE
    (78) empty -> .

    NEWLINE         reduce using rule 78 (empty -> .)
    error           reduce using rule 78 (empty -> .)
    COMMENT         reduce using rule 78 (empty -> .)
    FUNC            reduce using rule 78 (empty -> .)
    PROC            reduce using rule 78 (empty -> .)
    ID              reduce using rule 78 (empty -> .)
    RETURN          reduce using rule 78 (empty -> .)
    PROCEDURE       reduce using rule 78 (empty -> .)
    PRINT           reduce using rule 78 (empty -> .)
    WHILE           reduce using rule 78 (empty -> .)
    FOR             reduce using rule 78 (empty -> .)
    IF              reduce using rule 78 (empty -> .)
    LBRACKET        reduce using rule 78 (empty -> .)
    LPARENT         reduce using rule 78 (empty -> .)
    FLOAT           reduce using rule 78 (empty -> .)
    CONSTANT        reduce using rule 78 (empty -> .)
    MINUS           reduce using rule 78 (empty -> .)
    INC             reduce using rule 78 (empty -> .)
    DEC             reduce using rule 78 (empty -> .)
    BLTIN           reduce using rule 78 (empty -> .)
    $end            reduce using rule 78 (empty -> .)

    list                           shift and go to state 1
    program                        shift and go to state 2
    empty                          shift and go to state 3

state 1

    (1) program -> list .
    (3) list -> list . NEWLINE
    (4) list -> list . defn NEWLINE
    (5) list -> list . asgn NEWLINE
    (6) list -> list . stmt NEWLINE
    (7) list -> list . expr NEWLINE
    (8) list -> list . error NEWLINE
    (9) list -> list . COMMENT NEWLINE
    (67) defn -> . FUNC procname LPARENT formals RPARENT
    (68) defn -> . PROC procname LPARENT formals RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (10) stmt -> . expr
    (11) stmt -> . RETURN
    (12) stmt -> . RETURN expr
    (13) stmt -> . PROCEDURE BEGIN LPARENT arglist RPARENT
    (14) stmt -> . PRINT prlist
    (15) stmt -> . WHILE LPARENT cond RPARENT stmt END
    (16) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END
    (17) stmt -> . IF LPARENT cond RPARENT stmt END
    (18) stmt -> . IF LPARENT cond RPARENT stmt END ELSE stmt END
    (19) stmt -> . LBRACKET stmtlist RBRACKET
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    $end            reduce using rule 1 (program -> list .)
    NEWLINE         shift and go to state 13
    error           shift and go to state 31
    COMMENT         shift and go to state 11
    FUNC            shift and go to state 19
    PROC            shift and go to state 32
    ID              shift and go to state 22
    RETURN          shift and go to state 4
    PROCEDURE       shift and go to state 23
    PRINT           shift and go to state 7
    WHILE           shift and go to state 6
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 5
    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 26
    callfunc                       shift and go to state 27
    stmt                           shift and go to state 17
    asgn                           shift and go to state 14
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 21
    defn                           shift and go to state 20

state 2

    (0) S' -> program .



state 3

    (2) list -> empty .

    NEWLINE         reduce using rule 2 (list -> empty .)
    error           reduce using rule 2 (list -> empty .)
    COMMENT         reduce using rule 2 (list -> empty .)
    FUNC            reduce using rule 2 (list -> empty .)
    PROC            reduce using rule 2 (list -> empty .)
    ID              reduce using rule 2 (list -> empty .)
    RETURN          reduce using rule 2 (list -> empty .)
    PROCEDURE       reduce using rule 2 (list -> empty .)
    PRINT           reduce using rule 2 (list -> empty .)
    WHILE           reduce using rule 2 (list -> empty .)
    FOR             reduce using rule 2 (list -> empty .)
    IF              reduce using rule 2 (list -> empty .)
    LBRACKET        reduce using rule 2 (list -> empty .)
    LPARENT         reduce using rule 2 (list -> empty .)
    FLOAT           reduce using rule 2 (list -> empty .)
    CONSTANT        reduce using rule 2 (list -> empty .)
    MINUS           reduce using rule 2 (list -> empty .)
    INC             reduce using rule 2 (list -> empty .)
    DEC             reduce using rule 2 (list -> empty .)
    BLTIN           reduce using rule 2 (list -> empty .)
    $end            reduce using rule 2 (list -> empty .)


state 4

    (11) stmt -> RETURN .
    (12) stmt -> RETURN . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

  ! shift/reduce conflict for LPARENT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for BLTIN resolved as shift
    END             reduce using rule 11 (stmt -> RETURN .)
    RBRACKET        reduce using rule 11 (stmt -> RETURN .)
    NEWLINE         reduce using rule 11 (stmt -> RETURN .)
    RETURN          reduce using rule 11 (stmt -> RETURN .)
    PROCEDURE       reduce using rule 11 (stmt -> RETURN .)
    PRINT           reduce using rule 11 (stmt -> RETURN .)
    WHILE           reduce using rule 11 (stmt -> RETURN .)
    FOR             reduce using rule 11 (stmt -> RETURN .)
    IF              reduce using rule 11 (stmt -> RETURN .)
    LBRACKET        reduce using rule 11 (stmt -> RETURN .)
    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

  ! LPARENT         [ reduce using rule 11 (stmt -> RETURN .) ]
  ! FLOAT           [ reduce using rule 11 (stmt -> RETURN .) ]
  ! CONSTANT        [ reduce using rule 11 (stmt -> RETURN .) ]
  ! ID              [ reduce using rule 11 (stmt -> RETURN .) ]
  ! MINUS           [ reduce using rule 11 (stmt -> RETURN .) ]
  ! INC             [ reduce using rule 11 (stmt -> RETURN .) ]
  ! DEC             [ reduce using rule 11 (stmt -> RETURN .) ]
  ! BLTIN           [ reduce using rule 11 (stmt -> RETURN .) ]

    unaryop                        shift and go to state 16
    expr                           shift and go to state 36
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 5

    (19) stmt -> LBRACKET . stmtlist RBRACKET
    (21) stmtlist -> . empty
    (22) stmtlist -> . stmtlist NEWLINE
    (23) stmtlist -> . stmtlist stmt
    (78) empty -> .

    RBRACKET        reduce using rule 78 (empty -> .)
    NEWLINE         reduce using rule 78 (empty -> .)
    RETURN          reduce using rule 78 (empty -> .)
    PROCEDURE       reduce using rule 78 (empty -> .)
    PRINT           reduce using rule 78 (empty -> .)
    WHILE           reduce using rule 78 (empty -> .)
    FOR             reduce using rule 78 (empty -> .)
    IF              reduce using rule 78 (empty -> .)
    LBRACKET        reduce using rule 78 (empty -> .)
    LPARENT         reduce using rule 78 (empty -> .)
    FLOAT           reduce using rule 78 (empty -> .)
    CONSTANT        reduce using rule 78 (empty -> .)
    ID              reduce using rule 78 (empty -> .)
    MINUS           reduce using rule 78 (empty -> .)
    INC             reduce using rule 78 (empty -> .)
    DEC             reduce using rule 78 (empty -> .)
    BLTIN           reduce using rule 78 (empty -> .)

    empty                          shift and go to state 38
    stmtlist                       shift and go to state 37

state 6

    (15) stmt -> WHILE . LPARENT cond RPARENT stmt END

    LPARENT         shift and go to state 39


state 7

    (14) stmt -> PRINT . prlist
    (63) prlist -> . expr
    (64) prlist -> . STRING
    (65) prlist -> . prlist COMMA expr
    (66) prlist -> . prlist COMMA STRING
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    STRING          shift and go to state 40
    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 41
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    prlist                         shift and go to state 42
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 8

    (30) data -> CONSTANT .

    RPARENT         reduce using rule 30 (data -> CONSTANT .)
    EXP             reduce using rule 30 (data -> CONSTANT .)
    PLUS            reduce using rule 30 (data -> CONSTANT .)
    MINUS           reduce using rule 30 (data -> CONSTANT .)
    TIMES           reduce using rule 30 (data -> CONSTANT .)
    DIVIDE          reduce using rule 30 (data -> CONSTANT .)
    MOD             reduce using rule 30 (data -> CONSTANT .)
    LT              reduce using rule 30 (data -> CONSTANT .)
    GT              reduce using rule 30 (data -> CONSTANT .)
    LE              reduce using rule 30 (data -> CONSTANT .)
    GE              reduce using rule 30 (data -> CONSTANT .)
    EQ              reduce using rule 30 (data -> CONSTANT .)
    NE              reduce using rule 30 (data -> CONSTANT .)
    OR              reduce using rule 30 (data -> CONSTANT .)
    AND             reduce using rule 30 (data -> CONSTANT .)
    NOT             reduce using rule 30 (data -> CONSTANT .)
    NEWLINE         reduce using rule 30 (data -> CONSTANT .)
    RBRACKET        reduce using rule 30 (data -> CONSTANT .)
    RETURN          reduce using rule 30 (data -> CONSTANT .)
    PROCEDURE       reduce using rule 30 (data -> CONSTANT .)
    PRINT           reduce using rule 30 (data -> CONSTANT .)
    WHILE           reduce using rule 30 (data -> CONSTANT .)
    FOR             reduce using rule 30 (data -> CONSTANT .)
    IF              reduce using rule 30 (data -> CONSTANT .)
    LBRACKET        reduce using rule 30 (data -> CONSTANT .)
    LPARENT         reduce using rule 30 (data -> CONSTANT .)
    FLOAT           reduce using rule 30 (data -> CONSTANT .)
    CONSTANT        reduce using rule 30 (data -> CONSTANT .)
    ID              reduce using rule 30 (data -> CONSTANT .)
    INC             reduce using rule 30 (data -> CONSTANT .)
    DEC             reduce using rule 30 (data -> CONSTANT .)
    BLTIN           reduce using rule 30 (data -> CONSTANT .)
    END             reduce using rule 30 (data -> CONSTANT .)
    COMMA           reduce using rule 30 (data -> CONSTANT .)
    SEMICOLON       reduce using rule 30 (data -> CONSTANT .)


state 9

    (39) binaryop -> logicop .

    EXP             reduce using rule 39 (binaryop -> logicop .)
    PLUS            reduce using rule 39 (binaryop -> logicop .)
    MINUS           reduce using rule 39 (binaryop -> logicop .)
    TIMES           reduce using rule 39 (binaryop -> logicop .)
    DIVIDE          reduce using rule 39 (binaryop -> logicop .)
    MOD             reduce using rule 39 (binaryop -> logicop .)
    LT              reduce using rule 39 (binaryop -> logicop .)
    GT              reduce using rule 39 (binaryop -> logicop .)
    LE              reduce using rule 39 (binaryop -> logicop .)
    GE              reduce using rule 39 (binaryop -> logicop .)
    EQ              reduce using rule 39 (binaryop -> logicop .)
    NE              reduce using rule 39 (binaryop -> logicop .)
    OR              reduce using rule 39 (binaryop -> logicop .)
    AND             reduce using rule 39 (binaryop -> logicop .)
    NOT             reduce using rule 39 (binaryop -> logicop .)
    END             reduce using rule 39 (binaryop -> logicop .)
    RPARENT         reduce using rule 39 (binaryop -> logicop .)
    NEWLINE         reduce using rule 39 (binaryop -> logicop .)
    RBRACKET        reduce using rule 39 (binaryop -> logicop .)
    RETURN          reduce using rule 39 (binaryop -> logicop .)
    PROCEDURE       reduce using rule 39 (binaryop -> logicop .)
    PRINT           reduce using rule 39 (binaryop -> logicop .)
    WHILE           reduce using rule 39 (binaryop -> logicop .)
    FOR             reduce using rule 39 (binaryop -> logicop .)
    IF              reduce using rule 39 (binaryop -> logicop .)
    LBRACKET        reduce using rule 39 (binaryop -> logicop .)
    LPARENT         reduce using rule 39 (binaryop -> logicop .)
    FLOAT           reduce using rule 39 (binaryop -> logicop .)
    CONSTANT        reduce using rule 39 (binaryop -> logicop .)
    ID              reduce using rule 39 (binaryop -> logicop .)
    INC             reduce using rule 39 (binaryop -> logicop .)
    DEC             reduce using rule 39 (binaryop -> logicop .)
    BLTIN           reduce using rule 39 (binaryop -> logicop .)
    COMMA           reduce using rule 39 (binaryop -> logicop .)
    SEMICOLON       reduce using rule 39 (binaryop -> logicop .)


state 10

    (32) unaryop -> MINUS . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 43
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 11

    (9) list -> list COMMENT . NEWLINE

    NEWLINE         shift and go to state 44


state 12

    (27) expr -> LPARENT . expr RPARENT
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 45
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 13

    (3) list -> list NEWLINE .

    NEWLINE         reduce using rule 3 (list -> list NEWLINE .)
    error           reduce using rule 3 (list -> list NEWLINE .)
    COMMENT         reduce using rule 3 (list -> list NEWLINE .)
    FUNC            reduce using rule 3 (list -> list NEWLINE .)
    PROC            reduce using rule 3 (list -> list NEWLINE .)
    ID              reduce using rule 3 (list -> list NEWLINE .)
    RETURN          reduce using rule 3 (list -> list NEWLINE .)
    PROCEDURE       reduce using rule 3 (list -> list NEWLINE .)
    PRINT           reduce using rule 3 (list -> list NEWLINE .)
    WHILE           reduce using rule 3 (list -> list NEWLINE .)
    FOR             reduce using rule 3 (list -> list NEWLINE .)
    IF              reduce using rule 3 (list -> list NEWLINE .)
    LBRACKET        reduce using rule 3 (list -> list NEWLINE .)
    LPARENT         reduce using rule 3 (list -> list NEWLINE .)
    FLOAT           reduce using rule 3 (list -> list NEWLINE .)
    CONSTANT        reduce using rule 3 (list -> list NEWLINE .)
    MINUS           reduce using rule 3 (list -> list NEWLINE .)
    INC             reduce using rule 3 (list -> list NEWLINE .)
    DEC             reduce using rule 3 (list -> list NEWLINE .)
    BLTIN           reduce using rule 3 (list -> list NEWLINE .)
    $end            reduce using rule 3 (list -> list NEWLINE .)


state 14

    (5) list -> list asgn . NEWLINE
    (37) binaryop -> asgn .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 46
    EXP             reduce using rule 37 (binaryop -> asgn .)
    PLUS            reduce using rule 37 (binaryop -> asgn .)
    MINUS           reduce using rule 37 (binaryop -> asgn .)
    TIMES           reduce using rule 37 (binaryop -> asgn .)
    DIVIDE          reduce using rule 37 (binaryop -> asgn .)
    MOD             reduce using rule 37 (binaryop -> asgn .)
    LT              reduce using rule 37 (binaryop -> asgn .)
    GT              reduce using rule 37 (binaryop -> asgn .)
    LE              reduce using rule 37 (binaryop -> asgn .)
    GE              reduce using rule 37 (binaryop -> asgn .)
    EQ              reduce using rule 37 (binaryop -> asgn .)
    NE              reduce using rule 37 (binaryop -> asgn .)
    OR              reduce using rule 37 (binaryop -> asgn .)
    AND             reduce using rule 37 (binaryop -> asgn .)
    NOT             reduce using rule 37 (binaryop -> asgn .)

  ! NEWLINE         [ reduce using rule 37 (binaryop -> asgn .) ]


state 15

    (16) stmt -> FOR . LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END

    LPARENT         shift and go to state 47


state 16

    (25) expr -> unaryop .

    EXP             reduce using rule 25 (expr -> unaryop .)
    PLUS            reduce using rule 25 (expr -> unaryop .)
    MINUS           reduce using rule 25 (expr -> unaryop .)
    TIMES           reduce using rule 25 (expr -> unaryop .)
    DIVIDE          reduce using rule 25 (expr -> unaryop .)
    MOD             reduce using rule 25 (expr -> unaryop .)
    LT              reduce using rule 25 (expr -> unaryop .)
    GT              reduce using rule 25 (expr -> unaryop .)
    LE              reduce using rule 25 (expr -> unaryop .)
    GE              reduce using rule 25 (expr -> unaryop .)
    EQ              reduce using rule 25 (expr -> unaryop .)
    NE              reduce using rule 25 (expr -> unaryop .)
    OR              reduce using rule 25 (expr -> unaryop .)
    AND             reduce using rule 25 (expr -> unaryop .)
    NOT             reduce using rule 25 (expr -> unaryop .)
    NEWLINE         reduce using rule 25 (expr -> unaryop .)
    RBRACKET        reduce using rule 25 (expr -> unaryop .)
    RETURN          reduce using rule 25 (expr -> unaryop .)
    PROCEDURE       reduce using rule 25 (expr -> unaryop .)
    PRINT           reduce using rule 25 (expr -> unaryop .)
    WHILE           reduce using rule 25 (expr -> unaryop .)
    FOR             reduce using rule 25 (expr -> unaryop .)
    IF              reduce using rule 25 (expr -> unaryop .)
    LBRACKET        reduce using rule 25 (expr -> unaryop .)
    LPARENT         reduce using rule 25 (expr -> unaryop .)
    FLOAT           reduce using rule 25 (expr -> unaryop .)
    CONSTANT        reduce using rule 25 (expr -> unaryop .)
    ID              reduce using rule 25 (expr -> unaryop .)
    INC             reduce using rule 25 (expr -> unaryop .)
    DEC             reduce using rule 25 (expr -> unaryop .)
    BLTIN           reduce using rule 25 (expr -> unaryop .)
    END             reduce using rule 25 (expr -> unaryop .)
    COMMA           reduce using rule 25 (expr -> unaryop .)
    RPARENT         reduce using rule 25 (expr -> unaryop .)
    SEMICOLON       reduce using rule 25 (expr -> unaryop .)


state 17

    (6) list -> list stmt . NEWLINE

    NEWLINE         shift and go to state 48


state 18

    (61) callfunc -> BLTIN . LPARENT expr RPARENT

    LPARENT         shift and go to state 49


state 19

    (67) defn -> FUNC . procname LPARENT formals RPARENT
    (71) procname -> . FUNCTION
    (72) procname -> . ID
    (73) procname -> . PROCEDURE
    (74) procname -> . BLTIN

    FUNCTION        shift and go to state 50
    ID              shift and go to state 53
    PROCEDURE       shift and go to state 54
    BLTIN           shift and go to state 51

    procname                       shift and go to state 52

state 20

    (4) list -> list defn . NEWLINE

    NEWLINE         shift and go to state 55


state 21

    (24) expr -> data .

    EXP             reduce using rule 24 (expr -> data .)
    PLUS            reduce using rule 24 (expr -> data .)
    MINUS           reduce using rule 24 (expr -> data .)
    TIMES           reduce using rule 24 (expr -> data .)
    DIVIDE          reduce using rule 24 (expr -> data .)
    MOD             reduce using rule 24 (expr -> data .)
    LT              reduce using rule 24 (expr -> data .)
    GT              reduce using rule 24 (expr -> data .)
    LE              reduce using rule 24 (expr -> data .)
    GE              reduce using rule 24 (expr -> data .)
    EQ              reduce using rule 24 (expr -> data .)
    NE              reduce using rule 24 (expr -> data .)
    OR              reduce using rule 24 (expr -> data .)
    AND             reduce using rule 24 (expr -> data .)
    NOT             reduce using rule 24 (expr -> data .)
    NEWLINE         reduce using rule 24 (expr -> data .)
    RBRACKET        reduce using rule 24 (expr -> data .)
    RETURN          reduce using rule 24 (expr -> data .)
    PROCEDURE       reduce using rule 24 (expr -> data .)
    PRINT           reduce using rule 24 (expr -> data .)
    WHILE           reduce using rule 24 (expr -> data .)
    FOR             reduce using rule 24 (expr -> data .)
    IF              reduce using rule 24 (expr -> data .)
    LBRACKET        reduce using rule 24 (expr -> data .)
    LPARENT         reduce using rule 24 (expr -> data .)
    FLOAT           reduce using rule 24 (expr -> data .)
    CONSTANT        reduce using rule 24 (expr -> data .)
    ID              reduce using rule 24 (expr -> data .)
    INC             reduce using rule 24 (expr -> data .)
    DEC             reduce using rule 24 (expr -> data .)
    BLTIN           reduce using rule 24 (expr -> data .)
    END             reduce using rule 24 (expr -> data .)
    COMMA           reduce using rule 24 (expr -> data .)
    RPARENT         reduce using rule 24 (expr -> data .)
    SEMICOLON       reduce using rule 24 (expr -> data .)


state 22

    (40) asgn -> ID . ASSIGN expr
    (41) asgn -> ID . ADDEQ expr
    (42) asgn -> ID . SUBEQ expr
    (43) asgn -> ID . MULEQ expr
    (44) asgn -> ID . DIVEQ expr
    (45) asgn -> ID . MODEQ expr
    (31) data -> ID .
    (35) unaryop -> ID . INC
    (36) unaryop -> ID . DEC
    (62) callfunc -> ID . LPARENT expr RPARENT

    ASSIGN          shift and go to state 58
    ADDEQ           shift and go to state 61
    SUBEQ           shift and go to state 59
    MULEQ           shift and go to state 60
    DIVEQ           shift and go to state 63
    MODEQ           shift and go to state 57
    NEWLINE         reduce using rule 31 (data -> ID .)
    EXP             reduce using rule 31 (data -> ID .)
    PLUS            reduce using rule 31 (data -> ID .)
    MINUS           reduce using rule 31 (data -> ID .)
    TIMES           reduce using rule 31 (data -> ID .)
    DIVIDE          reduce using rule 31 (data -> ID .)
    MOD             reduce using rule 31 (data -> ID .)
    LT              reduce using rule 31 (data -> ID .)
    GT              reduce using rule 31 (data -> ID .)
    LE              reduce using rule 31 (data -> ID .)
    GE              reduce using rule 31 (data -> ID .)
    EQ              reduce using rule 31 (data -> ID .)
    NE              reduce using rule 31 (data -> ID .)
    OR              reduce using rule 31 (data -> ID .)
    AND             reduce using rule 31 (data -> ID .)
    NOT             reduce using rule 31 (data -> ID .)
    INC             shift and go to state 64
    DEC             shift and go to state 62
    LPARENT         shift and go to state 56


state 23

    (13) stmt -> PROCEDURE . BEGIN LPARENT arglist RPARENT

    BEGIN           shift and go to state 65


state 24

    (17) stmt -> IF . LPARENT cond RPARENT stmt END
    (18) stmt -> IF . LPARENT cond RPARENT stmt END ELSE stmt END

    LPARENT         shift and go to state 66


state 25

    (34) unaryop -> DEC . ID

    ID              shift and go to state 67


state 26

    (7) list -> list expr . NEWLINE
    (10) stmt -> expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 72
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! NEWLINE         [ reduce using rule 10 (stmt -> expr .) ]


state 27

    (28) expr -> callfunc .

    EXP             reduce using rule 28 (expr -> callfunc .)
    PLUS            reduce using rule 28 (expr -> callfunc .)
    MINUS           reduce using rule 28 (expr -> callfunc .)
    TIMES           reduce using rule 28 (expr -> callfunc .)
    DIVIDE          reduce using rule 28 (expr -> callfunc .)
    MOD             reduce using rule 28 (expr -> callfunc .)
    LT              reduce using rule 28 (expr -> callfunc .)
    GT              reduce using rule 28 (expr -> callfunc .)
    LE              reduce using rule 28 (expr -> callfunc .)
    GE              reduce using rule 28 (expr -> callfunc .)
    EQ              reduce using rule 28 (expr -> callfunc .)
    NE              reduce using rule 28 (expr -> callfunc .)
    OR              reduce using rule 28 (expr -> callfunc .)
    AND             reduce using rule 28 (expr -> callfunc .)
    NOT             reduce using rule 28 (expr -> callfunc .)
    NEWLINE         reduce using rule 28 (expr -> callfunc .)
    RBRACKET        reduce using rule 28 (expr -> callfunc .)
    RETURN          reduce using rule 28 (expr -> callfunc .)
    PROCEDURE       reduce using rule 28 (expr -> callfunc .)
    PRINT           reduce using rule 28 (expr -> callfunc .)
    WHILE           reduce using rule 28 (expr -> callfunc .)
    FOR             reduce using rule 28 (expr -> callfunc .)
    IF              reduce using rule 28 (expr -> callfunc .)
    LBRACKET        reduce using rule 28 (expr -> callfunc .)
    LPARENT         reduce using rule 28 (expr -> callfunc .)
    FLOAT           reduce using rule 28 (expr -> callfunc .)
    CONSTANT        reduce using rule 28 (expr -> callfunc .)
    ID              reduce using rule 28 (expr -> callfunc .)
    INC             reduce using rule 28 (expr -> callfunc .)
    DEC             reduce using rule 28 (expr -> callfunc .)
    BLTIN           reduce using rule 28 (expr -> callfunc .)
    END             reduce using rule 28 (expr -> callfunc .)
    COMMA           reduce using rule 28 (expr -> callfunc .)
    RPARENT         reduce using rule 28 (expr -> callfunc .)
    SEMICOLON       reduce using rule 28 (expr -> callfunc .)


state 28

    (29) data -> FLOAT .

    RPARENT         reduce using rule 29 (data -> FLOAT .)
    EXP             reduce using rule 29 (data -> FLOAT .)
    PLUS            reduce using rule 29 (data -> FLOAT .)
    MINUS           reduce using rule 29 (data -> FLOAT .)
    TIMES           reduce using rule 29 (data -> FLOAT .)
    DIVIDE          reduce using rule 29 (data -> FLOAT .)
    MOD             reduce using rule 29 (data -> FLOAT .)
    LT              reduce using rule 29 (data -> FLOAT .)
    GT              reduce using rule 29 (data -> FLOAT .)
    LE              reduce using rule 29 (data -> FLOAT .)
    GE              reduce using rule 29 (data -> FLOAT .)
    EQ              reduce using rule 29 (data -> FLOAT .)
    NE              reduce using rule 29 (data -> FLOAT .)
    OR              reduce using rule 29 (data -> FLOAT .)
    AND             reduce using rule 29 (data -> FLOAT .)
    NOT             reduce using rule 29 (data -> FLOAT .)
    NEWLINE         reduce using rule 29 (data -> FLOAT .)
    RBRACKET        reduce using rule 29 (data -> FLOAT .)
    RETURN          reduce using rule 29 (data -> FLOAT .)
    PROCEDURE       reduce using rule 29 (data -> FLOAT .)
    PRINT           reduce using rule 29 (data -> FLOAT .)
    WHILE           reduce using rule 29 (data -> FLOAT .)
    FOR             reduce using rule 29 (data -> FLOAT .)
    IF              reduce using rule 29 (data -> FLOAT .)
    LBRACKET        reduce using rule 29 (data -> FLOAT .)
    LPARENT         reduce using rule 29 (data -> FLOAT .)
    FLOAT           reduce using rule 29 (data -> FLOAT .)
    CONSTANT        reduce using rule 29 (data -> FLOAT .)
    ID              reduce using rule 29 (data -> FLOAT .)
    INC             reduce using rule 29 (data -> FLOAT .)
    DEC             reduce using rule 29 (data -> FLOAT .)
    BLTIN           reduce using rule 29 (data -> FLOAT .)
    END             reduce using rule 29 (data -> FLOAT .)
    COMMA           reduce using rule 29 (data -> FLOAT .)
    SEMICOLON       reduce using rule 29 (data -> FLOAT .)


state 29

    (38) binaryop -> mathop .

    EXP             reduce using rule 38 (binaryop -> mathop .)
    PLUS            reduce using rule 38 (binaryop -> mathop .)
    MINUS           reduce using rule 38 (binaryop -> mathop .)
    TIMES           reduce using rule 38 (binaryop -> mathop .)
    DIVIDE          reduce using rule 38 (binaryop -> mathop .)
    MOD             reduce using rule 38 (binaryop -> mathop .)
    LT              reduce using rule 38 (binaryop -> mathop .)
    GT              reduce using rule 38 (binaryop -> mathop .)
    LE              reduce using rule 38 (binaryop -> mathop .)
    GE              reduce using rule 38 (binaryop -> mathop .)
    EQ              reduce using rule 38 (binaryop -> mathop .)
    NE              reduce using rule 38 (binaryop -> mathop .)
    OR              reduce using rule 38 (binaryop -> mathop .)
    AND             reduce using rule 38 (binaryop -> mathop .)
    NOT             reduce using rule 38 (binaryop -> mathop .)
    END             reduce using rule 38 (binaryop -> mathop .)
    RPARENT         reduce using rule 38 (binaryop -> mathop .)
    NEWLINE         reduce using rule 38 (binaryop -> mathop .)
    RBRACKET        reduce using rule 38 (binaryop -> mathop .)
    RETURN          reduce using rule 38 (binaryop -> mathop .)
    PROCEDURE       reduce using rule 38 (binaryop -> mathop .)
    PRINT           reduce using rule 38 (binaryop -> mathop .)
    WHILE           reduce using rule 38 (binaryop -> mathop .)
    FOR             reduce using rule 38 (binaryop -> mathop .)
    IF              reduce using rule 38 (binaryop -> mathop .)
    LBRACKET        reduce using rule 38 (binaryop -> mathop .)
    LPARENT         reduce using rule 38 (binaryop -> mathop .)
    FLOAT           reduce using rule 38 (binaryop -> mathop .)
    CONSTANT        reduce using rule 38 (binaryop -> mathop .)
    ID              reduce using rule 38 (binaryop -> mathop .)
    INC             reduce using rule 38 (binaryop -> mathop .)
    DEC             reduce using rule 38 (binaryop -> mathop .)
    BLTIN           reduce using rule 38 (binaryop -> mathop .)
    COMMA           reduce using rule 38 (binaryop -> mathop .)
    SEMICOLON       reduce using rule 38 (binaryop -> mathop .)


state 30

    (26) expr -> binaryop .

    EXP             reduce using rule 26 (expr -> binaryop .)
    PLUS            reduce using rule 26 (expr -> binaryop .)
    MINUS           reduce using rule 26 (expr -> binaryop .)
    TIMES           reduce using rule 26 (expr -> binaryop .)
    DIVIDE          reduce using rule 26 (expr -> binaryop .)
    MOD             reduce using rule 26 (expr -> binaryop .)
    LT              reduce using rule 26 (expr -> binaryop .)
    GT              reduce using rule 26 (expr -> binaryop .)
    LE              reduce using rule 26 (expr -> binaryop .)
    GE              reduce using rule 26 (expr -> binaryop .)
    EQ              reduce using rule 26 (expr -> binaryop .)
    NE              reduce using rule 26 (expr -> binaryop .)
    OR              reduce using rule 26 (expr -> binaryop .)
    AND             reduce using rule 26 (expr -> binaryop .)
    NOT             reduce using rule 26 (expr -> binaryop .)
    NEWLINE         reduce using rule 26 (expr -> binaryop .)
    RBRACKET        reduce using rule 26 (expr -> binaryop .)
    RETURN          reduce using rule 26 (expr -> binaryop .)
    PROCEDURE       reduce using rule 26 (expr -> binaryop .)
    PRINT           reduce using rule 26 (expr -> binaryop .)
    WHILE           reduce using rule 26 (expr -> binaryop .)
    FOR             reduce using rule 26 (expr -> binaryop .)
    IF              reduce using rule 26 (expr -> binaryop .)
    LBRACKET        reduce using rule 26 (expr -> binaryop .)
    LPARENT         reduce using rule 26 (expr -> binaryop .)
    FLOAT           reduce using rule 26 (expr -> binaryop .)
    CONSTANT        reduce using rule 26 (expr -> binaryop .)
    ID              reduce using rule 26 (expr -> binaryop .)
    INC             reduce using rule 26 (expr -> binaryop .)
    DEC             reduce using rule 26 (expr -> binaryop .)
    BLTIN           reduce using rule 26 (expr -> binaryop .)
    END             reduce using rule 26 (expr -> binaryop .)
    COMMA           reduce using rule 26 (expr -> binaryop .)
    RPARENT         reduce using rule 26 (expr -> binaryop .)
    SEMICOLON       reduce using rule 26 (expr -> binaryop .)


state 31

    (8) list -> list error . NEWLINE

    NEWLINE         shift and go to state 84


state 32

    (68) defn -> PROC . procname LPARENT formals RPARENT
    (71) procname -> . FUNCTION
    (72) procname -> . ID
    (73) procname -> . PROCEDURE
    (74) procname -> . BLTIN

    FUNCTION        shift and go to state 50
    ID              shift and go to state 53
    PROCEDURE       shift and go to state 54
    BLTIN           shift and go to state 51

    procname                       shift and go to state 85

state 33

    (33) unaryop -> INC . ID

    ID              shift and go to state 86


state 34

    (37) binaryop -> asgn .

    EXP             reduce using rule 37 (binaryop -> asgn .)
    PLUS            reduce using rule 37 (binaryop -> asgn .)
    MINUS           reduce using rule 37 (binaryop -> asgn .)
    TIMES           reduce using rule 37 (binaryop -> asgn .)
    DIVIDE          reduce using rule 37 (binaryop -> asgn .)
    MOD             reduce using rule 37 (binaryop -> asgn .)
    LT              reduce using rule 37 (binaryop -> asgn .)
    GT              reduce using rule 37 (binaryop -> asgn .)
    LE              reduce using rule 37 (binaryop -> asgn .)
    GE              reduce using rule 37 (binaryop -> asgn .)
    EQ              reduce using rule 37 (binaryop -> asgn .)
    NE              reduce using rule 37 (binaryop -> asgn .)
    OR              reduce using rule 37 (binaryop -> asgn .)
    AND             reduce using rule 37 (binaryop -> asgn .)
    NOT             reduce using rule 37 (binaryop -> asgn .)
    END             reduce using rule 37 (binaryop -> asgn .)
    RPARENT         reduce using rule 37 (binaryop -> asgn .)
    NEWLINE         reduce using rule 37 (binaryop -> asgn .)
    RBRACKET        reduce using rule 37 (binaryop -> asgn .)
    RETURN          reduce using rule 37 (binaryop -> asgn .)
    PROCEDURE       reduce using rule 37 (binaryop -> asgn .)
    PRINT           reduce using rule 37 (binaryop -> asgn .)
    WHILE           reduce using rule 37 (binaryop -> asgn .)
    FOR             reduce using rule 37 (binaryop -> asgn .)
    IF              reduce using rule 37 (binaryop -> asgn .)
    LBRACKET        reduce using rule 37 (binaryop -> asgn .)
    LPARENT         reduce using rule 37 (binaryop -> asgn .)
    FLOAT           reduce using rule 37 (binaryop -> asgn .)
    CONSTANT        reduce using rule 37 (binaryop -> asgn .)
    ID              reduce using rule 37 (binaryop -> asgn .)
    INC             reduce using rule 37 (binaryop -> asgn .)
    DEC             reduce using rule 37 (binaryop -> asgn .)
    BLTIN           reduce using rule 37 (binaryop -> asgn .)
    COMMA           reduce using rule 37 (binaryop -> asgn .)
    SEMICOLON       reduce using rule 37 (binaryop -> asgn .)


state 35

    (31) data -> ID .
    (35) unaryop -> ID . INC
    (36) unaryop -> ID . DEC
    (62) callfunc -> ID . LPARENT expr RPARENT
    (40) asgn -> ID . ASSIGN expr
    (41) asgn -> ID . ADDEQ expr
    (42) asgn -> ID . SUBEQ expr
    (43) asgn -> ID . MULEQ expr
    (44) asgn -> ID . DIVEQ expr
    (45) asgn -> ID . MODEQ expr

  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for LPARENT resolved as shift
    RPARENT         reduce using rule 31 (data -> ID .)
    EXP             reduce using rule 31 (data -> ID .)
    PLUS            reduce using rule 31 (data -> ID .)
    MINUS           reduce using rule 31 (data -> ID .)
    TIMES           reduce using rule 31 (data -> ID .)
    DIVIDE          reduce using rule 31 (data -> ID .)
    MOD             reduce using rule 31 (data -> ID .)
    LT              reduce using rule 31 (data -> ID .)
    GT              reduce using rule 31 (data -> ID .)
    LE              reduce using rule 31 (data -> ID .)
    GE              reduce using rule 31 (data -> ID .)
    EQ              reduce using rule 31 (data -> ID .)
    NE              reduce using rule 31 (data -> ID .)
    OR              reduce using rule 31 (data -> ID .)
    AND             reduce using rule 31 (data -> ID .)
    NOT             reduce using rule 31 (data -> ID .)
    NEWLINE         reduce using rule 31 (data -> ID .)
    RBRACKET        reduce using rule 31 (data -> ID .)
    RETURN          reduce using rule 31 (data -> ID .)
    PROCEDURE       reduce using rule 31 (data -> ID .)
    PRINT           reduce using rule 31 (data -> ID .)
    WHILE           reduce using rule 31 (data -> ID .)
    FOR             reduce using rule 31 (data -> ID .)
    IF              reduce using rule 31 (data -> ID .)
    LBRACKET        reduce using rule 31 (data -> ID .)
    FLOAT           reduce using rule 31 (data -> ID .)
    CONSTANT        reduce using rule 31 (data -> ID .)
    ID              reduce using rule 31 (data -> ID .)
    BLTIN           reduce using rule 31 (data -> ID .)
    END             reduce using rule 31 (data -> ID .)
    COMMA           reduce using rule 31 (data -> ID .)
    SEMICOLON       reduce using rule 31 (data -> ID .)
    INC             shift and go to state 64
    DEC             shift and go to state 62
    LPARENT         shift and go to state 56
    ASSIGN          shift and go to state 58
    ADDEQ           shift and go to state 61
    SUBEQ           shift and go to state 59
    MULEQ           shift and go to state 60
    DIVEQ           shift and go to state 63
    MODEQ           shift and go to state 57

  ! LPARENT         [ reduce using rule 31 (data -> ID .) ]
  ! INC             [ reduce using rule 31 (data -> ID .) ]
  ! DEC             [ reduce using rule 31 (data -> ID .) ]


state 36

    (12) stmt -> RETURN expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for MINUS resolved as shift
    END             reduce using rule 12 (stmt -> RETURN expr .)
    RBRACKET        reduce using rule 12 (stmt -> RETURN expr .)
    NEWLINE         reduce using rule 12 (stmt -> RETURN expr .)
    RETURN          reduce using rule 12 (stmt -> RETURN expr .)
    PROCEDURE       reduce using rule 12 (stmt -> RETURN expr .)
    PRINT           reduce using rule 12 (stmt -> RETURN expr .)
    WHILE           reduce using rule 12 (stmt -> RETURN expr .)
    FOR             reduce using rule 12 (stmt -> RETURN expr .)
    IF              reduce using rule 12 (stmt -> RETURN expr .)
    LBRACKET        reduce using rule 12 (stmt -> RETURN expr .)
    LPARENT         reduce using rule 12 (stmt -> RETURN expr .)
    FLOAT           reduce using rule 12 (stmt -> RETURN expr .)
    CONSTANT        reduce using rule 12 (stmt -> RETURN expr .)
    ID              reduce using rule 12 (stmt -> RETURN expr .)
    INC             reduce using rule 12 (stmt -> RETURN expr .)
    DEC             reduce using rule 12 (stmt -> RETURN expr .)
    BLTIN           reduce using rule 12 (stmt -> RETURN expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! MINUS           [ reduce using rule 12 (stmt -> RETURN expr .) ]


state 37

    (19) stmt -> LBRACKET stmtlist . RBRACKET
    (22) stmtlist -> stmtlist . NEWLINE
    (23) stmtlist -> stmtlist . stmt
    (10) stmt -> . expr
    (11) stmt -> . RETURN
    (12) stmt -> . RETURN expr
    (13) stmt -> . PROCEDURE BEGIN LPARENT arglist RPARENT
    (14) stmt -> . PRINT prlist
    (15) stmt -> . WHILE LPARENT cond RPARENT stmt END
    (16) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END
    (17) stmt -> . IF LPARENT cond RPARENT stmt END
    (18) stmt -> . IF LPARENT cond RPARENT stmt END ELSE stmt END
    (19) stmt -> . LBRACKET stmtlist RBRACKET
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    RBRACKET        shift and go to state 90
    NEWLINE         shift and go to state 87
    RETURN          shift and go to state 4
    PROCEDURE       shift and go to state 23
    PRINT           shift and go to state 7
    WHILE           shift and go to state 6
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 5
    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 89
    callfunc                       shift and go to state 27
    stmt                           shift and go to state 88
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 38

    (21) stmtlist -> empty .

    RBRACKET        reduce using rule 21 (stmtlist -> empty .)
    NEWLINE         reduce using rule 21 (stmtlist -> empty .)
    RETURN          reduce using rule 21 (stmtlist -> empty .)
    PROCEDURE       reduce using rule 21 (stmtlist -> empty .)
    PRINT           reduce using rule 21 (stmtlist -> empty .)
    WHILE           reduce using rule 21 (stmtlist -> empty .)
    FOR             reduce using rule 21 (stmtlist -> empty .)
    IF              reduce using rule 21 (stmtlist -> empty .)
    LBRACKET        reduce using rule 21 (stmtlist -> empty .)
    LPARENT         reduce using rule 21 (stmtlist -> empty .)
    FLOAT           reduce using rule 21 (stmtlist -> empty .)
    CONSTANT        reduce using rule 21 (stmtlist -> empty .)
    ID              reduce using rule 21 (stmtlist -> empty .)
    MINUS           reduce using rule 21 (stmtlist -> empty .)
    INC             reduce using rule 21 (stmtlist -> empty .)
    DEC             reduce using rule 21 (stmtlist -> empty .)
    BLTIN           reduce using rule 21 (stmtlist -> empty .)


state 39

    (15) stmt -> WHILE LPARENT . cond RPARENT stmt END
    (20) cond -> . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 92
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    cond                           shift and go to state 91
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 40

    (64) prlist -> STRING .

    COMMA           reduce using rule 64 (prlist -> STRING .)
    NEWLINE         reduce using rule 64 (prlist -> STRING .)
    RBRACKET        reduce using rule 64 (prlist -> STRING .)
    RETURN          reduce using rule 64 (prlist -> STRING .)
    PROCEDURE       reduce using rule 64 (prlist -> STRING .)
    PRINT           reduce using rule 64 (prlist -> STRING .)
    WHILE           reduce using rule 64 (prlist -> STRING .)
    FOR             reduce using rule 64 (prlist -> STRING .)
    IF              reduce using rule 64 (prlist -> STRING .)
    LBRACKET        reduce using rule 64 (prlist -> STRING .)
    LPARENT         reduce using rule 64 (prlist -> STRING .)
    FLOAT           reduce using rule 64 (prlist -> STRING .)
    CONSTANT        reduce using rule 64 (prlist -> STRING .)
    ID              reduce using rule 64 (prlist -> STRING .)
    MINUS           reduce using rule 64 (prlist -> STRING .)
    INC             reduce using rule 64 (prlist -> STRING .)
    DEC             reduce using rule 64 (prlist -> STRING .)
    BLTIN           reduce using rule 64 (prlist -> STRING .)
    END             reduce using rule 64 (prlist -> STRING .)


state 41

    (63) prlist -> expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for MINUS resolved as shift
    COMMA           reduce using rule 63 (prlist -> expr .)
    NEWLINE         reduce using rule 63 (prlist -> expr .)
    RBRACKET        reduce using rule 63 (prlist -> expr .)
    RETURN          reduce using rule 63 (prlist -> expr .)
    PROCEDURE       reduce using rule 63 (prlist -> expr .)
    PRINT           reduce using rule 63 (prlist -> expr .)
    WHILE           reduce using rule 63 (prlist -> expr .)
    FOR             reduce using rule 63 (prlist -> expr .)
    IF              reduce using rule 63 (prlist -> expr .)
    LBRACKET        reduce using rule 63 (prlist -> expr .)
    LPARENT         reduce using rule 63 (prlist -> expr .)
    FLOAT           reduce using rule 63 (prlist -> expr .)
    CONSTANT        reduce using rule 63 (prlist -> expr .)
    ID              reduce using rule 63 (prlist -> expr .)
    INC             reduce using rule 63 (prlist -> expr .)
    DEC             reduce using rule 63 (prlist -> expr .)
    BLTIN           reduce using rule 63 (prlist -> expr .)
    END             reduce using rule 63 (prlist -> expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! MINUS           [ reduce using rule 63 (prlist -> expr .) ]


state 42

    (14) stmt -> PRINT prlist .
    (65) prlist -> prlist . COMMA expr
    (66) prlist -> prlist . COMMA STRING

    END             reduce using rule 14 (stmt -> PRINT prlist .)
    RBRACKET        reduce using rule 14 (stmt -> PRINT prlist .)
    NEWLINE         reduce using rule 14 (stmt -> PRINT prlist .)
    RETURN          reduce using rule 14 (stmt -> PRINT prlist .)
    PROCEDURE       reduce using rule 14 (stmt -> PRINT prlist .)
    PRINT           reduce using rule 14 (stmt -> PRINT prlist .)
    WHILE           reduce using rule 14 (stmt -> PRINT prlist .)
    FOR             reduce using rule 14 (stmt -> PRINT prlist .)
    IF              reduce using rule 14 (stmt -> PRINT prlist .)
    LBRACKET        reduce using rule 14 (stmt -> PRINT prlist .)
    LPARENT         reduce using rule 14 (stmt -> PRINT prlist .)
    FLOAT           reduce using rule 14 (stmt -> PRINT prlist .)
    CONSTANT        reduce using rule 14 (stmt -> PRINT prlist .)
    ID              reduce using rule 14 (stmt -> PRINT prlist .)
    MINUS           reduce using rule 14 (stmt -> PRINT prlist .)
    INC             reduce using rule 14 (stmt -> PRINT prlist .)
    DEC             reduce using rule 14 (stmt -> PRINT prlist .)
    BLTIN           reduce using rule 14 (stmt -> PRINT prlist .)
    COMMA           shift and go to state 93


state 43

    (32) unaryop -> MINUS expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NEWLINE         reduce using rule 32 (unaryop -> MINUS expr .)
    RBRACKET        reduce using rule 32 (unaryop -> MINUS expr .)
    RETURN          reduce using rule 32 (unaryop -> MINUS expr .)
    PROCEDURE       reduce using rule 32 (unaryop -> MINUS expr .)
    PRINT           reduce using rule 32 (unaryop -> MINUS expr .)
    WHILE           reduce using rule 32 (unaryop -> MINUS expr .)
    FOR             reduce using rule 32 (unaryop -> MINUS expr .)
    IF              reduce using rule 32 (unaryop -> MINUS expr .)
    LBRACKET        reduce using rule 32 (unaryop -> MINUS expr .)
    LPARENT         reduce using rule 32 (unaryop -> MINUS expr .)
    FLOAT           reduce using rule 32 (unaryop -> MINUS expr .)
    CONSTANT        reduce using rule 32 (unaryop -> MINUS expr .)
    ID              reduce using rule 32 (unaryop -> MINUS expr .)
    INC             reduce using rule 32 (unaryop -> MINUS expr .)
    DEC             reduce using rule 32 (unaryop -> MINUS expr .)
    BLTIN           reduce using rule 32 (unaryop -> MINUS expr .)
    END             reduce using rule 32 (unaryop -> MINUS expr .)
    COMMA           reduce using rule 32 (unaryop -> MINUS expr .)
    RPARENT         reduce using rule 32 (unaryop -> MINUS expr .)
    SEMICOLON       reduce using rule 32 (unaryop -> MINUS expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! PLUS            [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! MINUS           [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! TIMES           [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! MOD             [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! LT              [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! GT              [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! LE              [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! GE              [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! EQ              [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! NE              [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! OR              [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! AND             [ reduce using rule 32 (unaryop -> MINUS expr .) ]
  ! NOT             [ reduce using rule 32 (unaryop -> MINUS expr .) ]


state 44

    (9) list -> list COMMENT NEWLINE .

    NEWLINE         reduce using rule 9 (list -> list COMMENT NEWLINE .)
    error           reduce using rule 9 (list -> list COMMENT NEWLINE .)
    COMMENT         reduce using rule 9 (list -> list COMMENT NEWLINE .)
    FUNC            reduce using rule 9 (list -> list COMMENT NEWLINE .)
    PROC            reduce using rule 9 (list -> list COMMENT NEWLINE .)
    ID              reduce using rule 9 (list -> list COMMENT NEWLINE .)
    RETURN          reduce using rule 9 (list -> list COMMENT NEWLINE .)
    PROCEDURE       reduce using rule 9 (list -> list COMMENT NEWLINE .)
    PRINT           reduce using rule 9 (list -> list COMMENT NEWLINE .)
    WHILE           reduce using rule 9 (list -> list COMMENT NEWLINE .)
    FOR             reduce using rule 9 (list -> list COMMENT NEWLINE .)
    IF              reduce using rule 9 (list -> list COMMENT NEWLINE .)
    LBRACKET        reduce using rule 9 (list -> list COMMENT NEWLINE .)
    LPARENT         reduce using rule 9 (list -> list COMMENT NEWLINE .)
    FLOAT           reduce using rule 9 (list -> list COMMENT NEWLINE .)
    CONSTANT        reduce using rule 9 (list -> list COMMENT NEWLINE .)
    MINUS           reduce using rule 9 (list -> list COMMENT NEWLINE .)
    INC             reduce using rule 9 (list -> list COMMENT NEWLINE .)
    DEC             reduce using rule 9 (list -> list COMMENT NEWLINE .)
    BLTIN           reduce using rule 9 (list -> list COMMENT NEWLINE .)
    $end            reduce using rule 9 (list -> list COMMENT NEWLINE .)


state 45

    (27) expr -> LPARENT expr . RPARENT
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

    RPARENT         shift and go to state 94
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79


state 46

    (5) list -> list asgn NEWLINE .

    NEWLINE         reduce using rule 5 (list -> list asgn NEWLINE .)
    error           reduce using rule 5 (list -> list asgn NEWLINE .)
    COMMENT         reduce using rule 5 (list -> list asgn NEWLINE .)
    FUNC            reduce using rule 5 (list -> list asgn NEWLINE .)
    PROC            reduce using rule 5 (list -> list asgn NEWLINE .)
    ID              reduce using rule 5 (list -> list asgn NEWLINE .)
    RETURN          reduce using rule 5 (list -> list asgn NEWLINE .)
    PROCEDURE       reduce using rule 5 (list -> list asgn NEWLINE .)
    PRINT           reduce using rule 5 (list -> list asgn NEWLINE .)
    WHILE           reduce using rule 5 (list -> list asgn NEWLINE .)
    FOR             reduce using rule 5 (list -> list asgn NEWLINE .)
    IF              reduce using rule 5 (list -> list asgn NEWLINE .)
    LBRACKET        reduce using rule 5 (list -> list asgn NEWLINE .)
    LPARENT         reduce using rule 5 (list -> list asgn NEWLINE .)
    FLOAT           reduce using rule 5 (list -> list asgn NEWLINE .)
    CONSTANT        reduce using rule 5 (list -> list asgn NEWLINE .)
    MINUS           reduce using rule 5 (list -> list asgn NEWLINE .)
    INC             reduce using rule 5 (list -> list asgn NEWLINE .)
    DEC             reduce using rule 5 (list -> list asgn NEWLINE .)
    BLTIN           reduce using rule 5 (list -> list asgn NEWLINE .)
    $end            reduce using rule 5 (list -> list asgn NEWLINE .)


state 47

    (16) stmt -> FOR LPARENT . cond SEMICOLON cond SEMICOLON cond RPARENT stmt END
    (20) cond -> . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 92
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    cond                           shift and go to state 95
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 48

    (6) list -> list stmt NEWLINE .

    NEWLINE         reduce using rule 6 (list -> list stmt NEWLINE .)
    error           reduce using rule 6 (list -> list stmt NEWLINE .)
    COMMENT         reduce using rule 6 (list -> list stmt NEWLINE .)
    FUNC            reduce using rule 6 (list -> list stmt NEWLINE .)
    PROC            reduce using rule 6 (list -> list stmt NEWLINE .)
    ID              reduce using rule 6 (list -> list stmt NEWLINE .)
    RETURN          reduce using rule 6 (list -> list stmt NEWLINE .)
    PROCEDURE       reduce using rule 6 (list -> list stmt NEWLINE .)
    PRINT           reduce using rule 6 (list -> list stmt NEWLINE .)
    WHILE           reduce using rule 6 (list -> list stmt NEWLINE .)
    FOR             reduce using rule 6 (list -> list stmt NEWLINE .)
    IF              reduce using rule 6 (list -> list stmt NEWLINE .)
    LBRACKET        reduce using rule 6 (list -> list stmt NEWLINE .)
    LPARENT         reduce using rule 6 (list -> list stmt NEWLINE .)
    FLOAT           reduce using rule 6 (list -> list stmt NEWLINE .)
    CONSTANT        reduce using rule 6 (list -> list stmt NEWLINE .)
    MINUS           reduce using rule 6 (list -> list stmt NEWLINE .)
    INC             reduce using rule 6 (list -> list stmt NEWLINE .)
    DEC             reduce using rule 6 (list -> list stmt NEWLINE .)
    BLTIN           reduce using rule 6 (list -> list stmt NEWLINE .)
    $end            reduce using rule 6 (list -> list stmt NEWLINE .)


state 49

    (61) callfunc -> BLTIN LPARENT . expr RPARENT
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 96
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 50

    (71) procname -> FUNCTION .

    LPARENT         reduce using rule 71 (procname -> FUNCTION .)


state 51

    (74) procname -> BLTIN .

    LPARENT         reduce using rule 74 (procname -> BLTIN .)


state 52

    (67) defn -> FUNC procname . LPARENT formals RPARENT

    LPARENT         shift and go to state 97


state 53

    (72) procname -> ID .

    LPARENT         reduce using rule 72 (procname -> ID .)


state 54

    (73) procname -> PROCEDURE .

    LPARENT         reduce using rule 73 (procname -> PROCEDURE .)


state 55

    (4) list -> list defn NEWLINE .

    NEWLINE         reduce using rule 4 (list -> list defn NEWLINE .)
    error           reduce using rule 4 (list -> list defn NEWLINE .)
    COMMENT         reduce using rule 4 (list -> list defn NEWLINE .)
    FUNC            reduce using rule 4 (list -> list defn NEWLINE .)
    PROC            reduce using rule 4 (list -> list defn NEWLINE .)
    ID              reduce using rule 4 (list -> list defn NEWLINE .)
    RETURN          reduce using rule 4 (list -> list defn NEWLINE .)
    PROCEDURE       reduce using rule 4 (list -> list defn NEWLINE .)
    PRINT           reduce using rule 4 (list -> list defn NEWLINE .)
    WHILE           reduce using rule 4 (list -> list defn NEWLINE .)
    FOR             reduce using rule 4 (list -> list defn NEWLINE .)
    IF              reduce using rule 4 (list -> list defn NEWLINE .)
    LBRACKET        reduce using rule 4 (list -> list defn NEWLINE .)
    LPARENT         reduce using rule 4 (list -> list defn NEWLINE .)
    FLOAT           reduce using rule 4 (list -> list defn NEWLINE .)
    CONSTANT        reduce using rule 4 (list -> list defn NEWLINE .)
    MINUS           reduce using rule 4 (list -> list defn NEWLINE .)
    INC             reduce using rule 4 (list -> list defn NEWLINE .)
    DEC             reduce using rule 4 (list -> list defn NEWLINE .)
    BLTIN           reduce using rule 4 (list -> list defn NEWLINE .)
    $end            reduce using rule 4 (list -> list defn NEWLINE .)


state 56

    (62) callfunc -> ID LPARENT . expr RPARENT
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 98
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 57

    (45) asgn -> ID MODEQ . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 99
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 58

    (40) asgn -> ID ASSIGN . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 100
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 59

    (42) asgn -> ID SUBEQ . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 101
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 60

    (43) asgn -> ID MULEQ . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 102
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 61

    (41) asgn -> ID ADDEQ . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 103
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 62

    (36) unaryop -> ID DEC .

    EXP             reduce using rule 36 (unaryop -> ID DEC .)
    PLUS            reduce using rule 36 (unaryop -> ID DEC .)
    MINUS           reduce using rule 36 (unaryop -> ID DEC .)
    TIMES           reduce using rule 36 (unaryop -> ID DEC .)
    DIVIDE          reduce using rule 36 (unaryop -> ID DEC .)
    MOD             reduce using rule 36 (unaryop -> ID DEC .)
    LT              reduce using rule 36 (unaryop -> ID DEC .)
    GT              reduce using rule 36 (unaryop -> ID DEC .)
    LE              reduce using rule 36 (unaryop -> ID DEC .)
    GE              reduce using rule 36 (unaryop -> ID DEC .)
    EQ              reduce using rule 36 (unaryop -> ID DEC .)
    NE              reduce using rule 36 (unaryop -> ID DEC .)
    OR              reduce using rule 36 (unaryop -> ID DEC .)
    AND             reduce using rule 36 (unaryop -> ID DEC .)
    NOT             reduce using rule 36 (unaryop -> ID DEC .)
    NEWLINE         reduce using rule 36 (unaryop -> ID DEC .)
    RBRACKET        reduce using rule 36 (unaryop -> ID DEC .)
    RETURN          reduce using rule 36 (unaryop -> ID DEC .)
    PROCEDURE       reduce using rule 36 (unaryop -> ID DEC .)
    PRINT           reduce using rule 36 (unaryop -> ID DEC .)
    WHILE           reduce using rule 36 (unaryop -> ID DEC .)
    FOR             reduce using rule 36 (unaryop -> ID DEC .)
    IF              reduce using rule 36 (unaryop -> ID DEC .)
    LBRACKET        reduce using rule 36 (unaryop -> ID DEC .)
    LPARENT         reduce using rule 36 (unaryop -> ID DEC .)
    FLOAT           reduce using rule 36 (unaryop -> ID DEC .)
    CONSTANT        reduce using rule 36 (unaryop -> ID DEC .)
    ID              reduce using rule 36 (unaryop -> ID DEC .)
    INC             reduce using rule 36 (unaryop -> ID DEC .)
    DEC             reduce using rule 36 (unaryop -> ID DEC .)
    BLTIN           reduce using rule 36 (unaryop -> ID DEC .)
    END             reduce using rule 36 (unaryop -> ID DEC .)
    COMMA           reduce using rule 36 (unaryop -> ID DEC .)
    RPARENT         reduce using rule 36 (unaryop -> ID DEC .)
    SEMICOLON       reduce using rule 36 (unaryop -> ID DEC .)


state 63

    (44) asgn -> ID DIVEQ . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 104
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 64

    (35) unaryop -> ID INC .

    EXP             reduce using rule 35 (unaryop -> ID INC .)
    PLUS            reduce using rule 35 (unaryop -> ID INC .)
    MINUS           reduce using rule 35 (unaryop -> ID INC .)
    TIMES           reduce using rule 35 (unaryop -> ID INC .)
    DIVIDE          reduce using rule 35 (unaryop -> ID INC .)
    MOD             reduce using rule 35 (unaryop -> ID INC .)
    LT              reduce using rule 35 (unaryop -> ID INC .)
    GT              reduce using rule 35 (unaryop -> ID INC .)
    LE              reduce using rule 35 (unaryop -> ID INC .)
    GE              reduce using rule 35 (unaryop -> ID INC .)
    EQ              reduce using rule 35 (unaryop -> ID INC .)
    NE              reduce using rule 35 (unaryop -> ID INC .)
    OR              reduce using rule 35 (unaryop -> ID INC .)
    AND             reduce using rule 35 (unaryop -> ID INC .)
    NOT             reduce using rule 35 (unaryop -> ID INC .)
    NEWLINE         reduce using rule 35 (unaryop -> ID INC .)
    RBRACKET        reduce using rule 35 (unaryop -> ID INC .)
    RETURN          reduce using rule 35 (unaryop -> ID INC .)
    PROCEDURE       reduce using rule 35 (unaryop -> ID INC .)
    PRINT           reduce using rule 35 (unaryop -> ID INC .)
    WHILE           reduce using rule 35 (unaryop -> ID INC .)
    FOR             reduce using rule 35 (unaryop -> ID INC .)
    IF              reduce using rule 35 (unaryop -> ID INC .)
    LBRACKET        reduce using rule 35 (unaryop -> ID INC .)
    LPARENT         reduce using rule 35 (unaryop -> ID INC .)
    FLOAT           reduce using rule 35 (unaryop -> ID INC .)
    CONSTANT        reduce using rule 35 (unaryop -> ID INC .)
    ID              reduce using rule 35 (unaryop -> ID INC .)
    INC             reduce using rule 35 (unaryop -> ID INC .)
    DEC             reduce using rule 35 (unaryop -> ID INC .)
    BLTIN           reduce using rule 35 (unaryop -> ID INC .)
    END             reduce using rule 35 (unaryop -> ID INC .)
    COMMA           reduce using rule 35 (unaryop -> ID INC .)
    RPARENT         reduce using rule 35 (unaryop -> ID INC .)
    SEMICOLON       reduce using rule 35 (unaryop -> ID INC .)


state 65

    (13) stmt -> PROCEDURE BEGIN . LPARENT arglist RPARENT

    LPARENT         shift and go to state 105


state 66

    (17) stmt -> IF LPARENT . cond RPARENT stmt END
    (18) stmt -> IF LPARENT . cond RPARENT stmt END ELSE stmt END
    (20) cond -> . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 92
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    cond                           shift and go to state 106
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 67

    (34) unaryop -> DEC ID .

    EXP             reduce using rule 34 (unaryop -> DEC ID .)
    PLUS            reduce using rule 34 (unaryop -> DEC ID .)
    MINUS           reduce using rule 34 (unaryop -> DEC ID .)
    TIMES           reduce using rule 34 (unaryop -> DEC ID .)
    DIVIDE          reduce using rule 34 (unaryop -> DEC ID .)
    MOD             reduce using rule 34 (unaryop -> DEC ID .)
    LT              reduce using rule 34 (unaryop -> DEC ID .)
    GT              reduce using rule 34 (unaryop -> DEC ID .)
    LE              reduce using rule 34 (unaryop -> DEC ID .)
    GE              reduce using rule 34 (unaryop -> DEC ID .)
    EQ              reduce using rule 34 (unaryop -> DEC ID .)
    NE              reduce using rule 34 (unaryop -> DEC ID .)
    OR              reduce using rule 34 (unaryop -> DEC ID .)
    AND             reduce using rule 34 (unaryop -> DEC ID .)
    NOT             reduce using rule 34 (unaryop -> DEC ID .)
    NEWLINE         reduce using rule 34 (unaryop -> DEC ID .)
    RBRACKET        reduce using rule 34 (unaryop -> DEC ID .)
    RETURN          reduce using rule 34 (unaryop -> DEC ID .)
    PROCEDURE       reduce using rule 34 (unaryop -> DEC ID .)
    PRINT           reduce using rule 34 (unaryop -> DEC ID .)
    WHILE           reduce using rule 34 (unaryop -> DEC ID .)
    FOR             reduce using rule 34 (unaryop -> DEC ID .)
    IF              reduce using rule 34 (unaryop -> DEC ID .)
    LBRACKET        reduce using rule 34 (unaryop -> DEC ID .)
    LPARENT         reduce using rule 34 (unaryop -> DEC ID .)
    FLOAT           reduce using rule 34 (unaryop -> DEC ID .)
    CONSTANT        reduce using rule 34 (unaryop -> DEC ID .)
    ID              reduce using rule 34 (unaryop -> DEC ID .)
    INC             reduce using rule 34 (unaryop -> DEC ID .)
    DEC             reduce using rule 34 (unaryop -> DEC ID .)
    BLTIN           reduce using rule 34 (unaryop -> DEC ID .)
    END             reduce using rule 34 (unaryop -> DEC ID .)
    COMMA           reduce using rule 34 (unaryop -> DEC ID .)
    RPARENT         reduce using rule 34 (unaryop -> DEC ID .)
    SEMICOLON       reduce using rule 34 (unaryop -> DEC ID .)


state 68

    (59) logicop -> expr AND . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 107
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 69

    (58) logicop -> expr OR . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 108
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 70

    (53) logicop -> expr GT . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 109
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 71

    (50) mathop -> expr DIVIDE . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 110
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 72

    (7) list -> list expr NEWLINE .

    NEWLINE         reduce using rule 7 (list -> list expr NEWLINE .)
    error           reduce using rule 7 (list -> list expr NEWLINE .)
    COMMENT         reduce using rule 7 (list -> list expr NEWLINE .)
    FUNC            reduce using rule 7 (list -> list expr NEWLINE .)
    PROC            reduce using rule 7 (list -> list expr NEWLINE .)
    ID              reduce using rule 7 (list -> list expr NEWLINE .)
    RETURN          reduce using rule 7 (list -> list expr NEWLINE .)
    PROCEDURE       reduce using rule 7 (list -> list expr NEWLINE .)
    PRINT           reduce using rule 7 (list -> list expr NEWLINE .)
    WHILE           reduce using rule 7 (list -> list expr NEWLINE .)
    FOR             reduce using rule 7 (list -> list expr NEWLINE .)
    IF              reduce using rule 7 (list -> list expr NEWLINE .)
    LBRACKET        reduce using rule 7 (list -> list expr NEWLINE .)
    LPARENT         reduce using rule 7 (list -> list expr NEWLINE .)
    FLOAT           reduce using rule 7 (list -> list expr NEWLINE .)
    CONSTANT        reduce using rule 7 (list -> list expr NEWLINE .)
    MINUS           reduce using rule 7 (list -> list expr NEWLINE .)
    INC             reduce using rule 7 (list -> list expr NEWLINE .)
    DEC             reduce using rule 7 (list -> list expr NEWLINE .)
    BLTIN           reduce using rule 7 (list -> list expr NEWLINE .)
    $end            reduce using rule 7 (list -> list expr NEWLINE .)


state 73

    (55) logicop -> expr GE . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 111
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 74

    (49) mathop -> expr TIMES . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 112
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 75

    (52) logicop -> expr LT . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 113
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 76

    (54) logicop -> expr LE . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 114
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 77

    (47) mathop -> expr PLUS . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 115
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 78

    (46) mathop -> expr EXP . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 116
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 79

    (60) logicop -> expr NOT . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 117
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 80

    (56) logicop -> expr EQ . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 118
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 81

    (48) mathop -> expr MINUS . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 119
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 82

    (57) logicop -> expr NE . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 120
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 83

    (51) mathop -> expr MOD . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 121
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 84

    (8) list -> list error NEWLINE .

    NEWLINE         reduce using rule 8 (list -> list error NEWLINE .)
    error           reduce using rule 8 (list -> list error NEWLINE .)
    COMMENT         reduce using rule 8 (list -> list error NEWLINE .)
    FUNC            reduce using rule 8 (list -> list error NEWLINE .)
    PROC            reduce using rule 8 (list -> list error NEWLINE .)
    ID              reduce using rule 8 (list -> list error NEWLINE .)
    RETURN          reduce using rule 8 (list -> list error NEWLINE .)
    PROCEDURE       reduce using rule 8 (list -> list error NEWLINE .)
    PRINT           reduce using rule 8 (list -> list error NEWLINE .)
    WHILE           reduce using rule 8 (list -> list error NEWLINE .)
    FOR             reduce using rule 8 (list -> list error NEWLINE .)
    IF              reduce using rule 8 (list -> list error NEWLINE .)
    LBRACKET        reduce using rule 8 (list -> list error NEWLINE .)
    LPARENT         reduce using rule 8 (list -> list error NEWLINE .)
    FLOAT           reduce using rule 8 (list -> list error NEWLINE .)
    CONSTANT        reduce using rule 8 (list -> list error NEWLINE .)
    MINUS           reduce using rule 8 (list -> list error NEWLINE .)
    INC             reduce using rule 8 (list -> list error NEWLINE .)
    DEC             reduce using rule 8 (list -> list error NEWLINE .)
    BLTIN           reduce using rule 8 (list -> list error NEWLINE .)
    $end            reduce using rule 8 (list -> list error NEWLINE .)


state 85

    (68) defn -> PROC procname . LPARENT formals RPARENT

    LPARENT         shift and go to state 122


state 86

    (33) unaryop -> INC ID .

    EXP             reduce using rule 33 (unaryop -> INC ID .)
    PLUS            reduce using rule 33 (unaryop -> INC ID .)
    MINUS           reduce using rule 33 (unaryop -> INC ID .)
    TIMES           reduce using rule 33 (unaryop -> INC ID .)
    DIVIDE          reduce using rule 33 (unaryop -> INC ID .)
    MOD             reduce using rule 33 (unaryop -> INC ID .)
    LT              reduce using rule 33 (unaryop -> INC ID .)
    GT              reduce using rule 33 (unaryop -> INC ID .)
    LE              reduce using rule 33 (unaryop -> INC ID .)
    GE              reduce using rule 33 (unaryop -> INC ID .)
    EQ              reduce using rule 33 (unaryop -> INC ID .)
    NE              reduce using rule 33 (unaryop -> INC ID .)
    OR              reduce using rule 33 (unaryop -> INC ID .)
    AND             reduce using rule 33 (unaryop -> INC ID .)
    NOT             reduce using rule 33 (unaryop -> INC ID .)
    NEWLINE         reduce using rule 33 (unaryop -> INC ID .)
    RBRACKET        reduce using rule 33 (unaryop -> INC ID .)
    RETURN          reduce using rule 33 (unaryop -> INC ID .)
    PROCEDURE       reduce using rule 33 (unaryop -> INC ID .)
    PRINT           reduce using rule 33 (unaryop -> INC ID .)
    WHILE           reduce using rule 33 (unaryop -> INC ID .)
    FOR             reduce using rule 33 (unaryop -> INC ID .)
    IF              reduce using rule 33 (unaryop -> INC ID .)
    LBRACKET        reduce using rule 33 (unaryop -> INC ID .)
    LPARENT         reduce using rule 33 (unaryop -> INC ID .)
    FLOAT           reduce using rule 33 (unaryop -> INC ID .)
    CONSTANT        reduce using rule 33 (unaryop -> INC ID .)
    ID              reduce using rule 33 (unaryop -> INC ID .)
    INC             reduce using rule 33 (unaryop -> INC ID .)
    DEC             reduce using rule 33 (unaryop -> INC ID .)
    BLTIN           reduce using rule 33 (unaryop -> INC ID .)
    END             reduce using rule 33 (unaryop -> INC ID .)
    COMMA           reduce using rule 33 (unaryop -> INC ID .)
    RPARENT         reduce using rule 33 (unaryop -> INC ID .)
    SEMICOLON       reduce using rule 33 (unaryop -> INC ID .)


state 87

    (22) stmtlist -> stmtlist NEWLINE .

    RBRACKET        reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    NEWLINE         reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    RETURN          reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    PROCEDURE       reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    PRINT           reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    WHILE           reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    FOR             reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    IF              reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    LBRACKET        reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    LPARENT         reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    FLOAT           reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    CONSTANT        reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    ID              reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    MINUS           reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    INC             reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    DEC             reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)
    BLTIN           reduce using rule 22 (stmtlist -> stmtlist NEWLINE .)


state 88

    (23) stmtlist -> stmtlist stmt .

    RBRACKET        reduce using rule 23 (stmtlist -> stmtlist stmt .)
    NEWLINE         reduce using rule 23 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 23 (stmtlist -> stmtlist stmt .)
    PROCEDURE       reduce using rule 23 (stmtlist -> stmtlist stmt .)
    PRINT           reduce using rule 23 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 23 (stmtlist -> stmtlist stmt .)
    FOR             reduce using rule 23 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 23 (stmtlist -> stmtlist stmt .)
    LBRACKET        reduce using rule 23 (stmtlist -> stmtlist stmt .)
    LPARENT         reduce using rule 23 (stmtlist -> stmtlist stmt .)
    FLOAT           reduce using rule 23 (stmtlist -> stmtlist stmt .)
    CONSTANT        reduce using rule 23 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 23 (stmtlist -> stmtlist stmt .)
    MINUS           reduce using rule 23 (stmtlist -> stmtlist stmt .)
    INC             reduce using rule 23 (stmtlist -> stmtlist stmt .)
    DEC             reduce using rule 23 (stmtlist -> stmtlist stmt .)
    BLTIN           reduce using rule 23 (stmtlist -> stmtlist stmt .)


state 89

    (10) stmt -> expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for MINUS resolved as shift
    END             reduce using rule 10 (stmt -> expr .)
    RBRACKET        reduce using rule 10 (stmt -> expr .)
    NEWLINE         reduce using rule 10 (stmt -> expr .)
    RETURN          reduce using rule 10 (stmt -> expr .)
    PROCEDURE       reduce using rule 10 (stmt -> expr .)
    PRINT           reduce using rule 10 (stmt -> expr .)
    WHILE           reduce using rule 10 (stmt -> expr .)
    FOR             reduce using rule 10 (stmt -> expr .)
    IF              reduce using rule 10 (stmt -> expr .)
    LBRACKET        reduce using rule 10 (stmt -> expr .)
    LPARENT         reduce using rule 10 (stmt -> expr .)
    FLOAT           reduce using rule 10 (stmt -> expr .)
    CONSTANT        reduce using rule 10 (stmt -> expr .)
    ID              reduce using rule 10 (stmt -> expr .)
    INC             reduce using rule 10 (stmt -> expr .)
    DEC             reduce using rule 10 (stmt -> expr .)
    BLTIN           reduce using rule 10 (stmt -> expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! MINUS           [ reduce using rule 10 (stmt -> expr .) ]


state 90

    (19) stmt -> LBRACKET stmtlist RBRACKET .

    END             reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    RBRACKET        reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    NEWLINE         reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    RETURN          reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    PROCEDURE       reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    PRINT           reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    WHILE           reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    FOR             reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    IF              reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    LBRACKET        reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    LPARENT         reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    FLOAT           reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    CONSTANT        reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    ID              reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    MINUS           reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    INC             reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    DEC             reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)
    BLTIN           reduce using rule 19 (stmt -> LBRACKET stmtlist RBRACKET .)


state 91

    (15) stmt -> WHILE LPARENT cond . RPARENT stmt END

    RPARENT         shift and go to state 123


state 92

    (20) cond -> expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

    SEMICOLON       reduce using rule 20 (cond -> expr .)
    RPARENT         reduce using rule 20 (cond -> expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79


state 93

    (65) prlist -> prlist COMMA . expr
    (66) prlist -> prlist COMMA . STRING
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    STRING          shift and go to state 124
    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 125
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 94

    (27) expr -> LPARENT expr RPARENT .

    EXP             reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    PLUS            reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    MINUS           reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    TIMES           reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    DIVIDE          reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    MOD             reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    LT              reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    GT              reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    LE              reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    GE              reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    EQ              reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    NE              reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    OR              reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    AND             reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    NOT             reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    NEWLINE         reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    RBRACKET        reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    RETURN          reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    PROCEDURE       reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    PRINT           reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    WHILE           reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    FOR             reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    IF              reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    LBRACKET        reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    LPARENT         reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    FLOAT           reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    CONSTANT        reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    ID              reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    INC             reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    DEC             reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    BLTIN           reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    END             reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    COMMA           reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    RPARENT         reduce using rule 27 (expr -> LPARENT expr RPARENT .)
    SEMICOLON       reduce using rule 27 (expr -> LPARENT expr RPARENT .)


state 95

    (16) stmt -> FOR LPARENT cond . SEMICOLON cond SEMICOLON cond RPARENT stmt END

    SEMICOLON       shift and go to state 126


state 96

    (61) callfunc -> BLTIN LPARENT expr . RPARENT
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

    RPARENT         shift and go to state 127
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79


state 97

    (67) defn -> FUNC procname LPARENT . formals RPARENT
    (69) formals -> . ID
    (70) formals -> . ID COMMA formals

    ID              shift and go to state 128

    formals                        shift and go to state 129

state 98

    (62) callfunc -> ID LPARENT expr . RPARENT
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

    RPARENT         shift and go to state 130
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79


state 99

    (45) asgn -> ID MODEQ expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NEWLINE         reduce using rule 45 (asgn -> ID MODEQ expr .)
    RBRACKET        reduce using rule 45 (asgn -> ID MODEQ expr .)
    RETURN          reduce using rule 45 (asgn -> ID MODEQ expr .)
    PROCEDURE       reduce using rule 45 (asgn -> ID MODEQ expr .)
    PRINT           reduce using rule 45 (asgn -> ID MODEQ expr .)
    WHILE           reduce using rule 45 (asgn -> ID MODEQ expr .)
    FOR             reduce using rule 45 (asgn -> ID MODEQ expr .)
    IF              reduce using rule 45 (asgn -> ID MODEQ expr .)
    LBRACKET        reduce using rule 45 (asgn -> ID MODEQ expr .)
    LPARENT         reduce using rule 45 (asgn -> ID MODEQ expr .)
    FLOAT           reduce using rule 45 (asgn -> ID MODEQ expr .)
    CONSTANT        reduce using rule 45 (asgn -> ID MODEQ expr .)
    ID              reduce using rule 45 (asgn -> ID MODEQ expr .)
    INC             reduce using rule 45 (asgn -> ID MODEQ expr .)
    DEC             reduce using rule 45 (asgn -> ID MODEQ expr .)
    BLTIN           reduce using rule 45 (asgn -> ID MODEQ expr .)
    END             reduce using rule 45 (asgn -> ID MODEQ expr .)
    COMMA           reduce using rule 45 (asgn -> ID MODEQ expr .)
    RPARENT         reduce using rule 45 (asgn -> ID MODEQ expr .)
    SEMICOLON       reduce using rule 45 (asgn -> ID MODEQ expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! PLUS            [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! MINUS           [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! TIMES           [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! DIVIDE          [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! MOD             [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! LT              [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! GT              [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! LE              [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! GE              [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! EQ              [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! NE              [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! OR              [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! AND             [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]
  ! NOT             [ reduce using rule 45 (asgn -> ID MODEQ expr .) ]


state 100

    (40) asgn -> ID ASSIGN expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NEWLINE         reduce using rule 40 (asgn -> ID ASSIGN expr .)
    RBRACKET        reduce using rule 40 (asgn -> ID ASSIGN expr .)
    RETURN          reduce using rule 40 (asgn -> ID ASSIGN expr .)
    PROCEDURE       reduce using rule 40 (asgn -> ID ASSIGN expr .)
    PRINT           reduce using rule 40 (asgn -> ID ASSIGN expr .)
    WHILE           reduce using rule 40 (asgn -> ID ASSIGN expr .)
    FOR             reduce using rule 40 (asgn -> ID ASSIGN expr .)
    IF              reduce using rule 40 (asgn -> ID ASSIGN expr .)
    LBRACKET        reduce using rule 40 (asgn -> ID ASSIGN expr .)
    LPARENT         reduce using rule 40 (asgn -> ID ASSIGN expr .)
    FLOAT           reduce using rule 40 (asgn -> ID ASSIGN expr .)
    CONSTANT        reduce using rule 40 (asgn -> ID ASSIGN expr .)
    ID              reduce using rule 40 (asgn -> ID ASSIGN expr .)
    INC             reduce using rule 40 (asgn -> ID ASSIGN expr .)
    DEC             reduce using rule 40 (asgn -> ID ASSIGN expr .)
    BLTIN           reduce using rule 40 (asgn -> ID ASSIGN expr .)
    END             reduce using rule 40 (asgn -> ID ASSIGN expr .)
    COMMA           reduce using rule 40 (asgn -> ID ASSIGN expr .)
    RPARENT         reduce using rule 40 (asgn -> ID ASSIGN expr .)
    SEMICOLON       reduce using rule 40 (asgn -> ID ASSIGN expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! PLUS            [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! MINUS           [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! TIMES           [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! DIVIDE          [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! MOD             [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! LT              [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! GT              [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! LE              [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! GE              [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! EQ              [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! NE              [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! OR              [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! AND             [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]
  ! NOT             [ reduce using rule 40 (asgn -> ID ASSIGN expr .) ]


state 101

    (42) asgn -> ID SUBEQ expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NEWLINE         reduce using rule 42 (asgn -> ID SUBEQ expr .)
    RBRACKET        reduce using rule 42 (asgn -> ID SUBEQ expr .)
    RETURN          reduce using rule 42 (asgn -> ID SUBEQ expr .)
    PROCEDURE       reduce using rule 42 (asgn -> ID SUBEQ expr .)
    PRINT           reduce using rule 42 (asgn -> ID SUBEQ expr .)
    WHILE           reduce using rule 42 (asgn -> ID SUBEQ expr .)
    FOR             reduce using rule 42 (asgn -> ID SUBEQ expr .)
    IF              reduce using rule 42 (asgn -> ID SUBEQ expr .)
    LBRACKET        reduce using rule 42 (asgn -> ID SUBEQ expr .)
    LPARENT         reduce using rule 42 (asgn -> ID SUBEQ expr .)
    FLOAT           reduce using rule 42 (asgn -> ID SUBEQ expr .)
    CONSTANT        reduce using rule 42 (asgn -> ID SUBEQ expr .)
    ID              reduce using rule 42 (asgn -> ID SUBEQ expr .)
    INC             reduce using rule 42 (asgn -> ID SUBEQ expr .)
    DEC             reduce using rule 42 (asgn -> ID SUBEQ expr .)
    BLTIN           reduce using rule 42 (asgn -> ID SUBEQ expr .)
    END             reduce using rule 42 (asgn -> ID SUBEQ expr .)
    COMMA           reduce using rule 42 (asgn -> ID SUBEQ expr .)
    RPARENT         reduce using rule 42 (asgn -> ID SUBEQ expr .)
    SEMICOLON       reduce using rule 42 (asgn -> ID SUBEQ expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! PLUS            [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! MINUS           [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! TIMES           [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! DIVIDE          [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! MOD             [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! LT              [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! GT              [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! LE              [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! GE              [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! EQ              [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! NE              [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! OR              [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! AND             [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]
  ! NOT             [ reduce using rule 42 (asgn -> ID SUBEQ expr .) ]


state 102

    (43) asgn -> ID MULEQ expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NEWLINE         reduce using rule 43 (asgn -> ID MULEQ expr .)
    RBRACKET        reduce using rule 43 (asgn -> ID MULEQ expr .)
    RETURN          reduce using rule 43 (asgn -> ID MULEQ expr .)
    PROCEDURE       reduce using rule 43 (asgn -> ID MULEQ expr .)
    PRINT           reduce using rule 43 (asgn -> ID MULEQ expr .)
    WHILE           reduce using rule 43 (asgn -> ID MULEQ expr .)
    FOR             reduce using rule 43 (asgn -> ID MULEQ expr .)
    IF              reduce using rule 43 (asgn -> ID MULEQ expr .)
    LBRACKET        reduce using rule 43 (asgn -> ID MULEQ expr .)
    LPARENT         reduce using rule 43 (asgn -> ID MULEQ expr .)
    FLOAT           reduce using rule 43 (asgn -> ID MULEQ expr .)
    CONSTANT        reduce using rule 43 (asgn -> ID MULEQ expr .)
    ID              reduce using rule 43 (asgn -> ID MULEQ expr .)
    INC             reduce using rule 43 (asgn -> ID MULEQ expr .)
    DEC             reduce using rule 43 (asgn -> ID MULEQ expr .)
    BLTIN           reduce using rule 43 (asgn -> ID MULEQ expr .)
    END             reduce using rule 43 (asgn -> ID MULEQ expr .)
    COMMA           reduce using rule 43 (asgn -> ID MULEQ expr .)
    RPARENT         reduce using rule 43 (asgn -> ID MULEQ expr .)
    SEMICOLON       reduce using rule 43 (asgn -> ID MULEQ expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! PLUS            [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! MINUS           [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! TIMES           [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! DIVIDE          [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! MOD             [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! LT              [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! GT              [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! LE              [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! GE              [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! EQ              [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! NE              [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! OR              [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! AND             [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]
  ! NOT             [ reduce using rule 43 (asgn -> ID MULEQ expr .) ]


state 103

    (41) asgn -> ID ADDEQ expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NEWLINE         reduce using rule 41 (asgn -> ID ADDEQ expr .)
    RBRACKET        reduce using rule 41 (asgn -> ID ADDEQ expr .)
    RETURN          reduce using rule 41 (asgn -> ID ADDEQ expr .)
    PROCEDURE       reduce using rule 41 (asgn -> ID ADDEQ expr .)
    PRINT           reduce using rule 41 (asgn -> ID ADDEQ expr .)
    WHILE           reduce using rule 41 (asgn -> ID ADDEQ expr .)
    FOR             reduce using rule 41 (asgn -> ID ADDEQ expr .)
    IF              reduce using rule 41 (asgn -> ID ADDEQ expr .)
    LBRACKET        reduce using rule 41 (asgn -> ID ADDEQ expr .)
    LPARENT         reduce using rule 41 (asgn -> ID ADDEQ expr .)
    FLOAT           reduce using rule 41 (asgn -> ID ADDEQ expr .)
    CONSTANT        reduce using rule 41 (asgn -> ID ADDEQ expr .)
    ID              reduce using rule 41 (asgn -> ID ADDEQ expr .)
    INC             reduce using rule 41 (asgn -> ID ADDEQ expr .)
    DEC             reduce using rule 41 (asgn -> ID ADDEQ expr .)
    BLTIN           reduce using rule 41 (asgn -> ID ADDEQ expr .)
    END             reduce using rule 41 (asgn -> ID ADDEQ expr .)
    COMMA           reduce using rule 41 (asgn -> ID ADDEQ expr .)
    RPARENT         reduce using rule 41 (asgn -> ID ADDEQ expr .)
    SEMICOLON       reduce using rule 41 (asgn -> ID ADDEQ expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! PLUS            [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! MINUS           [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! TIMES           [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! DIVIDE          [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! MOD             [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! LT              [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! GT              [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! LE              [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! GE              [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! EQ              [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! NE              [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! OR              [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! AND             [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]
  ! NOT             [ reduce using rule 41 (asgn -> ID ADDEQ expr .) ]


state 104

    (44) asgn -> ID DIVEQ expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NEWLINE         reduce using rule 44 (asgn -> ID DIVEQ expr .)
    RBRACKET        reduce using rule 44 (asgn -> ID DIVEQ expr .)
    RETURN          reduce using rule 44 (asgn -> ID DIVEQ expr .)
    PROCEDURE       reduce using rule 44 (asgn -> ID DIVEQ expr .)
    PRINT           reduce using rule 44 (asgn -> ID DIVEQ expr .)
    WHILE           reduce using rule 44 (asgn -> ID DIVEQ expr .)
    FOR             reduce using rule 44 (asgn -> ID DIVEQ expr .)
    IF              reduce using rule 44 (asgn -> ID DIVEQ expr .)
    LBRACKET        reduce using rule 44 (asgn -> ID DIVEQ expr .)
    LPARENT         reduce using rule 44 (asgn -> ID DIVEQ expr .)
    FLOAT           reduce using rule 44 (asgn -> ID DIVEQ expr .)
    CONSTANT        reduce using rule 44 (asgn -> ID DIVEQ expr .)
    ID              reduce using rule 44 (asgn -> ID DIVEQ expr .)
    INC             reduce using rule 44 (asgn -> ID DIVEQ expr .)
    DEC             reduce using rule 44 (asgn -> ID DIVEQ expr .)
    BLTIN           reduce using rule 44 (asgn -> ID DIVEQ expr .)
    END             reduce using rule 44 (asgn -> ID DIVEQ expr .)
    COMMA           reduce using rule 44 (asgn -> ID DIVEQ expr .)
    RPARENT         reduce using rule 44 (asgn -> ID DIVEQ expr .)
    SEMICOLON       reduce using rule 44 (asgn -> ID DIVEQ expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! PLUS            [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! MINUS           [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! TIMES           [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! DIVIDE          [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! MOD             [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! LT              [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! GT              [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! LE              [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! GE              [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! EQ              [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! NE              [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! OR              [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! AND             [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]
  ! NOT             [ reduce using rule 44 (asgn -> ID DIVEQ expr .) ]


state 105

    (13) stmt -> PROCEDURE BEGIN LPARENT . arglist RPARENT
    (75) arglist -> . empty
    (76) arglist -> . expr
    (77) arglist -> . arglist COMMA expr
    (78) empty -> .
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    RPARENT         reduce using rule 78 (empty -> .)
    COMMA           reduce using rule 78 (empty -> .)
    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 133
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    arglist                        shift and go to state 131
    data                           shift and go to state 21
    empty                          shift and go to state 132

state 106

    (17) stmt -> IF LPARENT cond . RPARENT stmt END
    (18) stmt -> IF LPARENT cond . RPARENT stmt END ELSE stmt END

    RPARENT         shift and go to state 134


state 107

    (59) logicop -> expr AND expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    RPARENT         reduce using rule 59 (logicop -> expr AND expr .)
    COMMA           reduce using rule 59 (logicop -> expr AND expr .)
    NEWLINE         reduce using rule 59 (logicop -> expr AND expr .)
    RBRACKET        reduce using rule 59 (logicop -> expr AND expr .)
    RETURN          reduce using rule 59 (logicop -> expr AND expr .)
    PROCEDURE       reduce using rule 59 (logicop -> expr AND expr .)
    PRINT           reduce using rule 59 (logicop -> expr AND expr .)
    WHILE           reduce using rule 59 (logicop -> expr AND expr .)
    FOR             reduce using rule 59 (logicop -> expr AND expr .)
    IF              reduce using rule 59 (logicop -> expr AND expr .)
    LBRACKET        reduce using rule 59 (logicop -> expr AND expr .)
    LPARENT         reduce using rule 59 (logicop -> expr AND expr .)
    FLOAT           reduce using rule 59 (logicop -> expr AND expr .)
    CONSTANT        reduce using rule 59 (logicop -> expr AND expr .)
    ID              reduce using rule 59 (logicop -> expr AND expr .)
    INC             reduce using rule 59 (logicop -> expr AND expr .)
    DEC             reduce using rule 59 (logicop -> expr AND expr .)
    BLTIN           reduce using rule 59 (logicop -> expr AND expr .)
    END             reduce using rule 59 (logicop -> expr AND expr .)
    SEMICOLON       reduce using rule 59 (logicop -> expr AND expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! PLUS            [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! TIMES           [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! MOD             [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! LT              [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! GT              [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! LE              [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! GE              [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! EQ              [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! NE              [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! OR              [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! AND             [ reduce using rule 59 (logicop -> expr AND expr .) ]
  ! NOT             [ reduce using rule 59 (logicop -> expr AND expr .) ]


state 108

    (58) logicop -> expr OR expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    RPARENT         reduce using rule 58 (logicop -> expr OR expr .)
    COMMA           reduce using rule 58 (logicop -> expr OR expr .)
    NEWLINE         reduce using rule 58 (logicop -> expr OR expr .)
    RBRACKET        reduce using rule 58 (logicop -> expr OR expr .)
    RETURN          reduce using rule 58 (logicop -> expr OR expr .)
    PROCEDURE       reduce using rule 58 (logicop -> expr OR expr .)
    PRINT           reduce using rule 58 (logicop -> expr OR expr .)
    WHILE           reduce using rule 58 (logicop -> expr OR expr .)
    FOR             reduce using rule 58 (logicop -> expr OR expr .)
    IF              reduce using rule 58 (logicop -> expr OR expr .)
    LBRACKET        reduce using rule 58 (logicop -> expr OR expr .)
    LPARENT         reduce using rule 58 (logicop -> expr OR expr .)
    FLOAT           reduce using rule 58 (logicop -> expr OR expr .)
    CONSTANT        reduce using rule 58 (logicop -> expr OR expr .)
    ID              reduce using rule 58 (logicop -> expr OR expr .)
    INC             reduce using rule 58 (logicop -> expr OR expr .)
    DEC             reduce using rule 58 (logicop -> expr OR expr .)
    BLTIN           reduce using rule 58 (logicop -> expr OR expr .)
    END             reduce using rule 58 (logicop -> expr OR expr .)
    SEMICOLON       reduce using rule 58 (logicop -> expr OR expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! PLUS            [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! TIMES           [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! MOD             [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! LT              [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! GT              [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! LE              [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! GE              [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! EQ              [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! NE              [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! OR              [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! AND             [ reduce using rule 58 (logicop -> expr OR expr .) ]
  ! NOT             [ reduce using rule 58 (logicop -> expr OR expr .) ]


state 109

    (53) logicop -> expr GT expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    RPARENT         reduce using rule 53 (logicop -> expr GT expr .)
    COMMA           reduce using rule 53 (logicop -> expr GT expr .)
    NEWLINE         reduce using rule 53 (logicop -> expr GT expr .)
    RBRACKET        reduce using rule 53 (logicop -> expr GT expr .)
    RETURN          reduce using rule 53 (logicop -> expr GT expr .)
    PROCEDURE       reduce using rule 53 (logicop -> expr GT expr .)
    PRINT           reduce using rule 53 (logicop -> expr GT expr .)
    WHILE           reduce using rule 53 (logicop -> expr GT expr .)
    FOR             reduce using rule 53 (logicop -> expr GT expr .)
    IF              reduce using rule 53 (logicop -> expr GT expr .)
    LBRACKET        reduce using rule 53 (logicop -> expr GT expr .)
    LPARENT         reduce using rule 53 (logicop -> expr GT expr .)
    FLOAT           reduce using rule 53 (logicop -> expr GT expr .)
    CONSTANT        reduce using rule 53 (logicop -> expr GT expr .)
    ID              reduce using rule 53 (logicop -> expr GT expr .)
    INC             reduce using rule 53 (logicop -> expr GT expr .)
    DEC             reduce using rule 53 (logicop -> expr GT expr .)
    BLTIN           reduce using rule 53 (logicop -> expr GT expr .)
    END             reduce using rule 53 (logicop -> expr GT expr .)
    SEMICOLON       reduce using rule 53 (logicop -> expr GT expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! PLUS            [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! TIMES           [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! MOD             [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! LT              [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! GT              [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! LE              [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! GE              [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! EQ              [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! NE              [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! OR              [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! AND             [ reduce using rule 53 (logicop -> expr GT expr .) ]
  ! NOT             [ reduce using rule 53 (logicop -> expr GT expr .) ]


state 110

    (50) mathop -> expr DIVIDE expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NEWLINE         reduce using rule 50 (mathop -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 50 (mathop -> expr DIVIDE expr .)
    RETURN          reduce using rule 50 (mathop -> expr DIVIDE expr .)
    PROCEDURE       reduce using rule 50 (mathop -> expr DIVIDE expr .)
    PRINT           reduce using rule 50 (mathop -> expr DIVIDE expr .)
    WHILE           reduce using rule 50 (mathop -> expr DIVIDE expr .)
    FOR             reduce using rule 50 (mathop -> expr DIVIDE expr .)
    IF              reduce using rule 50 (mathop -> expr DIVIDE expr .)
    LBRACKET        reduce using rule 50 (mathop -> expr DIVIDE expr .)
    LPARENT         reduce using rule 50 (mathop -> expr DIVIDE expr .)
    FLOAT           reduce using rule 50 (mathop -> expr DIVIDE expr .)
    CONSTANT        reduce using rule 50 (mathop -> expr DIVIDE expr .)
    ID              reduce using rule 50 (mathop -> expr DIVIDE expr .)
    INC             reduce using rule 50 (mathop -> expr DIVIDE expr .)
    DEC             reduce using rule 50 (mathop -> expr DIVIDE expr .)
    BLTIN           reduce using rule 50 (mathop -> expr DIVIDE expr .)
    END             reduce using rule 50 (mathop -> expr DIVIDE expr .)
    COMMA           reduce using rule 50 (mathop -> expr DIVIDE expr .)
    RPARENT         reduce using rule 50 (mathop -> expr DIVIDE expr .)
    SEMICOLON       reduce using rule 50 (mathop -> expr DIVIDE expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! PLUS            [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! MINUS           [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! TIMES           [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! DIVIDE          [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! MOD             [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! LT              [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! GT              [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! LE              [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! GE              [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! EQ              [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! NE              [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! OR              [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! AND             [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]
  ! NOT             [ reduce using rule 50 (mathop -> expr DIVIDE expr .) ]


state 111

    (55) logicop -> expr GE expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    RPARENT         reduce using rule 55 (logicop -> expr GE expr .)
    COMMA           reduce using rule 55 (logicop -> expr GE expr .)
    NEWLINE         reduce using rule 55 (logicop -> expr GE expr .)
    RBRACKET        reduce using rule 55 (logicop -> expr GE expr .)
    RETURN          reduce using rule 55 (logicop -> expr GE expr .)
    PROCEDURE       reduce using rule 55 (logicop -> expr GE expr .)
    PRINT           reduce using rule 55 (logicop -> expr GE expr .)
    WHILE           reduce using rule 55 (logicop -> expr GE expr .)
    FOR             reduce using rule 55 (logicop -> expr GE expr .)
    IF              reduce using rule 55 (logicop -> expr GE expr .)
    LBRACKET        reduce using rule 55 (logicop -> expr GE expr .)
    LPARENT         reduce using rule 55 (logicop -> expr GE expr .)
    FLOAT           reduce using rule 55 (logicop -> expr GE expr .)
    CONSTANT        reduce using rule 55 (logicop -> expr GE expr .)
    ID              reduce using rule 55 (logicop -> expr GE expr .)
    INC             reduce using rule 55 (logicop -> expr GE expr .)
    DEC             reduce using rule 55 (logicop -> expr GE expr .)
    BLTIN           reduce using rule 55 (logicop -> expr GE expr .)
    END             reduce using rule 55 (logicop -> expr GE expr .)
    SEMICOLON       reduce using rule 55 (logicop -> expr GE expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! PLUS            [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! MINUS           [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! TIMES           [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! DIVIDE          [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! MOD             [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! LT              [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! GT              [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! LE              [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! GE              [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! EQ              [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! NE              [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! OR              [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! AND             [ reduce using rule 55 (logicop -> expr GE expr .) ]
  ! NOT             [ reduce using rule 55 (logicop -> expr GE expr .) ]


state 112

    (49) mathop -> expr TIMES expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NEWLINE         reduce using rule 49 (mathop -> expr TIMES expr .)
    RBRACKET        reduce using rule 49 (mathop -> expr TIMES expr .)
    RETURN          reduce using rule 49 (mathop -> expr TIMES expr .)
    PROCEDURE       reduce using rule 49 (mathop -> expr TIMES expr .)
    PRINT           reduce using rule 49 (mathop -> expr TIMES expr .)
    WHILE           reduce using rule 49 (mathop -> expr TIMES expr .)
    FOR             reduce using rule 49 (mathop -> expr TIMES expr .)
    IF              reduce using rule 49 (mathop -> expr TIMES expr .)
    LBRACKET        reduce using rule 49 (mathop -> expr TIMES expr .)
    LPARENT         reduce using rule 49 (mathop -> expr TIMES expr .)
    FLOAT           reduce using rule 49 (mathop -> expr TIMES expr .)
    CONSTANT        reduce using rule 49 (mathop -> expr TIMES expr .)
    ID              reduce using rule 49 (mathop -> expr TIMES expr .)
    INC             reduce using rule 49 (mathop -> expr TIMES expr .)
    DEC             reduce using rule 49 (mathop -> expr TIMES expr .)
    BLTIN           reduce using rule 49 (mathop -> expr TIMES expr .)
    END             reduce using rule 49 (mathop -> expr TIMES expr .)
    COMMA           reduce using rule 49 (mathop -> expr TIMES expr .)
    RPARENT         reduce using rule 49 (mathop -> expr TIMES expr .)
    SEMICOLON       reduce using rule 49 (mathop -> expr TIMES expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! PLUS            [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! MINUS           [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! TIMES           [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! DIVIDE          [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! MOD             [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! LT              [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! GT              [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! LE              [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! GE              [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! EQ              [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! NE              [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! OR              [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! AND             [ reduce using rule 49 (mathop -> expr TIMES expr .) ]
  ! NOT             [ reduce using rule 49 (mathop -> expr TIMES expr .) ]


state 113

    (52) logicop -> expr LT expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    RPARENT         reduce using rule 52 (logicop -> expr LT expr .)
    COMMA           reduce using rule 52 (logicop -> expr LT expr .)
    NEWLINE         reduce using rule 52 (logicop -> expr LT expr .)
    RBRACKET        reduce using rule 52 (logicop -> expr LT expr .)
    RETURN          reduce using rule 52 (logicop -> expr LT expr .)
    PROCEDURE       reduce using rule 52 (logicop -> expr LT expr .)
    PRINT           reduce using rule 52 (logicop -> expr LT expr .)
    WHILE           reduce using rule 52 (logicop -> expr LT expr .)
    FOR             reduce using rule 52 (logicop -> expr LT expr .)
    IF              reduce using rule 52 (logicop -> expr LT expr .)
    LBRACKET        reduce using rule 52 (logicop -> expr LT expr .)
    LPARENT         reduce using rule 52 (logicop -> expr LT expr .)
    FLOAT           reduce using rule 52 (logicop -> expr LT expr .)
    CONSTANT        reduce using rule 52 (logicop -> expr LT expr .)
    ID              reduce using rule 52 (logicop -> expr LT expr .)
    INC             reduce using rule 52 (logicop -> expr LT expr .)
    DEC             reduce using rule 52 (logicop -> expr LT expr .)
    BLTIN           reduce using rule 52 (logicop -> expr LT expr .)
    END             reduce using rule 52 (logicop -> expr LT expr .)
    SEMICOLON       reduce using rule 52 (logicop -> expr LT expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! PLUS            [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! TIMES           [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! MOD             [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! LT              [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! GT              [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! LE              [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! GE              [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! EQ              [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! NE              [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! OR              [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! AND             [ reduce using rule 52 (logicop -> expr LT expr .) ]
  ! NOT             [ reduce using rule 52 (logicop -> expr LT expr .) ]


state 114

    (54) logicop -> expr LE expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    RPARENT         reduce using rule 54 (logicop -> expr LE expr .)
    COMMA           reduce using rule 54 (logicop -> expr LE expr .)
    NEWLINE         reduce using rule 54 (logicop -> expr LE expr .)
    RBRACKET        reduce using rule 54 (logicop -> expr LE expr .)
    RETURN          reduce using rule 54 (logicop -> expr LE expr .)
    PROCEDURE       reduce using rule 54 (logicop -> expr LE expr .)
    PRINT           reduce using rule 54 (logicop -> expr LE expr .)
    WHILE           reduce using rule 54 (logicop -> expr LE expr .)
    FOR             reduce using rule 54 (logicop -> expr LE expr .)
    IF              reduce using rule 54 (logicop -> expr LE expr .)
    LBRACKET        reduce using rule 54 (logicop -> expr LE expr .)
    LPARENT         reduce using rule 54 (logicop -> expr LE expr .)
    FLOAT           reduce using rule 54 (logicop -> expr LE expr .)
    CONSTANT        reduce using rule 54 (logicop -> expr LE expr .)
    ID              reduce using rule 54 (logicop -> expr LE expr .)
    INC             reduce using rule 54 (logicop -> expr LE expr .)
    DEC             reduce using rule 54 (logicop -> expr LE expr .)
    BLTIN           reduce using rule 54 (logicop -> expr LE expr .)
    END             reduce using rule 54 (logicop -> expr LE expr .)
    SEMICOLON       reduce using rule 54 (logicop -> expr LE expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! PLUS            [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! MINUS           [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! TIMES           [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! DIVIDE          [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! MOD             [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! LT              [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! GT              [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! LE              [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! GE              [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! EQ              [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! NE              [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! OR              [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! AND             [ reduce using rule 54 (logicop -> expr LE expr .) ]
  ! NOT             [ reduce using rule 54 (logicop -> expr LE expr .) ]


state 115

    (47) mathop -> expr PLUS expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NEWLINE         reduce using rule 47 (mathop -> expr PLUS expr .)
    RBRACKET        reduce using rule 47 (mathop -> expr PLUS expr .)
    RETURN          reduce using rule 47 (mathop -> expr PLUS expr .)
    PROCEDURE       reduce using rule 47 (mathop -> expr PLUS expr .)
    PRINT           reduce using rule 47 (mathop -> expr PLUS expr .)
    WHILE           reduce using rule 47 (mathop -> expr PLUS expr .)
    FOR             reduce using rule 47 (mathop -> expr PLUS expr .)
    IF              reduce using rule 47 (mathop -> expr PLUS expr .)
    LBRACKET        reduce using rule 47 (mathop -> expr PLUS expr .)
    LPARENT         reduce using rule 47 (mathop -> expr PLUS expr .)
    FLOAT           reduce using rule 47 (mathop -> expr PLUS expr .)
    CONSTANT        reduce using rule 47 (mathop -> expr PLUS expr .)
    ID              reduce using rule 47 (mathop -> expr PLUS expr .)
    INC             reduce using rule 47 (mathop -> expr PLUS expr .)
    DEC             reduce using rule 47 (mathop -> expr PLUS expr .)
    BLTIN           reduce using rule 47 (mathop -> expr PLUS expr .)
    END             reduce using rule 47 (mathop -> expr PLUS expr .)
    COMMA           reduce using rule 47 (mathop -> expr PLUS expr .)
    RPARENT         reduce using rule 47 (mathop -> expr PLUS expr .)
    SEMICOLON       reduce using rule 47 (mathop -> expr PLUS expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! PLUS            [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! MINUS           [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! TIMES           [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! MOD             [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! LT              [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! GT              [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! LE              [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! GE              [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! EQ              [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! NE              [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! OR              [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! AND             [ reduce using rule 47 (mathop -> expr PLUS expr .) ]
  ! NOT             [ reduce using rule 47 (mathop -> expr PLUS expr .) ]


state 116

    (46) mathop -> expr EXP expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NEWLINE         reduce using rule 46 (mathop -> expr EXP expr .)
    RBRACKET        reduce using rule 46 (mathop -> expr EXP expr .)
    RETURN          reduce using rule 46 (mathop -> expr EXP expr .)
    PROCEDURE       reduce using rule 46 (mathop -> expr EXP expr .)
    PRINT           reduce using rule 46 (mathop -> expr EXP expr .)
    WHILE           reduce using rule 46 (mathop -> expr EXP expr .)
    FOR             reduce using rule 46 (mathop -> expr EXP expr .)
    IF              reduce using rule 46 (mathop -> expr EXP expr .)
    LBRACKET        reduce using rule 46 (mathop -> expr EXP expr .)
    LPARENT         reduce using rule 46 (mathop -> expr EXP expr .)
    FLOAT           reduce using rule 46 (mathop -> expr EXP expr .)
    CONSTANT        reduce using rule 46 (mathop -> expr EXP expr .)
    ID              reduce using rule 46 (mathop -> expr EXP expr .)
    INC             reduce using rule 46 (mathop -> expr EXP expr .)
    DEC             reduce using rule 46 (mathop -> expr EXP expr .)
    BLTIN           reduce using rule 46 (mathop -> expr EXP expr .)
    END             reduce using rule 46 (mathop -> expr EXP expr .)
    COMMA           reduce using rule 46 (mathop -> expr EXP expr .)
    RPARENT         reduce using rule 46 (mathop -> expr EXP expr .)
    SEMICOLON       reduce using rule 46 (mathop -> expr EXP expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! PLUS            [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! MINUS           [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! TIMES           [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! DIVIDE          [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! MOD             [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! LT              [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! GT              [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! LE              [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! GE              [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! EQ              [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! NE              [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! OR              [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! AND             [ reduce using rule 46 (mathop -> expr EXP expr .) ]
  ! NOT             [ reduce using rule 46 (mathop -> expr EXP expr .) ]


state 117

    (60) logicop -> expr NOT expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    RPARENT         reduce using rule 60 (logicop -> expr NOT expr .)
    COMMA           reduce using rule 60 (logicop -> expr NOT expr .)
    NEWLINE         reduce using rule 60 (logicop -> expr NOT expr .)
    RBRACKET        reduce using rule 60 (logicop -> expr NOT expr .)
    RETURN          reduce using rule 60 (logicop -> expr NOT expr .)
    PROCEDURE       reduce using rule 60 (logicop -> expr NOT expr .)
    PRINT           reduce using rule 60 (logicop -> expr NOT expr .)
    WHILE           reduce using rule 60 (logicop -> expr NOT expr .)
    FOR             reduce using rule 60 (logicop -> expr NOT expr .)
    IF              reduce using rule 60 (logicop -> expr NOT expr .)
    LBRACKET        reduce using rule 60 (logicop -> expr NOT expr .)
    LPARENT         reduce using rule 60 (logicop -> expr NOT expr .)
    FLOAT           reduce using rule 60 (logicop -> expr NOT expr .)
    CONSTANT        reduce using rule 60 (logicop -> expr NOT expr .)
    ID              reduce using rule 60 (logicop -> expr NOT expr .)
    INC             reduce using rule 60 (logicop -> expr NOT expr .)
    DEC             reduce using rule 60 (logicop -> expr NOT expr .)
    BLTIN           reduce using rule 60 (logicop -> expr NOT expr .)
    END             reduce using rule 60 (logicop -> expr NOT expr .)
    SEMICOLON       reduce using rule 60 (logicop -> expr NOT expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! PLUS            [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! MINUS           [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! TIMES           [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! DIVIDE          [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! MOD             [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! LT              [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! GT              [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! LE              [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! GE              [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! EQ              [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! NE              [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! OR              [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! AND             [ reduce using rule 60 (logicop -> expr NOT expr .) ]
  ! NOT             [ reduce using rule 60 (logicop -> expr NOT expr .) ]


state 118

    (56) logicop -> expr EQ expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    RPARENT         reduce using rule 56 (logicop -> expr EQ expr .)
    COMMA           reduce using rule 56 (logicop -> expr EQ expr .)
    NEWLINE         reduce using rule 56 (logicop -> expr EQ expr .)
    RBRACKET        reduce using rule 56 (logicop -> expr EQ expr .)
    RETURN          reduce using rule 56 (logicop -> expr EQ expr .)
    PROCEDURE       reduce using rule 56 (logicop -> expr EQ expr .)
    PRINT           reduce using rule 56 (logicop -> expr EQ expr .)
    WHILE           reduce using rule 56 (logicop -> expr EQ expr .)
    FOR             reduce using rule 56 (logicop -> expr EQ expr .)
    IF              reduce using rule 56 (logicop -> expr EQ expr .)
    LBRACKET        reduce using rule 56 (logicop -> expr EQ expr .)
    LPARENT         reduce using rule 56 (logicop -> expr EQ expr .)
    FLOAT           reduce using rule 56 (logicop -> expr EQ expr .)
    CONSTANT        reduce using rule 56 (logicop -> expr EQ expr .)
    ID              reduce using rule 56 (logicop -> expr EQ expr .)
    INC             reduce using rule 56 (logicop -> expr EQ expr .)
    DEC             reduce using rule 56 (logicop -> expr EQ expr .)
    BLTIN           reduce using rule 56 (logicop -> expr EQ expr .)
    END             reduce using rule 56 (logicop -> expr EQ expr .)
    SEMICOLON       reduce using rule 56 (logicop -> expr EQ expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! PLUS            [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! MINUS           [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! TIMES           [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! DIVIDE          [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! MOD             [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! LT              [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! GT              [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! LE              [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! GE              [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! EQ              [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! NE              [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! OR              [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! AND             [ reduce using rule 56 (logicop -> expr EQ expr .) ]
  ! NOT             [ reduce using rule 56 (logicop -> expr EQ expr .) ]


state 119

    (48) mathop -> expr MINUS expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NEWLINE         reduce using rule 48 (mathop -> expr MINUS expr .)
    RBRACKET        reduce using rule 48 (mathop -> expr MINUS expr .)
    RETURN          reduce using rule 48 (mathop -> expr MINUS expr .)
    PROCEDURE       reduce using rule 48 (mathop -> expr MINUS expr .)
    PRINT           reduce using rule 48 (mathop -> expr MINUS expr .)
    WHILE           reduce using rule 48 (mathop -> expr MINUS expr .)
    FOR             reduce using rule 48 (mathop -> expr MINUS expr .)
    IF              reduce using rule 48 (mathop -> expr MINUS expr .)
    LBRACKET        reduce using rule 48 (mathop -> expr MINUS expr .)
    LPARENT         reduce using rule 48 (mathop -> expr MINUS expr .)
    FLOAT           reduce using rule 48 (mathop -> expr MINUS expr .)
    CONSTANT        reduce using rule 48 (mathop -> expr MINUS expr .)
    ID              reduce using rule 48 (mathop -> expr MINUS expr .)
    INC             reduce using rule 48 (mathop -> expr MINUS expr .)
    DEC             reduce using rule 48 (mathop -> expr MINUS expr .)
    BLTIN           reduce using rule 48 (mathop -> expr MINUS expr .)
    END             reduce using rule 48 (mathop -> expr MINUS expr .)
    COMMA           reduce using rule 48 (mathop -> expr MINUS expr .)
    RPARENT         reduce using rule 48 (mathop -> expr MINUS expr .)
    SEMICOLON       reduce using rule 48 (mathop -> expr MINUS expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! PLUS            [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! MINUS           [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! TIMES           [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! LT              [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! GT              [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! LE              [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! GE              [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! EQ              [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! NE              [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! OR              [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! AND             [ reduce using rule 48 (mathop -> expr MINUS expr .) ]
  ! NOT             [ reduce using rule 48 (mathop -> expr MINUS expr .) ]


state 120

    (57) logicop -> expr NE expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    RPARENT         reduce using rule 57 (logicop -> expr NE expr .)
    COMMA           reduce using rule 57 (logicop -> expr NE expr .)
    NEWLINE         reduce using rule 57 (logicop -> expr NE expr .)
    RBRACKET        reduce using rule 57 (logicop -> expr NE expr .)
    RETURN          reduce using rule 57 (logicop -> expr NE expr .)
    PROCEDURE       reduce using rule 57 (logicop -> expr NE expr .)
    PRINT           reduce using rule 57 (logicop -> expr NE expr .)
    WHILE           reduce using rule 57 (logicop -> expr NE expr .)
    FOR             reduce using rule 57 (logicop -> expr NE expr .)
    IF              reduce using rule 57 (logicop -> expr NE expr .)
    LBRACKET        reduce using rule 57 (logicop -> expr NE expr .)
    LPARENT         reduce using rule 57 (logicop -> expr NE expr .)
    FLOAT           reduce using rule 57 (logicop -> expr NE expr .)
    CONSTANT        reduce using rule 57 (logicop -> expr NE expr .)
    ID              reduce using rule 57 (logicop -> expr NE expr .)
    INC             reduce using rule 57 (logicop -> expr NE expr .)
    DEC             reduce using rule 57 (logicop -> expr NE expr .)
    BLTIN           reduce using rule 57 (logicop -> expr NE expr .)
    END             reduce using rule 57 (logicop -> expr NE expr .)
    SEMICOLON       reduce using rule 57 (logicop -> expr NE expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! PLUS            [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! MINUS           [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! TIMES           [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! DIVIDE          [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! MOD             [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! LT              [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! GT              [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! LE              [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! GE              [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! EQ              [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! NE              [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! OR              [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! AND             [ reduce using rule 57 (logicop -> expr NE expr .) ]
  ! NOT             [ reduce using rule 57 (logicop -> expr NE expr .) ]


state 121

    (51) mathop -> expr MOD expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NEWLINE         reduce using rule 51 (mathop -> expr MOD expr .)
    RBRACKET        reduce using rule 51 (mathop -> expr MOD expr .)
    RETURN          reduce using rule 51 (mathop -> expr MOD expr .)
    PROCEDURE       reduce using rule 51 (mathop -> expr MOD expr .)
    PRINT           reduce using rule 51 (mathop -> expr MOD expr .)
    WHILE           reduce using rule 51 (mathop -> expr MOD expr .)
    FOR             reduce using rule 51 (mathop -> expr MOD expr .)
    IF              reduce using rule 51 (mathop -> expr MOD expr .)
    LBRACKET        reduce using rule 51 (mathop -> expr MOD expr .)
    LPARENT         reduce using rule 51 (mathop -> expr MOD expr .)
    FLOAT           reduce using rule 51 (mathop -> expr MOD expr .)
    CONSTANT        reduce using rule 51 (mathop -> expr MOD expr .)
    ID              reduce using rule 51 (mathop -> expr MOD expr .)
    INC             reduce using rule 51 (mathop -> expr MOD expr .)
    DEC             reduce using rule 51 (mathop -> expr MOD expr .)
    BLTIN           reduce using rule 51 (mathop -> expr MOD expr .)
    END             reduce using rule 51 (mathop -> expr MOD expr .)
    COMMA           reduce using rule 51 (mathop -> expr MOD expr .)
    RPARENT         reduce using rule 51 (mathop -> expr MOD expr .)
    SEMICOLON       reduce using rule 51 (mathop -> expr MOD expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! EXP             [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! PLUS            [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! MINUS           [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! TIMES           [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! DIVIDE          [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! MOD             [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! LT              [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! GT              [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! LE              [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! GE              [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! EQ              [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! NE              [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! OR              [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! AND             [ reduce using rule 51 (mathop -> expr MOD expr .) ]
  ! NOT             [ reduce using rule 51 (mathop -> expr MOD expr .) ]


state 122

    (68) defn -> PROC procname LPARENT . formals RPARENT
    (69) formals -> . ID
    (70) formals -> . ID COMMA formals

    ID              shift and go to state 128

    formals                        shift and go to state 135

state 123

    (15) stmt -> WHILE LPARENT cond RPARENT . stmt END
    (10) stmt -> . expr
    (11) stmt -> . RETURN
    (12) stmt -> . RETURN expr
    (13) stmt -> . PROCEDURE BEGIN LPARENT arglist RPARENT
    (14) stmt -> . PRINT prlist
    (15) stmt -> . WHILE LPARENT cond RPARENT stmt END
    (16) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END
    (17) stmt -> . IF LPARENT cond RPARENT stmt END
    (18) stmt -> . IF LPARENT cond RPARENT stmt END ELSE stmt END
    (19) stmt -> . LBRACKET stmtlist RBRACKET
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    RETURN          shift and go to state 4
    PROCEDURE       shift and go to state 23
    PRINT           shift and go to state 7
    WHILE           shift and go to state 6
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 5
    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 89
    callfunc                       shift and go to state 27
    stmt                           shift and go to state 136
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 124

    (66) prlist -> prlist COMMA STRING .

    COMMA           reduce using rule 66 (prlist -> prlist COMMA STRING .)
    NEWLINE         reduce using rule 66 (prlist -> prlist COMMA STRING .)
    RBRACKET        reduce using rule 66 (prlist -> prlist COMMA STRING .)
    RETURN          reduce using rule 66 (prlist -> prlist COMMA STRING .)
    PROCEDURE       reduce using rule 66 (prlist -> prlist COMMA STRING .)
    PRINT           reduce using rule 66 (prlist -> prlist COMMA STRING .)
    WHILE           reduce using rule 66 (prlist -> prlist COMMA STRING .)
    FOR             reduce using rule 66 (prlist -> prlist COMMA STRING .)
    IF              reduce using rule 66 (prlist -> prlist COMMA STRING .)
    LBRACKET        reduce using rule 66 (prlist -> prlist COMMA STRING .)
    LPARENT         reduce using rule 66 (prlist -> prlist COMMA STRING .)
    FLOAT           reduce using rule 66 (prlist -> prlist COMMA STRING .)
    CONSTANT        reduce using rule 66 (prlist -> prlist COMMA STRING .)
    ID              reduce using rule 66 (prlist -> prlist COMMA STRING .)
    MINUS           reduce using rule 66 (prlist -> prlist COMMA STRING .)
    INC             reduce using rule 66 (prlist -> prlist COMMA STRING .)
    DEC             reduce using rule 66 (prlist -> prlist COMMA STRING .)
    BLTIN           reduce using rule 66 (prlist -> prlist COMMA STRING .)
    END             reduce using rule 66 (prlist -> prlist COMMA STRING .)


state 125

    (65) prlist -> prlist COMMA expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

  ! shift/reduce conflict for MINUS resolved as shift
    COMMA           reduce using rule 65 (prlist -> prlist COMMA expr .)
    NEWLINE         reduce using rule 65 (prlist -> prlist COMMA expr .)
    RBRACKET        reduce using rule 65 (prlist -> prlist COMMA expr .)
    RETURN          reduce using rule 65 (prlist -> prlist COMMA expr .)
    PROCEDURE       reduce using rule 65 (prlist -> prlist COMMA expr .)
    PRINT           reduce using rule 65 (prlist -> prlist COMMA expr .)
    WHILE           reduce using rule 65 (prlist -> prlist COMMA expr .)
    FOR             reduce using rule 65 (prlist -> prlist COMMA expr .)
    IF              reduce using rule 65 (prlist -> prlist COMMA expr .)
    LBRACKET        reduce using rule 65 (prlist -> prlist COMMA expr .)
    LPARENT         reduce using rule 65 (prlist -> prlist COMMA expr .)
    FLOAT           reduce using rule 65 (prlist -> prlist COMMA expr .)
    CONSTANT        reduce using rule 65 (prlist -> prlist COMMA expr .)
    ID              reduce using rule 65 (prlist -> prlist COMMA expr .)
    INC             reduce using rule 65 (prlist -> prlist COMMA expr .)
    DEC             reduce using rule 65 (prlist -> prlist COMMA expr .)
    BLTIN           reduce using rule 65 (prlist -> prlist COMMA expr .)
    END             reduce using rule 65 (prlist -> prlist COMMA expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79

  ! MINUS           [ reduce using rule 65 (prlist -> prlist COMMA expr .) ]


state 126

    (16) stmt -> FOR LPARENT cond SEMICOLON . cond SEMICOLON cond RPARENT stmt END
    (20) cond -> . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 92
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    cond                           shift and go to state 137
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 127

    (61) callfunc -> BLTIN LPARENT expr RPARENT .

    EXP             reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    PLUS            reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    MINUS           reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    TIMES           reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    DIVIDE          reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    MOD             reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    LT              reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    GT              reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    LE              reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    GE              reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    EQ              reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    NE              reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    OR              reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    AND             reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    NOT             reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    NEWLINE         reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    RBRACKET        reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    RETURN          reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    PROCEDURE       reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    PRINT           reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    WHILE           reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    FOR             reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    IF              reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    LBRACKET        reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    LPARENT         reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    FLOAT           reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    CONSTANT        reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    ID              reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    INC             reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    DEC             reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    BLTIN           reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    END             reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    COMMA           reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    RPARENT         reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)
    SEMICOLON       reduce using rule 61 (callfunc -> BLTIN LPARENT expr RPARENT .)


state 128

    (69) formals -> ID .
    (70) formals -> ID . COMMA formals

    RPARENT         reduce using rule 69 (formals -> ID .)
    COMMA           shift and go to state 138


state 129

    (67) defn -> FUNC procname LPARENT formals . RPARENT

    RPARENT         shift and go to state 139


state 130

    (62) callfunc -> ID LPARENT expr RPARENT .

    EXP             reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    PLUS            reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    MINUS           reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    TIMES           reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    DIVIDE          reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    MOD             reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    LT              reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    GT              reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    LE              reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    GE              reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    EQ              reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    NE              reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    OR              reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    AND             reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    NOT             reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    NEWLINE         reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    RBRACKET        reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    RETURN          reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    PROCEDURE       reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    PRINT           reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    WHILE           reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    FOR             reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    IF              reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    LBRACKET        reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    LPARENT         reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    FLOAT           reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    CONSTANT        reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    ID              reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    INC             reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    DEC             reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    BLTIN           reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    END             reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    COMMA           reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    RPARENT         reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)
    SEMICOLON       reduce using rule 62 (callfunc -> ID LPARENT expr RPARENT .)


state 131

    (13) stmt -> PROCEDURE BEGIN LPARENT arglist . RPARENT
    (77) arglist -> arglist . COMMA expr

    RPARENT         shift and go to state 141
    COMMA           shift and go to state 140


state 132

    (75) arglist -> empty .

    RPARENT         reduce using rule 75 (arglist -> empty .)
    COMMA           reduce using rule 75 (arglist -> empty .)


state 133

    (76) arglist -> expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

    RPARENT         reduce using rule 76 (arglist -> expr .)
    COMMA           reduce using rule 76 (arglist -> expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79


state 134

    (17) stmt -> IF LPARENT cond RPARENT . stmt END
    (18) stmt -> IF LPARENT cond RPARENT . stmt END ELSE stmt END
    (10) stmt -> . expr
    (11) stmt -> . RETURN
    (12) stmt -> . RETURN expr
    (13) stmt -> . PROCEDURE BEGIN LPARENT arglist RPARENT
    (14) stmt -> . PRINT prlist
    (15) stmt -> . WHILE LPARENT cond RPARENT stmt END
    (16) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END
    (17) stmt -> . IF LPARENT cond RPARENT stmt END
    (18) stmt -> . IF LPARENT cond RPARENT stmt END ELSE stmt END
    (19) stmt -> . LBRACKET stmtlist RBRACKET
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    RETURN          shift and go to state 4
    PROCEDURE       shift and go to state 23
    PRINT           shift and go to state 7
    WHILE           shift and go to state 6
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 5
    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 89
    callfunc                       shift and go to state 27
    stmt                           shift and go to state 142
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 135

    (68) defn -> PROC procname LPARENT formals . RPARENT

    RPARENT         shift and go to state 143


state 136

    (15) stmt -> WHILE LPARENT cond RPARENT stmt . END

    END             shift and go to state 144


state 137

    (16) stmt -> FOR LPARENT cond SEMICOLON cond . SEMICOLON cond RPARENT stmt END

    SEMICOLON       shift and go to state 145


state 138

    (70) formals -> ID COMMA . formals
    (69) formals -> . ID
    (70) formals -> . ID COMMA formals

    ID              shift and go to state 128

    formals                        shift and go to state 146

state 139

    (67) defn -> FUNC procname LPARENT formals RPARENT .

    NEWLINE         reduce using rule 67 (defn -> FUNC procname LPARENT formals RPARENT .)


state 140

    (77) arglist -> arglist COMMA . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 147
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 141

    (13) stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .

    END             reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    RBRACKET        reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    NEWLINE         reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    RETURN          reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    PROCEDURE       reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    PRINT           reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    WHILE           reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    FOR             reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    IF              reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    LBRACKET        reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    LPARENT         reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    FLOAT           reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    CONSTANT        reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    ID              reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    MINUS           reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    INC             reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    DEC             reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)
    BLTIN           reduce using rule 13 (stmt -> PROCEDURE BEGIN LPARENT arglist RPARENT .)


state 142

    (17) stmt -> IF LPARENT cond RPARENT stmt . END
    (18) stmt -> IF LPARENT cond RPARENT stmt . END ELSE stmt END

    END             shift and go to state 148


state 143

    (68) defn -> PROC procname LPARENT formals RPARENT .

    NEWLINE         reduce using rule 68 (defn -> PROC procname LPARENT formals RPARENT .)


state 144

    (15) stmt -> WHILE LPARENT cond RPARENT stmt END .

    END             reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    RBRACKET        reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    NEWLINE         reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    RETURN          reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    PROCEDURE       reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    PRINT           reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    WHILE           reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    FOR             reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    IF              reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    LBRACKET        reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    LPARENT         reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    FLOAT           reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    CONSTANT        reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    ID              reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    MINUS           reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    INC             reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    DEC             reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)
    BLTIN           reduce using rule 15 (stmt -> WHILE LPARENT cond RPARENT stmt END .)


state 145

    (16) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON . cond RPARENT stmt END
    (20) cond -> . expr
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    unaryop                        shift and go to state 16
    expr                           shift and go to state 92
    callfunc                       shift and go to state 27
    asgn                           shift and go to state 34
    cond                           shift and go to state 149
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 146

    (70) formals -> ID COMMA formals .

    RPARENT         reduce using rule 70 (formals -> ID COMMA formals .)


state 147

    (77) arglist -> arglist COMMA expr .
    (46) mathop -> expr . EXP expr
    (47) mathop -> expr . PLUS expr
    (48) mathop -> expr . MINUS expr
    (49) mathop -> expr . TIMES expr
    (50) mathop -> expr . DIVIDE expr
    (51) mathop -> expr . MOD expr
    (52) logicop -> expr . LT expr
    (53) logicop -> expr . GT expr
    (54) logicop -> expr . LE expr
    (55) logicop -> expr . GE expr
    (56) logicop -> expr . EQ expr
    (57) logicop -> expr . NE expr
    (58) logicop -> expr . OR expr
    (59) logicop -> expr . AND expr
    (60) logicop -> expr . NOT expr

    RPARENT         reduce using rule 77 (arglist -> arglist COMMA expr .)
    COMMA           reduce using rule 77 (arglist -> arglist COMMA expr .)
    EXP             shift and go to state 78
    PLUS            shift and go to state 77
    MINUS           shift and go to state 81
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 71
    MOD             shift and go to state 83
    LT              shift and go to state 75
    GT              shift and go to state 70
    LE              shift and go to state 76
    GE              shift and go to state 73
    EQ              shift and go to state 80
    NE              shift and go to state 82
    OR              shift and go to state 69
    AND             shift and go to state 68
    NOT             shift and go to state 79


state 148

    (17) stmt -> IF LPARENT cond RPARENT stmt END .
    (18) stmt -> IF LPARENT cond RPARENT stmt END . ELSE stmt END

    END             reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    RBRACKET        reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    NEWLINE         reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    RETURN          reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    PROCEDURE       reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    PRINT           reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    WHILE           reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    FOR             reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    IF              reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    LBRACKET        reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    LPARENT         reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    FLOAT           reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    CONSTANT        reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    ID              reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    MINUS           reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    INC             reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    DEC             reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    BLTIN           reduce using rule 17 (stmt -> IF LPARENT cond RPARENT stmt END .)
    ELSE            shift and go to state 150


state 149

    (16) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond . RPARENT stmt END

    RPARENT         shift and go to state 151


state 150

    (18) stmt -> IF LPARENT cond RPARENT stmt END ELSE . stmt END
    (10) stmt -> . expr
    (11) stmt -> . RETURN
    (12) stmt -> . RETURN expr
    (13) stmt -> . PROCEDURE BEGIN LPARENT arglist RPARENT
    (14) stmt -> . PRINT prlist
    (15) stmt -> . WHILE LPARENT cond RPARENT stmt END
    (16) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END
    (17) stmt -> . IF LPARENT cond RPARENT stmt END
    (18) stmt -> . IF LPARENT cond RPARENT stmt END ELSE stmt END
    (19) stmt -> . LBRACKET stmtlist RBRACKET
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    RETURN          shift and go to state 4
    PROCEDURE       shift and go to state 23
    PRINT           shift and go to state 7
    WHILE           shift and go to state 6
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 5
    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 89
    callfunc                       shift and go to state 27
    stmt                           shift and go to state 152
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 151

    (16) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT . stmt END
    (10) stmt -> . expr
    (11) stmt -> . RETURN
    (12) stmt -> . RETURN expr
    (13) stmt -> . PROCEDURE BEGIN LPARENT arglist RPARENT
    (14) stmt -> . PRINT prlist
    (15) stmt -> . WHILE LPARENT cond RPARENT stmt END
    (16) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END
    (17) stmt -> . IF LPARENT cond RPARENT stmt END
    (18) stmt -> . IF LPARENT cond RPARENT stmt END ELSE stmt END
    (19) stmt -> . LBRACKET stmtlist RBRACKET
    (24) expr -> . data
    (25) expr -> . unaryop
    (26) expr -> . binaryop
    (27) expr -> . LPARENT expr RPARENT
    (28) expr -> . callfunc
    (29) data -> . FLOAT
    (30) data -> . CONSTANT
    (31) data -> . ID
    (32) unaryop -> . MINUS expr
    (33) unaryop -> . INC ID
    (34) unaryop -> . DEC ID
    (35) unaryop -> . ID INC
    (36) unaryop -> . ID DEC
    (37) binaryop -> . asgn
    (38) binaryop -> . mathop
    (39) binaryop -> . logicop
    (61) callfunc -> . BLTIN LPARENT expr RPARENT
    (62) callfunc -> . ID LPARENT expr RPARENT
    (40) asgn -> . ID ASSIGN expr
    (41) asgn -> . ID ADDEQ expr
    (42) asgn -> . ID SUBEQ expr
    (43) asgn -> . ID MULEQ expr
    (44) asgn -> . ID DIVEQ expr
    (45) asgn -> . ID MODEQ expr
    (46) mathop -> . expr EXP expr
    (47) mathop -> . expr PLUS expr
    (48) mathop -> . expr MINUS expr
    (49) mathop -> . expr TIMES expr
    (50) mathop -> . expr DIVIDE expr
    (51) mathop -> . expr MOD expr
    (52) logicop -> . expr LT expr
    (53) logicop -> . expr GT expr
    (54) logicop -> . expr LE expr
    (55) logicop -> . expr GE expr
    (56) logicop -> . expr EQ expr
    (57) logicop -> . expr NE expr
    (58) logicop -> . expr OR expr
    (59) logicop -> . expr AND expr
    (60) logicop -> . expr NOT expr

    RETURN          shift and go to state 4
    PROCEDURE       shift and go to state 23
    PRINT           shift and go to state 7
    WHILE           shift and go to state 6
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 5
    LPARENT         shift and go to state 12
    FLOAT           shift and go to state 28
    CONSTANT        shift and go to state 8
    ID              shift and go to state 35
    MINUS           shift and go to state 10
    INC             shift and go to state 33
    DEC             shift and go to state 25
    BLTIN           shift and go to state 18

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 89
    callfunc                       shift and go to state 27
    stmt                           shift and go to state 153
    asgn                           shift and go to state 34
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 21

state 152

    (18) stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt . END

    END             shift and go to state 154


state 153

    (16) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt . END

    END             shift and go to state 155


state 154

    (18) stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .

    END             reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    RBRACKET        reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    NEWLINE         reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    RETURN          reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    PROCEDURE       reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    PRINT           reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    WHILE           reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    FOR             reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    IF              reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    LBRACKET        reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    LPARENT         reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    FLOAT           reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    CONSTANT        reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    ID              reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    MINUS           reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    INC             reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    DEC             reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)
    BLTIN           reduce using rule 18 (stmt -> IF LPARENT cond RPARENT stmt END ELSE stmt END .)


state 155

    (16) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .

    END             reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    RBRACKET        reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    NEWLINE         reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    RETURN          reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    PROCEDURE       reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    PRINT           reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    WHILE           reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    FOR             reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    IF              reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    LBRACKET        reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    LPARENT         reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    FLOAT           reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    CONSTANT        reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    ID              reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    MINUS           reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    INC             reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    DEC             reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)
    BLTIN           reduce using rule 16 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPARENT in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 4 resolved as shift
WARNING: shift/reduce conflict for ID in state 4 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 4 resolved as shift
WARNING: shift/reduce conflict for INC in state 4 resolved as shift
WARNING: shift/reduce conflict for DEC in state 4 resolved as shift
WARNING: shift/reduce conflict for BLTIN in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 14 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 26 resolved as shift
WARNING: shift/reduce conflict for INC in state 35 resolved as shift
WARNING: shift/reduce conflict for DEC in state 35 resolved as shift
WARNING: shift/reduce conflict for LPARENT in state 35 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 36 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 41 resolved as shift
WARNING: shift/reduce conflict for EXP in state 43 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 43 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 43 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 43 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 43 resolved as shift
WARNING: shift/reduce conflict for MOD in state 43 resolved as shift
WARNING: shift/reduce conflict for LT in state 43 resolved as shift
WARNING: shift/reduce conflict for GT in state 43 resolved as shift
WARNING: shift/reduce conflict for LE in state 43 resolved as shift
WARNING: shift/reduce conflict for GE in state 43 resolved as shift
WARNING: shift/reduce conflict for EQ in state 43 resolved as shift
WARNING: shift/reduce conflict for NE in state 43 resolved as shift
WARNING: shift/reduce conflict for OR in state 43 resolved as shift
WARNING: shift/reduce conflict for AND in state 43 resolved as shift
WARNING: shift/reduce conflict for NOT in state 43 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 89 resolved as shift
WARNING: shift/reduce conflict for EXP in state 99 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 99 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 99 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 99 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 99 resolved as shift
WARNING: shift/reduce conflict for MOD in state 99 resolved as shift
WARNING: shift/reduce conflict for LT in state 99 resolved as shift
WARNING: shift/reduce conflict for GT in state 99 resolved as shift
WARNING: shift/reduce conflict for LE in state 99 resolved as shift
WARNING: shift/reduce conflict for GE in state 99 resolved as shift
WARNING: shift/reduce conflict for EQ in state 99 resolved as shift
WARNING: shift/reduce conflict for NE in state 99 resolved as shift
WARNING: shift/reduce conflict for OR in state 99 resolved as shift
WARNING: shift/reduce conflict for AND in state 99 resolved as shift
WARNING: shift/reduce conflict for NOT in state 99 resolved as shift
WARNING: shift/reduce conflict for EXP in state 100 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 100 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 100 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 100 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 100 resolved as shift
WARNING: shift/reduce conflict for MOD in state 100 resolved as shift
WARNING: shift/reduce conflict for LT in state 100 resolved as shift
WARNING: shift/reduce conflict for GT in state 100 resolved as shift
WARNING: shift/reduce conflict for LE in state 100 resolved as shift
WARNING: shift/reduce conflict for GE in state 100 resolved as shift
WARNING: shift/reduce conflict for EQ in state 100 resolved as shift
WARNING: shift/reduce conflict for NE in state 100 resolved as shift
WARNING: shift/reduce conflict for OR in state 100 resolved as shift
WARNING: shift/reduce conflict for AND in state 100 resolved as shift
WARNING: shift/reduce conflict for NOT in state 100 resolved as shift
WARNING: shift/reduce conflict for EXP in state 101 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 101 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 101 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 101 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 101 resolved as shift
WARNING: shift/reduce conflict for MOD in state 101 resolved as shift
WARNING: shift/reduce conflict for LT in state 101 resolved as shift
WARNING: shift/reduce conflict for GT in state 101 resolved as shift
WARNING: shift/reduce conflict for LE in state 101 resolved as shift
WARNING: shift/reduce conflict for GE in state 101 resolved as shift
WARNING: shift/reduce conflict for EQ in state 101 resolved as shift
WARNING: shift/reduce conflict for NE in state 101 resolved as shift
WARNING: shift/reduce conflict for OR in state 101 resolved as shift
WARNING: shift/reduce conflict for AND in state 101 resolved as shift
WARNING: shift/reduce conflict for NOT in state 101 resolved as shift
WARNING: shift/reduce conflict for EXP in state 102 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 102 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 102 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 102 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 102 resolved as shift
WARNING: shift/reduce conflict for MOD in state 102 resolved as shift
WARNING: shift/reduce conflict for LT in state 102 resolved as shift
WARNING: shift/reduce conflict for GT in state 102 resolved as shift
WARNING: shift/reduce conflict for LE in state 102 resolved as shift
WARNING: shift/reduce conflict for GE in state 102 resolved as shift
WARNING: shift/reduce conflict for EQ in state 102 resolved as shift
WARNING: shift/reduce conflict for NE in state 102 resolved as shift
WARNING: shift/reduce conflict for OR in state 102 resolved as shift
WARNING: shift/reduce conflict for AND in state 102 resolved as shift
WARNING: shift/reduce conflict for NOT in state 102 resolved as shift
WARNING: shift/reduce conflict for EXP in state 103 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 103 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 103 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 103 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 103 resolved as shift
WARNING: shift/reduce conflict for MOD in state 103 resolved as shift
WARNING: shift/reduce conflict for LT in state 103 resolved as shift
WARNING: shift/reduce conflict for GT in state 103 resolved as shift
WARNING: shift/reduce conflict for LE in state 103 resolved as shift
WARNING: shift/reduce conflict for GE in state 103 resolved as shift
WARNING: shift/reduce conflict for EQ in state 103 resolved as shift
WARNING: shift/reduce conflict for NE in state 103 resolved as shift
WARNING: shift/reduce conflict for OR in state 103 resolved as shift
WARNING: shift/reduce conflict for AND in state 103 resolved as shift
WARNING: shift/reduce conflict for NOT in state 103 resolved as shift
WARNING: shift/reduce conflict for EXP in state 104 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 104 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 104 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 104 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 104 resolved as shift
WARNING: shift/reduce conflict for MOD in state 104 resolved as shift
WARNING: shift/reduce conflict for LT in state 104 resolved as shift
WARNING: shift/reduce conflict for GT in state 104 resolved as shift
WARNING: shift/reduce conflict for LE in state 104 resolved as shift
WARNING: shift/reduce conflict for GE in state 104 resolved as shift
WARNING: shift/reduce conflict for EQ in state 104 resolved as shift
WARNING: shift/reduce conflict for NE in state 104 resolved as shift
WARNING: shift/reduce conflict for OR in state 104 resolved as shift
WARNING: shift/reduce conflict for AND in state 104 resolved as shift
WARNING: shift/reduce conflict for NOT in state 104 resolved as shift
WARNING: shift/reduce conflict for EXP in state 107 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 107 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 107 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 107 resolved as shift
WARNING: shift/reduce conflict for MOD in state 107 resolved as shift
WARNING: shift/reduce conflict for LT in state 107 resolved as shift
WARNING: shift/reduce conflict for GT in state 107 resolved as shift
WARNING: shift/reduce conflict for LE in state 107 resolved as shift
WARNING: shift/reduce conflict for GE in state 107 resolved as shift
WARNING: shift/reduce conflict for EQ in state 107 resolved as shift
WARNING: shift/reduce conflict for NE in state 107 resolved as shift
WARNING: shift/reduce conflict for OR in state 107 resolved as shift
WARNING: shift/reduce conflict for AND in state 107 resolved as shift
WARNING: shift/reduce conflict for NOT in state 107 resolved as shift
WARNING: shift/reduce conflict for EXP in state 108 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 108 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 108 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 108 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 108 resolved as shift
WARNING: shift/reduce conflict for MOD in state 108 resolved as shift
WARNING: shift/reduce conflict for LT in state 108 resolved as shift
WARNING: shift/reduce conflict for GT in state 108 resolved as shift
WARNING: shift/reduce conflict for LE in state 108 resolved as shift
WARNING: shift/reduce conflict for GE in state 108 resolved as shift
WARNING: shift/reduce conflict for EQ in state 108 resolved as shift
WARNING: shift/reduce conflict for NE in state 108 resolved as shift
WARNING: shift/reduce conflict for OR in state 108 resolved as shift
WARNING: shift/reduce conflict for AND in state 108 resolved as shift
WARNING: shift/reduce conflict for NOT in state 108 resolved as shift
WARNING: shift/reduce conflict for EXP in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for MOD in state 109 resolved as shift
WARNING: shift/reduce conflict for LT in state 109 resolved as shift
WARNING: shift/reduce conflict for GT in state 109 resolved as shift
WARNING: shift/reduce conflict for LE in state 109 resolved as shift
WARNING: shift/reduce conflict for GE in state 109 resolved as shift
WARNING: shift/reduce conflict for EQ in state 109 resolved as shift
WARNING: shift/reduce conflict for NE in state 109 resolved as shift
WARNING: shift/reduce conflict for OR in state 109 resolved as shift
WARNING: shift/reduce conflict for AND in state 109 resolved as shift
WARNING: shift/reduce conflict for NOT in state 109 resolved as shift
WARNING: shift/reduce conflict for EXP in state 110 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 110 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for MOD in state 110 resolved as shift
WARNING: shift/reduce conflict for LT in state 110 resolved as shift
WARNING: shift/reduce conflict for GT in state 110 resolved as shift
WARNING: shift/reduce conflict for LE in state 110 resolved as shift
WARNING: shift/reduce conflict for GE in state 110 resolved as shift
WARNING: shift/reduce conflict for EQ in state 110 resolved as shift
WARNING: shift/reduce conflict for NE in state 110 resolved as shift
WARNING: shift/reduce conflict for OR in state 110 resolved as shift
WARNING: shift/reduce conflict for AND in state 110 resolved as shift
WARNING: shift/reduce conflict for NOT in state 110 resolved as shift
WARNING: shift/reduce conflict for EXP in state 111 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 111 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 111 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 111 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 111 resolved as shift
WARNING: shift/reduce conflict for MOD in state 111 resolved as shift
WARNING: shift/reduce conflict for LT in state 111 resolved as shift
WARNING: shift/reduce conflict for GT in state 111 resolved as shift
WARNING: shift/reduce conflict for LE in state 111 resolved as shift
WARNING: shift/reduce conflict for GE in state 111 resolved as shift
WARNING: shift/reduce conflict for EQ in state 111 resolved as shift
WARNING: shift/reduce conflict for NE in state 111 resolved as shift
WARNING: shift/reduce conflict for OR in state 111 resolved as shift
WARNING: shift/reduce conflict for AND in state 111 resolved as shift
WARNING: shift/reduce conflict for NOT in state 111 resolved as shift
WARNING: shift/reduce conflict for EXP in state 112 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 112 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 112 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 112 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 112 resolved as shift
WARNING: shift/reduce conflict for MOD in state 112 resolved as shift
WARNING: shift/reduce conflict for LT in state 112 resolved as shift
WARNING: shift/reduce conflict for GT in state 112 resolved as shift
WARNING: shift/reduce conflict for LE in state 112 resolved as shift
WARNING: shift/reduce conflict for GE in state 112 resolved as shift
WARNING: shift/reduce conflict for EQ in state 112 resolved as shift
WARNING: shift/reduce conflict for NE in state 112 resolved as shift
WARNING: shift/reduce conflict for OR in state 112 resolved as shift
WARNING: shift/reduce conflict for AND in state 112 resolved as shift
WARNING: shift/reduce conflict for NOT in state 112 resolved as shift
WARNING: shift/reduce conflict for EXP in state 113 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 113 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for MOD in state 113 resolved as shift
WARNING: shift/reduce conflict for LT in state 113 resolved as shift
WARNING: shift/reduce conflict for GT in state 113 resolved as shift
WARNING: shift/reduce conflict for LE in state 113 resolved as shift
WARNING: shift/reduce conflict for GE in state 113 resolved as shift
WARNING: shift/reduce conflict for EQ in state 113 resolved as shift
WARNING: shift/reduce conflict for NE in state 113 resolved as shift
WARNING: shift/reduce conflict for OR in state 113 resolved as shift
WARNING: shift/reduce conflict for AND in state 113 resolved as shift
WARNING: shift/reduce conflict for NOT in state 113 resolved as shift
WARNING: shift/reduce conflict for EXP in state 114 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 114 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 114 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 114 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 114 resolved as shift
WARNING: shift/reduce conflict for MOD in state 114 resolved as shift
WARNING: shift/reduce conflict for LT in state 114 resolved as shift
WARNING: shift/reduce conflict for GT in state 114 resolved as shift
WARNING: shift/reduce conflict for LE in state 114 resolved as shift
WARNING: shift/reduce conflict for GE in state 114 resolved as shift
WARNING: shift/reduce conflict for EQ in state 114 resolved as shift
WARNING: shift/reduce conflict for NE in state 114 resolved as shift
WARNING: shift/reduce conflict for OR in state 114 resolved as shift
WARNING: shift/reduce conflict for AND in state 114 resolved as shift
WARNING: shift/reduce conflict for NOT in state 114 resolved as shift
WARNING: shift/reduce conflict for EXP in state 115 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 115 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 115 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for MOD in state 115 resolved as shift
WARNING: shift/reduce conflict for LT in state 115 resolved as shift
WARNING: shift/reduce conflict for GT in state 115 resolved as shift
WARNING: shift/reduce conflict for LE in state 115 resolved as shift
WARNING: shift/reduce conflict for GE in state 115 resolved as shift
WARNING: shift/reduce conflict for EQ in state 115 resolved as shift
WARNING: shift/reduce conflict for NE in state 115 resolved as shift
WARNING: shift/reduce conflict for OR in state 115 resolved as shift
WARNING: shift/reduce conflict for AND in state 115 resolved as shift
WARNING: shift/reduce conflict for NOT in state 115 resolved as shift
WARNING: shift/reduce conflict for EXP in state 116 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 116 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for MOD in state 116 resolved as shift
WARNING: shift/reduce conflict for LT in state 116 resolved as shift
WARNING: shift/reduce conflict for GT in state 116 resolved as shift
WARNING: shift/reduce conflict for LE in state 116 resolved as shift
WARNING: shift/reduce conflict for GE in state 116 resolved as shift
WARNING: shift/reduce conflict for EQ in state 116 resolved as shift
WARNING: shift/reduce conflict for NE in state 116 resolved as shift
WARNING: shift/reduce conflict for OR in state 116 resolved as shift
WARNING: shift/reduce conflict for AND in state 116 resolved as shift
WARNING: shift/reduce conflict for NOT in state 116 resolved as shift
WARNING: shift/reduce conflict for EXP in state 117 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 117 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 117 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 117 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 117 resolved as shift
WARNING: shift/reduce conflict for MOD in state 117 resolved as shift
WARNING: shift/reduce conflict for LT in state 117 resolved as shift
WARNING: shift/reduce conflict for GT in state 117 resolved as shift
WARNING: shift/reduce conflict for LE in state 117 resolved as shift
WARNING: shift/reduce conflict for GE in state 117 resolved as shift
WARNING: shift/reduce conflict for EQ in state 117 resolved as shift
WARNING: shift/reduce conflict for NE in state 117 resolved as shift
WARNING: shift/reduce conflict for OR in state 117 resolved as shift
WARNING: shift/reduce conflict for AND in state 117 resolved as shift
WARNING: shift/reduce conflict for NOT in state 117 resolved as shift
WARNING: shift/reduce conflict for EXP in state 118 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 118 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 118 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 118 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 118 resolved as shift
WARNING: shift/reduce conflict for MOD in state 118 resolved as shift
WARNING: shift/reduce conflict for LT in state 118 resolved as shift
WARNING: shift/reduce conflict for GT in state 118 resolved as shift
WARNING: shift/reduce conflict for LE in state 118 resolved as shift
WARNING: shift/reduce conflict for GE in state 118 resolved as shift
WARNING: shift/reduce conflict for EQ in state 118 resolved as shift
WARNING: shift/reduce conflict for NE in state 118 resolved as shift
WARNING: shift/reduce conflict for OR in state 118 resolved as shift
WARNING: shift/reduce conflict for AND in state 118 resolved as shift
WARNING: shift/reduce conflict for NOT in state 118 resolved as shift
WARNING: shift/reduce conflict for EXP in state 119 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 119 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 119 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 119 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 119 resolved as shift
WARNING: shift/reduce conflict for MOD in state 119 resolved as shift
WARNING: shift/reduce conflict for LT in state 119 resolved as shift
WARNING: shift/reduce conflict for GT in state 119 resolved as shift
WARNING: shift/reduce conflict for LE in state 119 resolved as shift
WARNING: shift/reduce conflict for GE in state 119 resolved as shift
WARNING: shift/reduce conflict for EQ in state 119 resolved as shift
WARNING: shift/reduce conflict for NE in state 119 resolved as shift
WARNING: shift/reduce conflict for OR in state 119 resolved as shift
WARNING: shift/reduce conflict for AND in state 119 resolved as shift
WARNING: shift/reduce conflict for NOT in state 119 resolved as shift
WARNING: shift/reduce conflict for EXP in state 120 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 120 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 120 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 120 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 120 resolved as shift
WARNING: shift/reduce conflict for MOD in state 120 resolved as shift
WARNING: shift/reduce conflict for LT in state 120 resolved as shift
WARNING: shift/reduce conflict for GT in state 120 resolved as shift
WARNING: shift/reduce conflict for LE in state 120 resolved as shift
WARNING: shift/reduce conflict for GE in state 120 resolved as shift
WARNING: shift/reduce conflict for EQ in state 120 resolved as shift
WARNING: shift/reduce conflict for NE in state 120 resolved as shift
WARNING: shift/reduce conflict for OR in state 120 resolved as shift
WARNING: shift/reduce conflict for AND in state 120 resolved as shift
WARNING: shift/reduce conflict for NOT in state 120 resolved as shift
WARNING: shift/reduce conflict for EXP in state 121 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 121 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 121 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 121 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 121 resolved as shift
WARNING: shift/reduce conflict for MOD in state 121 resolved as shift
WARNING: shift/reduce conflict for LT in state 121 resolved as shift
WARNING: shift/reduce conflict for GT in state 121 resolved as shift
WARNING: shift/reduce conflict for LE in state 121 resolved as shift
WARNING: shift/reduce conflict for GE in state 121 resolved as shift
WARNING: shift/reduce conflict for EQ in state 121 resolved as shift
WARNING: shift/reduce conflict for NE in state 121 resolved as shift
WARNING: shift/reduce conflict for OR in state 121 resolved as shift
WARNING: shift/reduce conflict for AND in state 121 resolved as shift
WARNING: shift/reduce conflict for NOT in state 121 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 125 resolved as shift
