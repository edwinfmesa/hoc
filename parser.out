Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> list
Rule 1     list -> empty
Rule 2     list -> list newline
Rule 3     list -> list defn newline
Rule 4     list -> list asgn newline
Rule 5     list -> list stmt newline
Rule 6     list -> list expr newline
Rule 7     list -> list error newline
Rule 8     list -> list COMMENT newline
Rule 9     asgn -> VAR ASSIGN expr
Rule 10    asgn -> VAR ADDEQ expr
Rule 11    asgn -> VAR SUBEQ expr
Rule 12    asgn -> VAR MULEQ expr
Rule 13    asgn -> VAR DIVEQ expr
Rule 14    asgn -> VAR MODEQ expr
Rule 15    stmt -> expr
Rule 16    stmt -> RETURN expr
Rule 17    stmt -> RETURN
Rule 18    stmt -> PRINT prlist
Rule 19    stmt -> WHILE LPARENT cond RPARENT stmt end
Rule 20    stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end
Rule 21    stmt -> IF LPARENT cond RPARENT stmt end
Rule 22    stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end
Rule 23    stmt -> LBRACKET stmtlist RBRACKET
Rule 24    end -> <empty>
Rule 25    begin -> <empty>
Rule 26    cond -> expr
Rule 27    stmtlist -> empty
Rule 28    stmtlist -> stmtlist newline
Rule 29    stmtlist -> stmtlist stmt
Rule 30    expr -> data
Rule 31    expr -> asgn
Rule 32    expr -> unaryop
Rule 33    expr -> binaryop
Rule 34    expr -> LPARENT expr RPARENT
Rule 35    expr -> callfunc
Rule 36    data -> FLOAT
Rule 37    data -> CONSTANT
Rule 38    data -> VAR
Rule 39    unaryop -> UNARYMINUS expr
Rule 40    unaryop -> UNARYPLUS expr
Rule 41    unaryop -> INC VAR
Rule 42    unaryop -> DEC VAR
Rule 43    unaryop -> VAR INC
Rule 44    unaryop -> VAR DEC
Rule 45    unaryop -> NOT expr
Rule 46    binaryop -> mathop
Rule 47    binaryop -> logicop
Rule 48    mathop -> expr EXP expr
Rule 49    mathop -> expr PLUS expr
Rule 50    mathop -> expr MINUS expr
Rule 51    mathop -> expr TIMES expr
Rule 52    mathop -> expr DIVIDE expr
Rule 53    mathop -> expr MOD expr
Rule 54    logicop -> expr LT expr
Rule 55    logicop -> expr GT expr
Rule 56    logicop -> expr LE expr
Rule 57    logicop -> expr GE expr
Rule 58    logicop -> expr EQ expr
Rule 59    logicop -> expr NE expr
Rule 60    logicop -> expr OR expr
Rule 61    logicop -> expr AND expr
Rule 62    callfunc -> BLTIN begin LPARENT expr RPARENT
Rule 63    callfunc -> VAR begin LPARENT arglist RPARENT
Rule 64    prlist -> expr
Rule 65    prlist -> STRING
Rule 66    prlist -> prlist COMMA expr
Rule 67    prlist -> prlist COMMA STRING
Rule 68    defn -> FUNC procname LPARENT formals RPARENT stmt
Rule 69    defn -> PROC procname LPARENT formals RPARENT stmt
Rule 70    procname -> VAR
Rule 71    formals -> empty
Rule 72    formals -> VAR
Rule 73    formals -> formals COMMA VAR
Rule 74    arglist -> empty
Rule 75    arglist -> expr
Rule 76    arglist -> arglist COMMA expr
Rule 77    empty -> <empty>
Rule 78    newline -> NEWLINE

Terminals, with rules where they appear

ADDEQ                : 10
AND                  : 61
ASSIGN               : 9
BLTIN                : 62
COMMA                : 66 67 73 76
COMMENT              : 8
CONSTANT             : 37
DEC                  : 42 44
DIVEQ                : 13
DIVIDE               : 52
ELSE                 : 22
EQ                   : 58
EXP                  : 48
FLOAT                : 36
FOR                  : 20
FUNC                 : 68
GE                   : 57
GT                   : 55
IF                   : 21 22
INC                  : 41 43
LBRACKET             : 23
LE                   : 56
LPARENT              : 19 20 21 22 34 62 63 68 69
LT                   : 54
MINUS                : 50
MOD                  : 53
MODEQ                : 14
MULEQ                : 12
NE                   : 59
NEWLINE              : 78
NOT                  : 45
OR                   : 60
PLUS                 : 49
PRINT                : 18
PROC                 : 69
RBRACKET             : 23
RETURN               : 16 17
RPARENT              : 19 20 21 22 34 62 63 68 69
SEMICOLON            : 20 20
STRING               : 65 67
SUBEQ                : 11
TIMES                : 51
UNARYMINUS           : 39
UNARYPLUS            : 40
VAR                  : 9 10 11 12 13 14 38 41 42 43 44 63 70 72 73
WHILE                : 19
error                : 7

Nonterminals, with rules where they appear

arglist              : 63 76
asgn                 : 4 31
begin                : 62 63
binaryop             : 33
callfunc             : 35
cond                 : 19 20 20 20 21 22
data                 : 30
defn                 : 3
empty                : 1 27 71 74
end                  : 19 20 21 22
expr                 : 6 9 10 11 12 13 14 15 16 26 34 39 40 45 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 64 66 75 76
formals              : 68 69 73
list                 : 2 3 4 5 6 7 8 0
logicop              : 47
mathop               : 46
newline              : 2 3 4 5 6 7 8 28
prlist               : 18 66 67
procname             : 68 69
stmt                 : 5 19 20 21 22 22 29 68 69
stmtlist             : 23 28 29
unaryop              : 32

Parsing method: LALR

state 0

    (0) S' -> . list
    (1) list -> . empty
    (2) list -> . list newline
    (3) list -> . list defn newline
    (4) list -> . list asgn newline
    (5) list -> . list stmt newline
    (6) list -> . list expr newline
    (7) list -> . list error newline
    (8) list -> . list COMMENT newline
    (77) empty -> .

    error           reduce using rule 77 (empty -> .)
    COMMENT         reduce using rule 77 (empty -> .)
    NEWLINE         reduce using rule 77 (empty -> .)
    FUNC            reduce using rule 77 (empty -> .)
    PROC            reduce using rule 77 (empty -> .)
    VAR             reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)
    PRINT           reduce using rule 77 (empty -> .)
    WHILE           reduce using rule 77 (empty -> .)
    FOR             reduce using rule 77 (empty -> .)
    IF              reduce using rule 77 (empty -> .)
    LBRACKET        reduce using rule 77 (empty -> .)
    LPARENT         reduce using rule 77 (empty -> .)
    FLOAT           reduce using rule 77 (empty -> .)
    CONSTANT        reduce using rule 77 (empty -> .)
    UNARYMINUS      reduce using rule 77 (empty -> .)
    UNARYPLUS       reduce using rule 77 (empty -> .)
    INC             reduce using rule 77 (empty -> .)
    DEC             reduce using rule 77 (empty -> .)
    NOT             reduce using rule 77 (empty -> .)
    BLTIN           reduce using rule 77 (empty -> .)
    $end            reduce using rule 77 (empty -> .)

    list                           shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> list .
    (2) list -> list . newline
    (3) list -> list . defn newline
    (4) list -> list . asgn newline
    (5) list -> list . stmt newline
    (6) list -> list . expr newline
    (7) list -> list . error newline
    (8) list -> list . COMMENT newline
    (78) newline -> . NEWLINE
    (68) defn -> . FUNC procname LPARENT formals RPARENT stmt
    (69) defn -> . PROC procname LPARENT formals RPARENT stmt
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (15) stmt -> . expr
    (16) stmt -> . RETURN expr
    (17) stmt -> . RETURN
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt end
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end
    (21) stmt -> . IF LPARENT cond RPARENT stmt end
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt end
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    error           shift and go to state 31
    COMMENT         shift and go to state 10
    NEWLINE         shift and go to state 12
    FUNC            shift and go to state 20
    PROC            shift and go to state 33
    VAR             shift and go to state 21
    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 25
    callfunc                       shift and go to state 26
    newline                        shift and go to state 17
    stmt                           shift and go to state 18
    asgn                           shift and go to state 13
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 22
    defn                           shift and go to state 23

state 2

    (1) list -> empty .

    error           reduce using rule 1 (list -> empty .)
    COMMENT         reduce using rule 1 (list -> empty .)
    NEWLINE         reduce using rule 1 (list -> empty .)
    FUNC            reduce using rule 1 (list -> empty .)
    PROC            reduce using rule 1 (list -> empty .)
    VAR             reduce using rule 1 (list -> empty .)
    RETURN          reduce using rule 1 (list -> empty .)
    PRINT           reduce using rule 1 (list -> empty .)
    WHILE           reduce using rule 1 (list -> empty .)
    FOR             reduce using rule 1 (list -> empty .)
    IF              reduce using rule 1 (list -> empty .)
    LBRACKET        reduce using rule 1 (list -> empty .)
    LPARENT         reduce using rule 1 (list -> empty .)
    FLOAT           reduce using rule 1 (list -> empty .)
    CONSTANT        reduce using rule 1 (list -> empty .)
    UNARYMINUS      reduce using rule 1 (list -> empty .)
    UNARYPLUS       reduce using rule 1 (list -> empty .)
    INC             reduce using rule 1 (list -> empty .)
    DEC             reduce using rule 1 (list -> empty .)
    NOT             reduce using rule 1 (list -> empty .)
    BLTIN           reduce using rule 1 (list -> empty .)
    $end            reduce using rule 1 (list -> empty .)


state 3

    (16) stmt -> RETURN . expr
    (17) stmt -> RETURN .
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

  ! shift/reduce conflict for LPARENT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for UNARYMINUS resolved as shift
  ! shift/reduce conflict for UNARYPLUS resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for BLTIN resolved as shift
    NEWLINE         reduce using rule 17 (stmt -> RETURN .)
    RBRACKET        reduce using rule 17 (stmt -> RETURN .)
    RETURN          reduce using rule 17 (stmt -> RETURN .)
    PRINT           reduce using rule 17 (stmt -> RETURN .)
    WHILE           reduce using rule 17 (stmt -> RETURN .)
    FOR             reduce using rule 17 (stmt -> RETURN .)
    IF              reduce using rule 17 (stmt -> RETURN .)
    LBRACKET        reduce using rule 17 (stmt -> RETURN .)
    ELSE            reduce using rule 17 (stmt -> RETURN .)
    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

  ! LPARENT         [ reduce using rule 17 (stmt -> RETURN .) ]
  ! FLOAT           [ reduce using rule 17 (stmt -> RETURN .) ]
  ! CONSTANT        [ reduce using rule 17 (stmt -> RETURN .) ]
  ! VAR             [ reduce using rule 17 (stmt -> RETURN .) ]
  ! UNARYMINUS      [ reduce using rule 17 (stmt -> RETURN .) ]
  ! UNARYPLUS       [ reduce using rule 17 (stmt -> RETURN .) ]
  ! INC             [ reduce using rule 17 (stmt -> RETURN .) ]
  ! DEC             [ reduce using rule 17 (stmt -> RETURN .) ]
  ! NOT             [ reduce using rule 17 (stmt -> RETURN .) ]
  ! BLTIN           [ reduce using rule 17 (stmt -> RETURN .) ]

    unaryop                        shift and go to state 16
    expr                           shift and go to state 37
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 4

    (23) stmt -> LBRACKET . stmtlist RBRACKET
    (27) stmtlist -> . empty
    (28) stmtlist -> . stmtlist newline
    (29) stmtlist -> . stmtlist stmt
    (77) empty -> .

    RBRACKET        reduce using rule 77 (empty -> .)
    NEWLINE         reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)
    PRINT           reduce using rule 77 (empty -> .)
    WHILE           reduce using rule 77 (empty -> .)
    FOR             reduce using rule 77 (empty -> .)
    IF              reduce using rule 77 (empty -> .)
    LBRACKET        reduce using rule 77 (empty -> .)
    LPARENT         reduce using rule 77 (empty -> .)
    FLOAT           reduce using rule 77 (empty -> .)
    CONSTANT        reduce using rule 77 (empty -> .)
    VAR             reduce using rule 77 (empty -> .)
    UNARYMINUS      reduce using rule 77 (empty -> .)
    UNARYPLUS       reduce using rule 77 (empty -> .)
    INC             reduce using rule 77 (empty -> .)
    DEC             reduce using rule 77 (empty -> .)
    NOT             reduce using rule 77 (empty -> .)
    BLTIN           reduce using rule 77 (empty -> .)

    empty                          shift and go to state 39
    stmtlist                       shift and go to state 38

state 5

    (19) stmt -> WHILE . LPARENT cond RPARENT stmt end

    LPARENT         shift and go to state 40


state 6

    (18) stmt -> PRINT . prlist
    (64) prlist -> . expr
    (65) prlist -> . STRING
    (66) prlist -> . prlist COMMA expr
    (67) prlist -> . prlist COMMA STRING
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    STRING          shift and go to state 41
    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 42
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    prlist                         shift and go to state 43
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 7

    (37) data -> CONSTANT .

    EXP             reduce using rule 37 (data -> CONSTANT .)
    PLUS            reduce using rule 37 (data -> CONSTANT .)
    MINUS           reduce using rule 37 (data -> CONSTANT .)
    TIMES           reduce using rule 37 (data -> CONSTANT .)
    DIVIDE          reduce using rule 37 (data -> CONSTANT .)
    MOD             reduce using rule 37 (data -> CONSTANT .)
    LT              reduce using rule 37 (data -> CONSTANT .)
    GT              reduce using rule 37 (data -> CONSTANT .)
    LE              reduce using rule 37 (data -> CONSTANT .)
    GE              reduce using rule 37 (data -> CONSTANT .)
    EQ              reduce using rule 37 (data -> CONSTANT .)
    NE              reduce using rule 37 (data -> CONSTANT .)
    OR              reduce using rule 37 (data -> CONSTANT .)
    AND             reduce using rule 37 (data -> CONSTANT .)
    NEWLINE         reduce using rule 37 (data -> CONSTANT .)
    RBRACKET        reduce using rule 37 (data -> CONSTANT .)
    RETURN          reduce using rule 37 (data -> CONSTANT .)
    PRINT           reduce using rule 37 (data -> CONSTANT .)
    WHILE           reduce using rule 37 (data -> CONSTANT .)
    FOR             reduce using rule 37 (data -> CONSTANT .)
    IF              reduce using rule 37 (data -> CONSTANT .)
    LBRACKET        reduce using rule 37 (data -> CONSTANT .)
    LPARENT         reduce using rule 37 (data -> CONSTANT .)
    FLOAT           reduce using rule 37 (data -> CONSTANT .)
    CONSTANT        reduce using rule 37 (data -> CONSTANT .)
    VAR             reduce using rule 37 (data -> CONSTANT .)
    UNARYMINUS      reduce using rule 37 (data -> CONSTANT .)
    UNARYPLUS       reduce using rule 37 (data -> CONSTANT .)
    INC             reduce using rule 37 (data -> CONSTANT .)
    DEC             reduce using rule 37 (data -> CONSTANT .)
    NOT             reduce using rule 37 (data -> CONSTANT .)
    BLTIN           reduce using rule 37 (data -> CONSTANT .)
    ELSE            reduce using rule 37 (data -> CONSTANT .)
    COMMA           reduce using rule 37 (data -> CONSTANT .)
    RPARENT         reduce using rule 37 (data -> CONSTANT .)
    SEMICOLON       reduce using rule 37 (data -> CONSTANT .)


state 8

    (42) unaryop -> DEC . VAR

    VAR             shift and go to state 44


state 9

    (47) binaryop -> logicop .

    EXP             reduce using rule 47 (binaryop -> logicop .)
    PLUS            reduce using rule 47 (binaryop -> logicop .)
    MINUS           reduce using rule 47 (binaryop -> logicop .)
    TIMES           reduce using rule 47 (binaryop -> logicop .)
    DIVIDE          reduce using rule 47 (binaryop -> logicop .)
    MOD             reduce using rule 47 (binaryop -> logicop .)
    LT              reduce using rule 47 (binaryop -> logicop .)
    GT              reduce using rule 47 (binaryop -> logicop .)
    LE              reduce using rule 47 (binaryop -> logicop .)
    GE              reduce using rule 47 (binaryop -> logicop .)
    EQ              reduce using rule 47 (binaryop -> logicop .)
    NE              reduce using rule 47 (binaryop -> logicop .)
    OR              reduce using rule 47 (binaryop -> logicop .)
    AND             reduce using rule 47 (binaryop -> logicop .)
    RPARENT         reduce using rule 47 (binaryop -> logicop .)
    COMMA           reduce using rule 47 (binaryop -> logicop .)
    NEWLINE         reduce using rule 47 (binaryop -> logicop .)
    RBRACKET        reduce using rule 47 (binaryop -> logicop .)
    RETURN          reduce using rule 47 (binaryop -> logicop .)
    PRINT           reduce using rule 47 (binaryop -> logicop .)
    WHILE           reduce using rule 47 (binaryop -> logicop .)
    FOR             reduce using rule 47 (binaryop -> logicop .)
    IF              reduce using rule 47 (binaryop -> logicop .)
    LBRACKET        reduce using rule 47 (binaryop -> logicop .)
    LPARENT         reduce using rule 47 (binaryop -> logicop .)
    FLOAT           reduce using rule 47 (binaryop -> logicop .)
    CONSTANT        reduce using rule 47 (binaryop -> logicop .)
    VAR             reduce using rule 47 (binaryop -> logicop .)
    UNARYMINUS      reduce using rule 47 (binaryop -> logicop .)
    UNARYPLUS       reduce using rule 47 (binaryop -> logicop .)
    INC             reduce using rule 47 (binaryop -> logicop .)
    DEC             reduce using rule 47 (binaryop -> logicop .)
    NOT             reduce using rule 47 (binaryop -> logicop .)
    BLTIN           reduce using rule 47 (binaryop -> logicop .)
    ELSE            reduce using rule 47 (binaryop -> logicop .)
    SEMICOLON       reduce using rule 47 (binaryop -> logicop .)


state 10

    (8) list -> list COMMENT . newline
    (78) newline -> . NEWLINE

    NEWLINE         shift and go to state 12

    newline                        shift and go to state 45

state 11

    (34) expr -> LPARENT . expr RPARENT
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 46
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 12

    (78) newline -> NEWLINE .

    error           reduce using rule 78 (newline -> NEWLINE .)
    COMMENT         reduce using rule 78 (newline -> NEWLINE .)
    NEWLINE         reduce using rule 78 (newline -> NEWLINE .)
    FUNC            reduce using rule 78 (newline -> NEWLINE .)
    PROC            reduce using rule 78 (newline -> NEWLINE .)
    VAR             reduce using rule 78 (newline -> NEWLINE .)
    RETURN          reduce using rule 78 (newline -> NEWLINE .)
    PRINT           reduce using rule 78 (newline -> NEWLINE .)
    WHILE           reduce using rule 78 (newline -> NEWLINE .)
    FOR             reduce using rule 78 (newline -> NEWLINE .)
    IF              reduce using rule 78 (newline -> NEWLINE .)
    LBRACKET        reduce using rule 78 (newline -> NEWLINE .)
    LPARENT         reduce using rule 78 (newline -> NEWLINE .)
    FLOAT           reduce using rule 78 (newline -> NEWLINE .)
    CONSTANT        reduce using rule 78 (newline -> NEWLINE .)
    UNARYMINUS      reduce using rule 78 (newline -> NEWLINE .)
    UNARYPLUS       reduce using rule 78 (newline -> NEWLINE .)
    INC             reduce using rule 78 (newline -> NEWLINE .)
    DEC             reduce using rule 78 (newline -> NEWLINE .)
    NOT             reduce using rule 78 (newline -> NEWLINE .)
    BLTIN           reduce using rule 78 (newline -> NEWLINE .)
    $end            reduce using rule 78 (newline -> NEWLINE .)
    RBRACKET        reduce using rule 78 (newline -> NEWLINE .)


state 13

    (4) list -> list asgn . newline
    (31) expr -> asgn .
    (78) newline -> . NEWLINE

  ! shift/reduce conflict for NEWLINE resolved as shift
    EXP             reduce using rule 31 (expr -> asgn .)
    PLUS            reduce using rule 31 (expr -> asgn .)
    MINUS           reduce using rule 31 (expr -> asgn .)
    TIMES           reduce using rule 31 (expr -> asgn .)
    DIVIDE          reduce using rule 31 (expr -> asgn .)
    MOD             reduce using rule 31 (expr -> asgn .)
    LT              reduce using rule 31 (expr -> asgn .)
    GT              reduce using rule 31 (expr -> asgn .)
    LE              reduce using rule 31 (expr -> asgn .)
    GE              reduce using rule 31 (expr -> asgn .)
    EQ              reduce using rule 31 (expr -> asgn .)
    NE              reduce using rule 31 (expr -> asgn .)
    OR              reduce using rule 31 (expr -> asgn .)
    AND             reduce using rule 31 (expr -> asgn .)
    NEWLINE         shift and go to state 12

  ! NEWLINE         [ reduce using rule 31 (expr -> asgn .) ]

    newline                        shift and go to state 47

state 14

    (40) unaryop -> UNARYPLUS . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 48
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 15

    (20) stmt -> FOR . LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end

    LPARENT         shift and go to state 49


state 16

    (32) expr -> unaryop .

    EXP             reduce using rule 32 (expr -> unaryop .)
    PLUS            reduce using rule 32 (expr -> unaryop .)
    MINUS           reduce using rule 32 (expr -> unaryop .)
    TIMES           reduce using rule 32 (expr -> unaryop .)
    DIVIDE          reduce using rule 32 (expr -> unaryop .)
    MOD             reduce using rule 32 (expr -> unaryop .)
    LT              reduce using rule 32 (expr -> unaryop .)
    GT              reduce using rule 32 (expr -> unaryop .)
    LE              reduce using rule 32 (expr -> unaryop .)
    GE              reduce using rule 32 (expr -> unaryop .)
    EQ              reduce using rule 32 (expr -> unaryop .)
    NE              reduce using rule 32 (expr -> unaryop .)
    OR              reduce using rule 32 (expr -> unaryop .)
    AND             reduce using rule 32 (expr -> unaryop .)
    NEWLINE         reduce using rule 32 (expr -> unaryop .)
    RBRACKET        reduce using rule 32 (expr -> unaryop .)
    RETURN          reduce using rule 32 (expr -> unaryop .)
    PRINT           reduce using rule 32 (expr -> unaryop .)
    WHILE           reduce using rule 32 (expr -> unaryop .)
    FOR             reduce using rule 32 (expr -> unaryop .)
    IF              reduce using rule 32 (expr -> unaryop .)
    LBRACKET        reduce using rule 32 (expr -> unaryop .)
    LPARENT         reduce using rule 32 (expr -> unaryop .)
    FLOAT           reduce using rule 32 (expr -> unaryop .)
    CONSTANT        reduce using rule 32 (expr -> unaryop .)
    VAR             reduce using rule 32 (expr -> unaryop .)
    UNARYMINUS      reduce using rule 32 (expr -> unaryop .)
    UNARYPLUS       reduce using rule 32 (expr -> unaryop .)
    INC             reduce using rule 32 (expr -> unaryop .)
    DEC             reduce using rule 32 (expr -> unaryop .)
    NOT             reduce using rule 32 (expr -> unaryop .)
    BLTIN           reduce using rule 32 (expr -> unaryop .)
    ELSE            reduce using rule 32 (expr -> unaryop .)
    COMMA           reduce using rule 32 (expr -> unaryop .)
    RPARENT         reduce using rule 32 (expr -> unaryop .)
    SEMICOLON       reduce using rule 32 (expr -> unaryop .)


state 17

    (2) list -> list newline .

    error           reduce using rule 2 (list -> list newline .)
    COMMENT         reduce using rule 2 (list -> list newline .)
    NEWLINE         reduce using rule 2 (list -> list newline .)
    FUNC            reduce using rule 2 (list -> list newline .)
    PROC            reduce using rule 2 (list -> list newline .)
    VAR             reduce using rule 2 (list -> list newline .)
    RETURN          reduce using rule 2 (list -> list newline .)
    PRINT           reduce using rule 2 (list -> list newline .)
    WHILE           reduce using rule 2 (list -> list newline .)
    FOR             reduce using rule 2 (list -> list newline .)
    IF              reduce using rule 2 (list -> list newline .)
    LBRACKET        reduce using rule 2 (list -> list newline .)
    LPARENT         reduce using rule 2 (list -> list newline .)
    FLOAT           reduce using rule 2 (list -> list newline .)
    CONSTANT        reduce using rule 2 (list -> list newline .)
    UNARYMINUS      reduce using rule 2 (list -> list newline .)
    UNARYPLUS       reduce using rule 2 (list -> list newline .)
    INC             reduce using rule 2 (list -> list newline .)
    DEC             reduce using rule 2 (list -> list newline .)
    NOT             reduce using rule 2 (list -> list newline .)
    BLTIN           reduce using rule 2 (list -> list newline .)
    $end            reduce using rule 2 (list -> list newline .)


state 18

    (5) list -> list stmt . newline
    (78) newline -> . NEWLINE

    NEWLINE         shift and go to state 12

    newline                        shift and go to state 50

state 19

    (62) callfunc -> BLTIN . begin LPARENT expr RPARENT
    (25) begin -> .

    LPARENT         reduce using rule 25 (begin -> .)

    begin                          shift and go to state 51

state 20

    (68) defn -> FUNC . procname LPARENT formals RPARENT stmt
    (70) procname -> . VAR

    VAR             shift and go to state 53

    procname                       shift and go to state 52

state 21

    (9) asgn -> VAR . ASSIGN expr
    (10) asgn -> VAR . ADDEQ expr
    (11) asgn -> VAR . SUBEQ expr
    (12) asgn -> VAR . MULEQ expr
    (13) asgn -> VAR . DIVEQ expr
    (14) asgn -> VAR . MODEQ expr
    (38) data -> VAR .
    (43) unaryop -> VAR . INC
    (44) unaryop -> VAR . DEC
    (63) callfunc -> VAR . begin LPARENT arglist RPARENT
    (25) begin -> .

    ASSIGN          shift and go to state 60
    ADDEQ           shift and go to state 58
    SUBEQ           shift and go to state 56
    MULEQ           shift and go to state 57
    DIVEQ           shift and go to state 61
    MODEQ           shift and go to state 55
    EXP             reduce using rule 38 (data -> VAR .)
    PLUS            reduce using rule 38 (data -> VAR .)
    MINUS           reduce using rule 38 (data -> VAR .)
    TIMES           reduce using rule 38 (data -> VAR .)
    DIVIDE          reduce using rule 38 (data -> VAR .)
    MOD             reduce using rule 38 (data -> VAR .)
    LT              reduce using rule 38 (data -> VAR .)
    GT              reduce using rule 38 (data -> VAR .)
    LE              reduce using rule 38 (data -> VAR .)
    GE              reduce using rule 38 (data -> VAR .)
    EQ              reduce using rule 38 (data -> VAR .)
    NE              reduce using rule 38 (data -> VAR .)
    OR              reduce using rule 38 (data -> VAR .)
    AND             reduce using rule 38 (data -> VAR .)
    NEWLINE         reduce using rule 38 (data -> VAR .)
    INC             shift and go to state 62
    DEC             shift and go to state 59
    LPARENT         reduce using rule 25 (begin -> .)

    begin                          shift and go to state 54

state 22

    (30) expr -> data .

    EXP             reduce using rule 30 (expr -> data .)
    PLUS            reduce using rule 30 (expr -> data .)
    MINUS           reduce using rule 30 (expr -> data .)
    TIMES           reduce using rule 30 (expr -> data .)
    DIVIDE          reduce using rule 30 (expr -> data .)
    MOD             reduce using rule 30 (expr -> data .)
    LT              reduce using rule 30 (expr -> data .)
    GT              reduce using rule 30 (expr -> data .)
    LE              reduce using rule 30 (expr -> data .)
    GE              reduce using rule 30 (expr -> data .)
    EQ              reduce using rule 30 (expr -> data .)
    NE              reduce using rule 30 (expr -> data .)
    OR              reduce using rule 30 (expr -> data .)
    AND             reduce using rule 30 (expr -> data .)
    NEWLINE         reduce using rule 30 (expr -> data .)
    RBRACKET        reduce using rule 30 (expr -> data .)
    RETURN          reduce using rule 30 (expr -> data .)
    PRINT           reduce using rule 30 (expr -> data .)
    WHILE           reduce using rule 30 (expr -> data .)
    FOR             reduce using rule 30 (expr -> data .)
    IF              reduce using rule 30 (expr -> data .)
    LBRACKET        reduce using rule 30 (expr -> data .)
    LPARENT         reduce using rule 30 (expr -> data .)
    FLOAT           reduce using rule 30 (expr -> data .)
    CONSTANT        reduce using rule 30 (expr -> data .)
    VAR             reduce using rule 30 (expr -> data .)
    UNARYMINUS      reduce using rule 30 (expr -> data .)
    UNARYPLUS       reduce using rule 30 (expr -> data .)
    INC             reduce using rule 30 (expr -> data .)
    DEC             reduce using rule 30 (expr -> data .)
    NOT             reduce using rule 30 (expr -> data .)
    BLTIN           reduce using rule 30 (expr -> data .)
    ELSE            reduce using rule 30 (expr -> data .)
    COMMA           reduce using rule 30 (expr -> data .)
    RPARENT         reduce using rule 30 (expr -> data .)
    SEMICOLON       reduce using rule 30 (expr -> data .)


state 23

    (3) list -> list defn . newline
    (78) newline -> . NEWLINE

    NEWLINE         shift and go to state 12

    newline                        shift and go to state 63

state 24

    (21) stmt -> IF . LPARENT cond RPARENT stmt end
    (22) stmt -> IF . LPARENT cond RPARENT stmt ELSE stmt end

    LPARENT         shift and go to state 64


state 25

    (6) list -> list expr . newline
    (15) stmt -> expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr
    (78) newline -> . NEWLINE

  ! shift/reduce conflict for NEWLINE resolved as shift
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65
    NEWLINE         shift and go to state 12

  ! NEWLINE         [ reduce using rule 15 (stmt -> expr .) ]

    newline                        shift and go to state 69

state 26

    (35) expr -> callfunc .

    EXP             reduce using rule 35 (expr -> callfunc .)
    PLUS            reduce using rule 35 (expr -> callfunc .)
    MINUS           reduce using rule 35 (expr -> callfunc .)
    TIMES           reduce using rule 35 (expr -> callfunc .)
    DIVIDE          reduce using rule 35 (expr -> callfunc .)
    MOD             reduce using rule 35 (expr -> callfunc .)
    LT              reduce using rule 35 (expr -> callfunc .)
    GT              reduce using rule 35 (expr -> callfunc .)
    LE              reduce using rule 35 (expr -> callfunc .)
    GE              reduce using rule 35 (expr -> callfunc .)
    EQ              reduce using rule 35 (expr -> callfunc .)
    NE              reduce using rule 35 (expr -> callfunc .)
    OR              reduce using rule 35 (expr -> callfunc .)
    AND             reduce using rule 35 (expr -> callfunc .)
    NEWLINE         reduce using rule 35 (expr -> callfunc .)
    RBRACKET        reduce using rule 35 (expr -> callfunc .)
    RETURN          reduce using rule 35 (expr -> callfunc .)
    PRINT           reduce using rule 35 (expr -> callfunc .)
    WHILE           reduce using rule 35 (expr -> callfunc .)
    FOR             reduce using rule 35 (expr -> callfunc .)
    IF              reduce using rule 35 (expr -> callfunc .)
    LBRACKET        reduce using rule 35 (expr -> callfunc .)
    LPARENT         reduce using rule 35 (expr -> callfunc .)
    FLOAT           reduce using rule 35 (expr -> callfunc .)
    CONSTANT        reduce using rule 35 (expr -> callfunc .)
    VAR             reduce using rule 35 (expr -> callfunc .)
    UNARYMINUS      reduce using rule 35 (expr -> callfunc .)
    UNARYPLUS       reduce using rule 35 (expr -> callfunc .)
    INC             reduce using rule 35 (expr -> callfunc .)
    DEC             reduce using rule 35 (expr -> callfunc .)
    NOT             reduce using rule 35 (expr -> callfunc .)
    BLTIN           reduce using rule 35 (expr -> callfunc .)
    ELSE            reduce using rule 35 (expr -> callfunc .)
    COMMA           reduce using rule 35 (expr -> callfunc .)
    RPARENT         reduce using rule 35 (expr -> callfunc .)
    SEMICOLON       reduce using rule 35 (expr -> callfunc .)


state 27

    (36) data -> FLOAT .

    EXP             reduce using rule 36 (data -> FLOAT .)
    PLUS            reduce using rule 36 (data -> FLOAT .)
    MINUS           reduce using rule 36 (data -> FLOAT .)
    TIMES           reduce using rule 36 (data -> FLOAT .)
    DIVIDE          reduce using rule 36 (data -> FLOAT .)
    MOD             reduce using rule 36 (data -> FLOAT .)
    LT              reduce using rule 36 (data -> FLOAT .)
    GT              reduce using rule 36 (data -> FLOAT .)
    LE              reduce using rule 36 (data -> FLOAT .)
    GE              reduce using rule 36 (data -> FLOAT .)
    EQ              reduce using rule 36 (data -> FLOAT .)
    NE              reduce using rule 36 (data -> FLOAT .)
    OR              reduce using rule 36 (data -> FLOAT .)
    AND             reduce using rule 36 (data -> FLOAT .)
    NEWLINE         reduce using rule 36 (data -> FLOAT .)
    RBRACKET        reduce using rule 36 (data -> FLOAT .)
    RETURN          reduce using rule 36 (data -> FLOAT .)
    PRINT           reduce using rule 36 (data -> FLOAT .)
    WHILE           reduce using rule 36 (data -> FLOAT .)
    FOR             reduce using rule 36 (data -> FLOAT .)
    IF              reduce using rule 36 (data -> FLOAT .)
    LBRACKET        reduce using rule 36 (data -> FLOAT .)
    LPARENT         reduce using rule 36 (data -> FLOAT .)
    FLOAT           reduce using rule 36 (data -> FLOAT .)
    CONSTANT        reduce using rule 36 (data -> FLOAT .)
    VAR             reduce using rule 36 (data -> FLOAT .)
    UNARYMINUS      reduce using rule 36 (data -> FLOAT .)
    UNARYPLUS       reduce using rule 36 (data -> FLOAT .)
    INC             reduce using rule 36 (data -> FLOAT .)
    DEC             reduce using rule 36 (data -> FLOAT .)
    NOT             reduce using rule 36 (data -> FLOAT .)
    BLTIN           reduce using rule 36 (data -> FLOAT .)
    ELSE            reduce using rule 36 (data -> FLOAT .)
    COMMA           reduce using rule 36 (data -> FLOAT .)
    RPARENT         reduce using rule 36 (data -> FLOAT .)
    SEMICOLON       reduce using rule 36 (data -> FLOAT .)


state 28

    (39) unaryop -> UNARYMINUS . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 80
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 29

    (46) binaryop -> mathop .

    EXP             reduce using rule 46 (binaryop -> mathop .)
    PLUS            reduce using rule 46 (binaryop -> mathop .)
    MINUS           reduce using rule 46 (binaryop -> mathop .)
    TIMES           reduce using rule 46 (binaryop -> mathop .)
    DIVIDE          reduce using rule 46 (binaryop -> mathop .)
    MOD             reduce using rule 46 (binaryop -> mathop .)
    LT              reduce using rule 46 (binaryop -> mathop .)
    GT              reduce using rule 46 (binaryop -> mathop .)
    LE              reduce using rule 46 (binaryop -> mathop .)
    GE              reduce using rule 46 (binaryop -> mathop .)
    EQ              reduce using rule 46 (binaryop -> mathop .)
    NE              reduce using rule 46 (binaryop -> mathop .)
    OR              reduce using rule 46 (binaryop -> mathop .)
    AND             reduce using rule 46 (binaryop -> mathop .)
    RPARENT         reduce using rule 46 (binaryop -> mathop .)
    COMMA           reduce using rule 46 (binaryop -> mathop .)
    NEWLINE         reduce using rule 46 (binaryop -> mathop .)
    RBRACKET        reduce using rule 46 (binaryop -> mathop .)
    RETURN          reduce using rule 46 (binaryop -> mathop .)
    PRINT           reduce using rule 46 (binaryop -> mathop .)
    WHILE           reduce using rule 46 (binaryop -> mathop .)
    FOR             reduce using rule 46 (binaryop -> mathop .)
    IF              reduce using rule 46 (binaryop -> mathop .)
    LBRACKET        reduce using rule 46 (binaryop -> mathop .)
    LPARENT         reduce using rule 46 (binaryop -> mathop .)
    FLOAT           reduce using rule 46 (binaryop -> mathop .)
    CONSTANT        reduce using rule 46 (binaryop -> mathop .)
    VAR             reduce using rule 46 (binaryop -> mathop .)
    UNARYMINUS      reduce using rule 46 (binaryop -> mathop .)
    UNARYPLUS       reduce using rule 46 (binaryop -> mathop .)
    INC             reduce using rule 46 (binaryop -> mathop .)
    DEC             reduce using rule 46 (binaryop -> mathop .)
    NOT             reduce using rule 46 (binaryop -> mathop .)
    BLTIN           reduce using rule 46 (binaryop -> mathop .)
    ELSE            reduce using rule 46 (binaryop -> mathop .)
    SEMICOLON       reduce using rule 46 (binaryop -> mathop .)


state 30

    (33) expr -> binaryop .

    EXP             reduce using rule 33 (expr -> binaryop .)
    PLUS            reduce using rule 33 (expr -> binaryop .)
    MINUS           reduce using rule 33 (expr -> binaryop .)
    TIMES           reduce using rule 33 (expr -> binaryop .)
    DIVIDE          reduce using rule 33 (expr -> binaryop .)
    MOD             reduce using rule 33 (expr -> binaryop .)
    LT              reduce using rule 33 (expr -> binaryop .)
    GT              reduce using rule 33 (expr -> binaryop .)
    LE              reduce using rule 33 (expr -> binaryop .)
    GE              reduce using rule 33 (expr -> binaryop .)
    EQ              reduce using rule 33 (expr -> binaryop .)
    NE              reduce using rule 33 (expr -> binaryop .)
    OR              reduce using rule 33 (expr -> binaryop .)
    AND             reduce using rule 33 (expr -> binaryop .)
    NEWLINE         reduce using rule 33 (expr -> binaryop .)
    RBRACKET        reduce using rule 33 (expr -> binaryop .)
    RETURN          reduce using rule 33 (expr -> binaryop .)
    PRINT           reduce using rule 33 (expr -> binaryop .)
    WHILE           reduce using rule 33 (expr -> binaryop .)
    FOR             reduce using rule 33 (expr -> binaryop .)
    IF              reduce using rule 33 (expr -> binaryop .)
    LBRACKET        reduce using rule 33 (expr -> binaryop .)
    LPARENT         reduce using rule 33 (expr -> binaryop .)
    FLOAT           reduce using rule 33 (expr -> binaryop .)
    CONSTANT        reduce using rule 33 (expr -> binaryop .)
    VAR             reduce using rule 33 (expr -> binaryop .)
    UNARYMINUS      reduce using rule 33 (expr -> binaryop .)
    UNARYPLUS       reduce using rule 33 (expr -> binaryop .)
    INC             reduce using rule 33 (expr -> binaryop .)
    DEC             reduce using rule 33 (expr -> binaryop .)
    NOT             reduce using rule 33 (expr -> binaryop .)
    BLTIN           reduce using rule 33 (expr -> binaryop .)
    ELSE            reduce using rule 33 (expr -> binaryop .)
    COMMA           reduce using rule 33 (expr -> binaryop .)
    RPARENT         reduce using rule 33 (expr -> binaryop .)
    SEMICOLON       reduce using rule 33 (expr -> binaryop .)


state 31

    (7) list -> list error . newline
    (78) newline -> . NEWLINE

    NEWLINE         shift and go to state 12

    newline                        shift and go to state 81

state 32

    (45) unaryop -> NOT . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 82
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 33

    (69) defn -> PROC . procname LPARENT formals RPARENT stmt
    (70) procname -> . VAR

    VAR             shift and go to state 53

    procname                       shift and go to state 83

state 34

    (41) unaryop -> INC . VAR

    VAR             shift and go to state 84


state 35

    (31) expr -> asgn .

    EXP             reduce using rule 31 (expr -> asgn .)
    PLUS            reduce using rule 31 (expr -> asgn .)
    MINUS           reduce using rule 31 (expr -> asgn .)
    TIMES           reduce using rule 31 (expr -> asgn .)
    DIVIDE          reduce using rule 31 (expr -> asgn .)
    MOD             reduce using rule 31 (expr -> asgn .)
    LT              reduce using rule 31 (expr -> asgn .)
    GT              reduce using rule 31 (expr -> asgn .)
    LE              reduce using rule 31 (expr -> asgn .)
    GE              reduce using rule 31 (expr -> asgn .)
    EQ              reduce using rule 31 (expr -> asgn .)
    NE              reduce using rule 31 (expr -> asgn .)
    OR              reduce using rule 31 (expr -> asgn .)
    AND             reduce using rule 31 (expr -> asgn .)
    NEWLINE         reduce using rule 31 (expr -> asgn .)
    RBRACKET        reduce using rule 31 (expr -> asgn .)
    RETURN          reduce using rule 31 (expr -> asgn .)
    PRINT           reduce using rule 31 (expr -> asgn .)
    WHILE           reduce using rule 31 (expr -> asgn .)
    FOR             reduce using rule 31 (expr -> asgn .)
    IF              reduce using rule 31 (expr -> asgn .)
    LBRACKET        reduce using rule 31 (expr -> asgn .)
    LPARENT         reduce using rule 31 (expr -> asgn .)
    FLOAT           reduce using rule 31 (expr -> asgn .)
    CONSTANT        reduce using rule 31 (expr -> asgn .)
    VAR             reduce using rule 31 (expr -> asgn .)
    UNARYMINUS      reduce using rule 31 (expr -> asgn .)
    UNARYPLUS       reduce using rule 31 (expr -> asgn .)
    INC             reduce using rule 31 (expr -> asgn .)
    DEC             reduce using rule 31 (expr -> asgn .)
    NOT             reduce using rule 31 (expr -> asgn .)
    BLTIN           reduce using rule 31 (expr -> asgn .)
    ELSE            reduce using rule 31 (expr -> asgn .)
    COMMA           reduce using rule 31 (expr -> asgn .)
    RPARENT         reduce using rule 31 (expr -> asgn .)
    SEMICOLON       reduce using rule 31 (expr -> asgn .)


state 36

    (38) data -> VAR .
    (9) asgn -> VAR . ASSIGN expr
    (10) asgn -> VAR . ADDEQ expr
    (11) asgn -> VAR . SUBEQ expr
    (12) asgn -> VAR . MULEQ expr
    (13) asgn -> VAR . DIVEQ expr
    (14) asgn -> VAR . MODEQ expr
    (43) unaryop -> VAR . INC
    (44) unaryop -> VAR . DEC
    (63) callfunc -> VAR . begin LPARENT arglist RPARENT
    (25) begin -> .

  ! reduce/reduce conflict for LPARENT resolved using rule 25 (begin -> .)
    EXP             reduce using rule 38 (data -> VAR .)
    PLUS            reduce using rule 38 (data -> VAR .)
    MINUS           reduce using rule 38 (data -> VAR .)
    TIMES           reduce using rule 38 (data -> VAR .)
    DIVIDE          reduce using rule 38 (data -> VAR .)
    MOD             reduce using rule 38 (data -> VAR .)
    LT              reduce using rule 38 (data -> VAR .)
    GT              reduce using rule 38 (data -> VAR .)
    LE              reduce using rule 38 (data -> VAR .)
    GE              reduce using rule 38 (data -> VAR .)
    EQ              reduce using rule 38 (data -> VAR .)
    NE              reduce using rule 38 (data -> VAR .)
    OR              reduce using rule 38 (data -> VAR .)
    AND             reduce using rule 38 (data -> VAR .)
    NEWLINE         reduce using rule 38 (data -> VAR .)
    RBRACKET        reduce using rule 38 (data -> VAR .)
    RETURN          reduce using rule 38 (data -> VAR .)
    PRINT           reduce using rule 38 (data -> VAR .)
    WHILE           reduce using rule 38 (data -> VAR .)
    FOR             reduce using rule 38 (data -> VAR .)
    IF              reduce using rule 38 (data -> VAR .)
    LBRACKET        reduce using rule 38 (data -> VAR .)
    FLOAT           reduce using rule 38 (data -> VAR .)
    CONSTANT        reduce using rule 38 (data -> VAR .)
    VAR             reduce using rule 38 (data -> VAR .)
    UNARYMINUS      reduce using rule 38 (data -> VAR .)
    UNARYPLUS       reduce using rule 38 (data -> VAR .)
    INC             reduce using rule 38 (data -> VAR .)
    DEC             reduce using rule 38 (data -> VAR .)
    NOT             reduce using rule 38 (data -> VAR .)
    BLTIN           reduce using rule 38 (data -> VAR .)
    ELSE            reduce using rule 38 (data -> VAR .)
    COMMA           reduce using rule 38 (data -> VAR .)
    RPARENT         reduce using rule 38 (data -> VAR .)
    SEMICOLON       reduce using rule 38 (data -> VAR .)
    ASSIGN          shift and go to state 60
    ADDEQ           shift and go to state 58
    SUBEQ           shift and go to state 56
    MULEQ           shift and go to state 57
    DIVEQ           shift and go to state 61
    MODEQ           shift and go to state 55
    LPARENT         reduce using rule 25 (begin -> .)

  ! LPARENT         [ reduce using rule 38 (data -> VAR .) ]
  ! INC             [ shift and go to state 62 ]
  ! DEC             [ shift and go to state 59 ]

    begin                          shift and go to state 54

state 37

    (16) stmt -> RETURN expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    NEWLINE         reduce using rule 16 (stmt -> RETURN expr .)
    RBRACKET        reduce using rule 16 (stmt -> RETURN expr .)
    RETURN          reduce using rule 16 (stmt -> RETURN expr .)
    PRINT           reduce using rule 16 (stmt -> RETURN expr .)
    WHILE           reduce using rule 16 (stmt -> RETURN expr .)
    FOR             reduce using rule 16 (stmt -> RETURN expr .)
    IF              reduce using rule 16 (stmt -> RETURN expr .)
    LBRACKET        reduce using rule 16 (stmt -> RETURN expr .)
    LPARENT         reduce using rule 16 (stmt -> RETURN expr .)
    FLOAT           reduce using rule 16 (stmt -> RETURN expr .)
    CONSTANT        reduce using rule 16 (stmt -> RETURN expr .)
    VAR             reduce using rule 16 (stmt -> RETURN expr .)
    UNARYMINUS      reduce using rule 16 (stmt -> RETURN expr .)
    UNARYPLUS       reduce using rule 16 (stmt -> RETURN expr .)
    INC             reduce using rule 16 (stmt -> RETURN expr .)
    DEC             reduce using rule 16 (stmt -> RETURN expr .)
    NOT             reduce using rule 16 (stmt -> RETURN expr .)
    BLTIN           reduce using rule 16 (stmt -> RETURN expr .)
    ELSE            reduce using rule 16 (stmt -> RETURN expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65


state 38

    (23) stmt -> LBRACKET stmtlist . RBRACKET
    (28) stmtlist -> stmtlist . newline
    (29) stmtlist -> stmtlist . stmt
    (78) newline -> . NEWLINE
    (15) stmt -> . expr
    (16) stmt -> . RETURN expr
    (17) stmt -> . RETURN
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt end
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end
    (21) stmt -> . IF LPARENT cond RPARENT stmt end
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt end
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    RBRACKET        shift and go to state 88
    NEWLINE         shift and go to state 12
    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 87
    callfunc                       shift and go to state 26
    newline                        shift and go to state 85
    stmt                           shift and go to state 86
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 39

    (27) stmtlist -> empty .

    RBRACKET        reduce using rule 27 (stmtlist -> empty .)
    NEWLINE         reduce using rule 27 (stmtlist -> empty .)
    RETURN          reduce using rule 27 (stmtlist -> empty .)
    PRINT           reduce using rule 27 (stmtlist -> empty .)
    WHILE           reduce using rule 27 (stmtlist -> empty .)
    FOR             reduce using rule 27 (stmtlist -> empty .)
    IF              reduce using rule 27 (stmtlist -> empty .)
    LBRACKET        reduce using rule 27 (stmtlist -> empty .)
    LPARENT         reduce using rule 27 (stmtlist -> empty .)
    FLOAT           reduce using rule 27 (stmtlist -> empty .)
    CONSTANT        reduce using rule 27 (stmtlist -> empty .)
    VAR             reduce using rule 27 (stmtlist -> empty .)
    UNARYMINUS      reduce using rule 27 (stmtlist -> empty .)
    UNARYPLUS       reduce using rule 27 (stmtlist -> empty .)
    INC             reduce using rule 27 (stmtlist -> empty .)
    DEC             reduce using rule 27 (stmtlist -> empty .)
    NOT             reduce using rule 27 (stmtlist -> empty .)
    BLTIN           reduce using rule 27 (stmtlist -> empty .)


state 40

    (19) stmt -> WHILE LPARENT . cond RPARENT stmt end
    (26) cond -> . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 90
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    cond                           shift and go to state 89
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 41

    (65) prlist -> STRING .

    COMMA           reduce using rule 65 (prlist -> STRING .)
    NEWLINE         reduce using rule 65 (prlist -> STRING .)
    RBRACKET        reduce using rule 65 (prlist -> STRING .)
    RETURN          reduce using rule 65 (prlist -> STRING .)
    PRINT           reduce using rule 65 (prlist -> STRING .)
    WHILE           reduce using rule 65 (prlist -> STRING .)
    FOR             reduce using rule 65 (prlist -> STRING .)
    IF              reduce using rule 65 (prlist -> STRING .)
    LBRACKET        reduce using rule 65 (prlist -> STRING .)
    LPARENT         reduce using rule 65 (prlist -> STRING .)
    FLOAT           reduce using rule 65 (prlist -> STRING .)
    CONSTANT        reduce using rule 65 (prlist -> STRING .)
    VAR             reduce using rule 65 (prlist -> STRING .)
    UNARYMINUS      reduce using rule 65 (prlist -> STRING .)
    UNARYPLUS       reduce using rule 65 (prlist -> STRING .)
    INC             reduce using rule 65 (prlist -> STRING .)
    DEC             reduce using rule 65 (prlist -> STRING .)
    NOT             reduce using rule 65 (prlist -> STRING .)
    BLTIN           reduce using rule 65 (prlist -> STRING .)
    ELSE            reduce using rule 65 (prlist -> STRING .)


state 42

    (64) prlist -> expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    COMMA           reduce using rule 64 (prlist -> expr .)
    NEWLINE         reduce using rule 64 (prlist -> expr .)
    RBRACKET        reduce using rule 64 (prlist -> expr .)
    RETURN          reduce using rule 64 (prlist -> expr .)
    PRINT           reduce using rule 64 (prlist -> expr .)
    WHILE           reduce using rule 64 (prlist -> expr .)
    FOR             reduce using rule 64 (prlist -> expr .)
    IF              reduce using rule 64 (prlist -> expr .)
    LBRACKET        reduce using rule 64 (prlist -> expr .)
    LPARENT         reduce using rule 64 (prlist -> expr .)
    FLOAT           reduce using rule 64 (prlist -> expr .)
    CONSTANT        reduce using rule 64 (prlist -> expr .)
    VAR             reduce using rule 64 (prlist -> expr .)
    UNARYMINUS      reduce using rule 64 (prlist -> expr .)
    UNARYPLUS       reduce using rule 64 (prlist -> expr .)
    INC             reduce using rule 64 (prlist -> expr .)
    DEC             reduce using rule 64 (prlist -> expr .)
    NOT             reduce using rule 64 (prlist -> expr .)
    BLTIN           reduce using rule 64 (prlist -> expr .)
    ELSE            reduce using rule 64 (prlist -> expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65


state 43

    (18) stmt -> PRINT prlist .
    (66) prlist -> prlist . COMMA expr
    (67) prlist -> prlist . COMMA STRING

    NEWLINE         reduce using rule 18 (stmt -> PRINT prlist .)
    RBRACKET        reduce using rule 18 (stmt -> PRINT prlist .)
    RETURN          reduce using rule 18 (stmt -> PRINT prlist .)
    PRINT           reduce using rule 18 (stmt -> PRINT prlist .)
    WHILE           reduce using rule 18 (stmt -> PRINT prlist .)
    FOR             reduce using rule 18 (stmt -> PRINT prlist .)
    IF              reduce using rule 18 (stmt -> PRINT prlist .)
    LBRACKET        reduce using rule 18 (stmt -> PRINT prlist .)
    LPARENT         reduce using rule 18 (stmt -> PRINT prlist .)
    FLOAT           reduce using rule 18 (stmt -> PRINT prlist .)
    CONSTANT        reduce using rule 18 (stmt -> PRINT prlist .)
    VAR             reduce using rule 18 (stmt -> PRINT prlist .)
    UNARYMINUS      reduce using rule 18 (stmt -> PRINT prlist .)
    UNARYPLUS       reduce using rule 18 (stmt -> PRINT prlist .)
    INC             reduce using rule 18 (stmt -> PRINT prlist .)
    DEC             reduce using rule 18 (stmt -> PRINT prlist .)
    NOT             reduce using rule 18 (stmt -> PRINT prlist .)
    BLTIN           reduce using rule 18 (stmt -> PRINT prlist .)
    ELSE            reduce using rule 18 (stmt -> PRINT prlist .)
    COMMA           shift and go to state 91


state 44

    (42) unaryop -> DEC VAR .

    EXP             reduce using rule 42 (unaryop -> DEC VAR .)
    PLUS            reduce using rule 42 (unaryop -> DEC VAR .)
    MINUS           reduce using rule 42 (unaryop -> DEC VAR .)
    TIMES           reduce using rule 42 (unaryop -> DEC VAR .)
    DIVIDE          reduce using rule 42 (unaryop -> DEC VAR .)
    MOD             reduce using rule 42 (unaryop -> DEC VAR .)
    LT              reduce using rule 42 (unaryop -> DEC VAR .)
    GT              reduce using rule 42 (unaryop -> DEC VAR .)
    LE              reduce using rule 42 (unaryop -> DEC VAR .)
    GE              reduce using rule 42 (unaryop -> DEC VAR .)
    EQ              reduce using rule 42 (unaryop -> DEC VAR .)
    NE              reduce using rule 42 (unaryop -> DEC VAR .)
    OR              reduce using rule 42 (unaryop -> DEC VAR .)
    AND             reduce using rule 42 (unaryop -> DEC VAR .)
    NEWLINE         reduce using rule 42 (unaryop -> DEC VAR .)
    RBRACKET        reduce using rule 42 (unaryop -> DEC VAR .)
    RETURN          reduce using rule 42 (unaryop -> DEC VAR .)
    PRINT           reduce using rule 42 (unaryop -> DEC VAR .)
    WHILE           reduce using rule 42 (unaryop -> DEC VAR .)
    FOR             reduce using rule 42 (unaryop -> DEC VAR .)
    IF              reduce using rule 42 (unaryop -> DEC VAR .)
    LBRACKET        reduce using rule 42 (unaryop -> DEC VAR .)
    LPARENT         reduce using rule 42 (unaryop -> DEC VAR .)
    FLOAT           reduce using rule 42 (unaryop -> DEC VAR .)
    CONSTANT        reduce using rule 42 (unaryop -> DEC VAR .)
    VAR             reduce using rule 42 (unaryop -> DEC VAR .)
    UNARYMINUS      reduce using rule 42 (unaryop -> DEC VAR .)
    UNARYPLUS       reduce using rule 42 (unaryop -> DEC VAR .)
    INC             reduce using rule 42 (unaryop -> DEC VAR .)
    DEC             reduce using rule 42 (unaryop -> DEC VAR .)
    NOT             reduce using rule 42 (unaryop -> DEC VAR .)
    BLTIN           reduce using rule 42 (unaryop -> DEC VAR .)
    ELSE            reduce using rule 42 (unaryop -> DEC VAR .)
    COMMA           reduce using rule 42 (unaryop -> DEC VAR .)
    RPARENT         reduce using rule 42 (unaryop -> DEC VAR .)
    SEMICOLON       reduce using rule 42 (unaryop -> DEC VAR .)


state 45

    (8) list -> list COMMENT newline .

    error           reduce using rule 8 (list -> list COMMENT newline .)
    COMMENT         reduce using rule 8 (list -> list COMMENT newline .)
    NEWLINE         reduce using rule 8 (list -> list COMMENT newline .)
    FUNC            reduce using rule 8 (list -> list COMMENT newline .)
    PROC            reduce using rule 8 (list -> list COMMENT newline .)
    VAR             reduce using rule 8 (list -> list COMMENT newline .)
    RETURN          reduce using rule 8 (list -> list COMMENT newline .)
    PRINT           reduce using rule 8 (list -> list COMMENT newline .)
    WHILE           reduce using rule 8 (list -> list COMMENT newline .)
    FOR             reduce using rule 8 (list -> list COMMENT newline .)
    IF              reduce using rule 8 (list -> list COMMENT newline .)
    LBRACKET        reduce using rule 8 (list -> list COMMENT newline .)
    LPARENT         reduce using rule 8 (list -> list COMMENT newline .)
    FLOAT           reduce using rule 8 (list -> list COMMENT newline .)
    CONSTANT        reduce using rule 8 (list -> list COMMENT newline .)
    UNARYMINUS      reduce using rule 8 (list -> list COMMENT newline .)
    UNARYPLUS       reduce using rule 8 (list -> list COMMENT newline .)
    INC             reduce using rule 8 (list -> list COMMENT newline .)
    DEC             reduce using rule 8 (list -> list COMMENT newline .)
    NOT             reduce using rule 8 (list -> list COMMENT newline .)
    BLTIN           reduce using rule 8 (list -> list COMMENT newline .)
    $end            reduce using rule 8 (list -> list COMMENT newline .)


state 46

    (34) expr -> LPARENT expr . RPARENT
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    RPARENT         shift and go to state 92
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65


state 47

    (4) list -> list asgn newline .

    error           reduce using rule 4 (list -> list asgn newline .)
    COMMENT         reduce using rule 4 (list -> list asgn newline .)
    NEWLINE         reduce using rule 4 (list -> list asgn newline .)
    FUNC            reduce using rule 4 (list -> list asgn newline .)
    PROC            reduce using rule 4 (list -> list asgn newline .)
    VAR             reduce using rule 4 (list -> list asgn newline .)
    RETURN          reduce using rule 4 (list -> list asgn newline .)
    PRINT           reduce using rule 4 (list -> list asgn newline .)
    WHILE           reduce using rule 4 (list -> list asgn newline .)
    FOR             reduce using rule 4 (list -> list asgn newline .)
    IF              reduce using rule 4 (list -> list asgn newline .)
    LBRACKET        reduce using rule 4 (list -> list asgn newline .)
    LPARENT         reduce using rule 4 (list -> list asgn newline .)
    FLOAT           reduce using rule 4 (list -> list asgn newline .)
    CONSTANT        reduce using rule 4 (list -> list asgn newline .)
    UNARYMINUS      reduce using rule 4 (list -> list asgn newline .)
    UNARYPLUS       reduce using rule 4 (list -> list asgn newline .)
    INC             reduce using rule 4 (list -> list asgn newline .)
    DEC             reduce using rule 4 (list -> list asgn newline .)
    NOT             reduce using rule 4 (list -> list asgn newline .)
    BLTIN           reduce using rule 4 (list -> list asgn newline .)
    $end            reduce using rule 4 (list -> list asgn newline .)


state 48

    (40) unaryop -> UNARYPLUS expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

  ! shift/reduce conflict for EXP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
    NEWLINE         reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    RBRACKET        reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    RETURN          reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    PRINT           reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    WHILE           reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    FOR             reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    IF              reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    LBRACKET        reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    LPARENT         reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    FLOAT           reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    CONSTANT        reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    VAR             reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    UNARYMINUS      reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    UNARYPLUS       reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    INC             reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    DEC             reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    NOT             reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    BLTIN           reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    ELSE            reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    COMMA           reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    RPARENT         reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    SEMICOLON       reduce using rule 40 (unaryop -> UNARYPLUS expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65

  ! EXP             [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]
  ! PLUS            [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]
  ! MINUS           [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]
  ! TIMES           [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]
  ! DIVIDE          [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]
  ! MOD             [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]
  ! LT              [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]
  ! GT              [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]
  ! LE              [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]
  ! GE              [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]
  ! EQ              [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]
  ! NE              [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]
  ! OR              [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]
  ! AND             [ reduce using rule 40 (unaryop -> UNARYPLUS expr .) ]


state 49

    (20) stmt -> FOR LPARENT . cond SEMICOLON cond SEMICOLON cond RPARENT stmt end
    (26) cond -> . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 90
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    cond                           shift and go to state 93
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 50

    (5) list -> list stmt newline .

    error           reduce using rule 5 (list -> list stmt newline .)
    COMMENT         reduce using rule 5 (list -> list stmt newline .)
    NEWLINE         reduce using rule 5 (list -> list stmt newline .)
    FUNC            reduce using rule 5 (list -> list stmt newline .)
    PROC            reduce using rule 5 (list -> list stmt newline .)
    VAR             reduce using rule 5 (list -> list stmt newline .)
    RETURN          reduce using rule 5 (list -> list stmt newline .)
    PRINT           reduce using rule 5 (list -> list stmt newline .)
    WHILE           reduce using rule 5 (list -> list stmt newline .)
    FOR             reduce using rule 5 (list -> list stmt newline .)
    IF              reduce using rule 5 (list -> list stmt newline .)
    LBRACKET        reduce using rule 5 (list -> list stmt newline .)
    LPARENT         reduce using rule 5 (list -> list stmt newline .)
    FLOAT           reduce using rule 5 (list -> list stmt newline .)
    CONSTANT        reduce using rule 5 (list -> list stmt newline .)
    UNARYMINUS      reduce using rule 5 (list -> list stmt newline .)
    UNARYPLUS       reduce using rule 5 (list -> list stmt newline .)
    INC             reduce using rule 5 (list -> list stmt newline .)
    DEC             reduce using rule 5 (list -> list stmt newline .)
    NOT             reduce using rule 5 (list -> list stmt newline .)
    BLTIN           reduce using rule 5 (list -> list stmt newline .)
    $end            reduce using rule 5 (list -> list stmt newline .)


state 51

    (62) callfunc -> BLTIN begin . LPARENT expr RPARENT

    LPARENT         shift and go to state 94


state 52

    (68) defn -> FUNC procname . LPARENT formals RPARENT stmt

    LPARENT         shift and go to state 95


state 53

    (70) procname -> VAR .

    LPARENT         reduce using rule 70 (procname -> VAR .)


state 54

    (63) callfunc -> VAR begin . LPARENT arglist RPARENT

    LPARENT         shift and go to state 96


state 55

    (14) asgn -> VAR MODEQ . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 97
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 56

    (11) asgn -> VAR SUBEQ . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 98
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 57

    (12) asgn -> VAR MULEQ . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 99
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 58

    (10) asgn -> VAR ADDEQ . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 100
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 59

    (44) unaryop -> VAR DEC .

    EXP             reduce using rule 44 (unaryop -> VAR DEC .)
    PLUS            reduce using rule 44 (unaryop -> VAR DEC .)
    MINUS           reduce using rule 44 (unaryop -> VAR DEC .)
    TIMES           reduce using rule 44 (unaryop -> VAR DEC .)
    DIVIDE          reduce using rule 44 (unaryop -> VAR DEC .)
    MOD             reduce using rule 44 (unaryop -> VAR DEC .)
    LT              reduce using rule 44 (unaryop -> VAR DEC .)
    GT              reduce using rule 44 (unaryop -> VAR DEC .)
    LE              reduce using rule 44 (unaryop -> VAR DEC .)
    GE              reduce using rule 44 (unaryop -> VAR DEC .)
    EQ              reduce using rule 44 (unaryop -> VAR DEC .)
    NE              reduce using rule 44 (unaryop -> VAR DEC .)
    OR              reduce using rule 44 (unaryop -> VAR DEC .)
    AND             reduce using rule 44 (unaryop -> VAR DEC .)
    NEWLINE         reduce using rule 44 (unaryop -> VAR DEC .)
    RBRACKET        reduce using rule 44 (unaryop -> VAR DEC .)
    RETURN          reduce using rule 44 (unaryop -> VAR DEC .)
    PRINT           reduce using rule 44 (unaryop -> VAR DEC .)
    WHILE           reduce using rule 44 (unaryop -> VAR DEC .)
    FOR             reduce using rule 44 (unaryop -> VAR DEC .)
    IF              reduce using rule 44 (unaryop -> VAR DEC .)
    LBRACKET        reduce using rule 44 (unaryop -> VAR DEC .)
    LPARENT         reduce using rule 44 (unaryop -> VAR DEC .)
    FLOAT           reduce using rule 44 (unaryop -> VAR DEC .)
    CONSTANT        reduce using rule 44 (unaryop -> VAR DEC .)
    VAR             reduce using rule 44 (unaryop -> VAR DEC .)
    UNARYMINUS      reduce using rule 44 (unaryop -> VAR DEC .)
    UNARYPLUS       reduce using rule 44 (unaryop -> VAR DEC .)
    INC             reduce using rule 44 (unaryop -> VAR DEC .)
    DEC             reduce using rule 44 (unaryop -> VAR DEC .)
    NOT             reduce using rule 44 (unaryop -> VAR DEC .)
    BLTIN           reduce using rule 44 (unaryop -> VAR DEC .)
    ELSE            reduce using rule 44 (unaryop -> VAR DEC .)
    COMMA           reduce using rule 44 (unaryop -> VAR DEC .)
    RPARENT         reduce using rule 44 (unaryop -> VAR DEC .)
    SEMICOLON       reduce using rule 44 (unaryop -> VAR DEC .)


state 60

    (9) asgn -> VAR ASSIGN . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 101
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 61

    (13) asgn -> VAR DIVEQ . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 102
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 62

    (43) unaryop -> VAR INC .

    EXP             reduce using rule 43 (unaryop -> VAR INC .)
    PLUS            reduce using rule 43 (unaryop -> VAR INC .)
    MINUS           reduce using rule 43 (unaryop -> VAR INC .)
    TIMES           reduce using rule 43 (unaryop -> VAR INC .)
    DIVIDE          reduce using rule 43 (unaryop -> VAR INC .)
    MOD             reduce using rule 43 (unaryop -> VAR INC .)
    LT              reduce using rule 43 (unaryop -> VAR INC .)
    GT              reduce using rule 43 (unaryop -> VAR INC .)
    LE              reduce using rule 43 (unaryop -> VAR INC .)
    GE              reduce using rule 43 (unaryop -> VAR INC .)
    EQ              reduce using rule 43 (unaryop -> VAR INC .)
    NE              reduce using rule 43 (unaryop -> VAR INC .)
    OR              reduce using rule 43 (unaryop -> VAR INC .)
    AND             reduce using rule 43 (unaryop -> VAR INC .)
    NEWLINE         reduce using rule 43 (unaryop -> VAR INC .)
    RBRACKET        reduce using rule 43 (unaryop -> VAR INC .)
    RETURN          reduce using rule 43 (unaryop -> VAR INC .)
    PRINT           reduce using rule 43 (unaryop -> VAR INC .)
    WHILE           reduce using rule 43 (unaryop -> VAR INC .)
    FOR             reduce using rule 43 (unaryop -> VAR INC .)
    IF              reduce using rule 43 (unaryop -> VAR INC .)
    LBRACKET        reduce using rule 43 (unaryop -> VAR INC .)
    LPARENT         reduce using rule 43 (unaryop -> VAR INC .)
    FLOAT           reduce using rule 43 (unaryop -> VAR INC .)
    CONSTANT        reduce using rule 43 (unaryop -> VAR INC .)
    VAR             reduce using rule 43 (unaryop -> VAR INC .)
    UNARYMINUS      reduce using rule 43 (unaryop -> VAR INC .)
    UNARYPLUS       reduce using rule 43 (unaryop -> VAR INC .)
    INC             reduce using rule 43 (unaryop -> VAR INC .)
    DEC             reduce using rule 43 (unaryop -> VAR INC .)
    NOT             reduce using rule 43 (unaryop -> VAR INC .)
    BLTIN           reduce using rule 43 (unaryop -> VAR INC .)
    ELSE            reduce using rule 43 (unaryop -> VAR INC .)
    COMMA           reduce using rule 43 (unaryop -> VAR INC .)
    RPARENT         reduce using rule 43 (unaryop -> VAR INC .)
    SEMICOLON       reduce using rule 43 (unaryop -> VAR INC .)


state 63

    (3) list -> list defn newline .

    error           reduce using rule 3 (list -> list defn newline .)
    COMMENT         reduce using rule 3 (list -> list defn newline .)
    NEWLINE         reduce using rule 3 (list -> list defn newline .)
    FUNC            reduce using rule 3 (list -> list defn newline .)
    PROC            reduce using rule 3 (list -> list defn newline .)
    VAR             reduce using rule 3 (list -> list defn newline .)
    RETURN          reduce using rule 3 (list -> list defn newline .)
    PRINT           reduce using rule 3 (list -> list defn newline .)
    WHILE           reduce using rule 3 (list -> list defn newline .)
    FOR             reduce using rule 3 (list -> list defn newline .)
    IF              reduce using rule 3 (list -> list defn newline .)
    LBRACKET        reduce using rule 3 (list -> list defn newline .)
    LPARENT         reduce using rule 3 (list -> list defn newline .)
    FLOAT           reduce using rule 3 (list -> list defn newline .)
    CONSTANT        reduce using rule 3 (list -> list defn newline .)
    UNARYMINUS      reduce using rule 3 (list -> list defn newline .)
    UNARYPLUS       reduce using rule 3 (list -> list defn newline .)
    INC             reduce using rule 3 (list -> list defn newline .)
    DEC             reduce using rule 3 (list -> list defn newline .)
    NOT             reduce using rule 3 (list -> list defn newline .)
    BLTIN           reduce using rule 3 (list -> list defn newline .)
    $end            reduce using rule 3 (list -> list defn newline .)


state 64

    (21) stmt -> IF LPARENT . cond RPARENT stmt end
    (22) stmt -> IF LPARENT . cond RPARENT stmt ELSE stmt end
    (26) cond -> . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 90
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    cond                           shift and go to state 103
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 65

    (61) logicop -> expr AND . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 104
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 66

    (60) logicop -> expr OR . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 105
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 67

    (55) logicop -> expr GT . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 106
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 68

    (52) mathop -> expr DIVIDE . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 107
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 69

    (6) list -> list expr newline .

    error           reduce using rule 6 (list -> list expr newline .)
    COMMENT         reduce using rule 6 (list -> list expr newline .)
    NEWLINE         reduce using rule 6 (list -> list expr newline .)
    FUNC            reduce using rule 6 (list -> list expr newline .)
    PROC            reduce using rule 6 (list -> list expr newline .)
    VAR             reduce using rule 6 (list -> list expr newline .)
    RETURN          reduce using rule 6 (list -> list expr newline .)
    PRINT           reduce using rule 6 (list -> list expr newline .)
    WHILE           reduce using rule 6 (list -> list expr newline .)
    FOR             reduce using rule 6 (list -> list expr newline .)
    IF              reduce using rule 6 (list -> list expr newline .)
    LBRACKET        reduce using rule 6 (list -> list expr newline .)
    LPARENT         reduce using rule 6 (list -> list expr newline .)
    FLOAT           reduce using rule 6 (list -> list expr newline .)
    CONSTANT        reduce using rule 6 (list -> list expr newline .)
    UNARYMINUS      reduce using rule 6 (list -> list expr newline .)
    UNARYPLUS       reduce using rule 6 (list -> list expr newline .)
    INC             reduce using rule 6 (list -> list expr newline .)
    DEC             reduce using rule 6 (list -> list expr newline .)
    NOT             reduce using rule 6 (list -> list expr newline .)
    BLTIN           reduce using rule 6 (list -> list expr newline .)
    $end            reduce using rule 6 (list -> list expr newline .)


state 70

    (57) logicop -> expr GE . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 108
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 71

    (51) mathop -> expr TIMES . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 109
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 72

    (54) logicop -> expr LT . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 110
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 73

    (56) logicop -> expr LE . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 111
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 74

    (49) mathop -> expr PLUS . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 112
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 75

    (48) mathop -> expr EXP . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 113
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 76

    (58) logicop -> expr EQ . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 114
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 77

    (50) mathop -> expr MINUS . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 115
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 78

    (59) logicop -> expr NE . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 116
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 79

    (53) mathop -> expr MOD . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 117
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 80

    (39) unaryop -> UNARYMINUS expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    PLUS            reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    MINUS           reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    TIMES           reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    DIVIDE          reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    MOD             reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    LT              reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    GT              reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    LE              reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    GE              reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    EQ              reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    NE              reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    OR              reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    AND             reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    NEWLINE         reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    RBRACKET        reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    RETURN          reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    PRINT           reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    WHILE           reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    FOR             reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    IF              reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    LBRACKET        reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    LPARENT         reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    FLOAT           reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    CONSTANT        reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    VAR             reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    UNARYMINUS      reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    UNARYPLUS       reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    INC             reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    DEC             reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    NOT             reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    BLTIN           reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    ELSE            reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    COMMA           reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    RPARENT         reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    SEMICOLON       reduce using rule 39 (unaryop -> UNARYMINUS expr .)
    EXP             shift and go to state 75

  ! EXP             [ reduce using rule 39 (unaryop -> UNARYMINUS expr .) ]
  ! PLUS            [ shift and go to state 74 ]
  ! MINUS           [ shift and go to state 77 ]
  ! TIMES           [ shift and go to state 71 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 79 ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 81

    (7) list -> list error newline .

    error           reduce using rule 7 (list -> list error newline .)
    COMMENT         reduce using rule 7 (list -> list error newline .)
    NEWLINE         reduce using rule 7 (list -> list error newline .)
    FUNC            reduce using rule 7 (list -> list error newline .)
    PROC            reduce using rule 7 (list -> list error newline .)
    VAR             reduce using rule 7 (list -> list error newline .)
    RETURN          reduce using rule 7 (list -> list error newline .)
    PRINT           reduce using rule 7 (list -> list error newline .)
    WHILE           reduce using rule 7 (list -> list error newline .)
    FOR             reduce using rule 7 (list -> list error newline .)
    IF              reduce using rule 7 (list -> list error newline .)
    LBRACKET        reduce using rule 7 (list -> list error newline .)
    LPARENT         reduce using rule 7 (list -> list error newline .)
    FLOAT           reduce using rule 7 (list -> list error newline .)
    CONSTANT        reduce using rule 7 (list -> list error newline .)
    UNARYMINUS      reduce using rule 7 (list -> list error newline .)
    UNARYPLUS       reduce using rule 7 (list -> list error newline .)
    INC             reduce using rule 7 (list -> list error newline .)
    DEC             reduce using rule 7 (list -> list error newline .)
    NOT             reduce using rule 7 (list -> list error newline .)
    BLTIN           reduce using rule 7 (list -> list error newline .)
    $end            reduce using rule 7 (list -> list error newline .)


state 82

    (45) unaryop -> NOT expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    PLUS            reduce using rule 45 (unaryop -> NOT expr .)
    MINUS           reduce using rule 45 (unaryop -> NOT expr .)
    TIMES           reduce using rule 45 (unaryop -> NOT expr .)
    DIVIDE          reduce using rule 45 (unaryop -> NOT expr .)
    MOD             reduce using rule 45 (unaryop -> NOT expr .)
    LT              reduce using rule 45 (unaryop -> NOT expr .)
    GT              reduce using rule 45 (unaryop -> NOT expr .)
    LE              reduce using rule 45 (unaryop -> NOT expr .)
    GE              reduce using rule 45 (unaryop -> NOT expr .)
    EQ              reduce using rule 45 (unaryop -> NOT expr .)
    NE              reduce using rule 45 (unaryop -> NOT expr .)
    OR              reduce using rule 45 (unaryop -> NOT expr .)
    AND             reduce using rule 45 (unaryop -> NOT expr .)
    NEWLINE         reduce using rule 45 (unaryop -> NOT expr .)
    RBRACKET        reduce using rule 45 (unaryop -> NOT expr .)
    RETURN          reduce using rule 45 (unaryop -> NOT expr .)
    PRINT           reduce using rule 45 (unaryop -> NOT expr .)
    WHILE           reduce using rule 45 (unaryop -> NOT expr .)
    FOR             reduce using rule 45 (unaryop -> NOT expr .)
    IF              reduce using rule 45 (unaryop -> NOT expr .)
    LBRACKET        reduce using rule 45 (unaryop -> NOT expr .)
    LPARENT         reduce using rule 45 (unaryop -> NOT expr .)
    FLOAT           reduce using rule 45 (unaryop -> NOT expr .)
    CONSTANT        reduce using rule 45 (unaryop -> NOT expr .)
    VAR             reduce using rule 45 (unaryop -> NOT expr .)
    UNARYMINUS      reduce using rule 45 (unaryop -> NOT expr .)
    UNARYPLUS       reduce using rule 45 (unaryop -> NOT expr .)
    INC             reduce using rule 45 (unaryop -> NOT expr .)
    DEC             reduce using rule 45 (unaryop -> NOT expr .)
    NOT             reduce using rule 45 (unaryop -> NOT expr .)
    BLTIN           reduce using rule 45 (unaryop -> NOT expr .)
    ELSE            reduce using rule 45 (unaryop -> NOT expr .)
    COMMA           reduce using rule 45 (unaryop -> NOT expr .)
    RPARENT         reduce using rule 45 (unaryop -> NOT expr .)
    SEMICOLON       reduce using rule 45 (unaryop -> NOT expr .)
    EXP             shift and go to state 75

  ! EXP             [ reduce using rule 45 (unaryop -> NOT expr .) ]
  ! PLUS            [ shift and go to state 74 ]
  ! MINUS           [ shift and go to state 77 ]
  ! TIMES           [ shift and go to state 71 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 79 ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 83

    (69) defn -> PROC procname . LPARENT formals RPARENT stmt

    LPARENT         shift and go to state 118


state 84

    (41) unaryop -> INC VAR .

    EXP             reduce using rule 41 (unaryop -> INC VAR .)
    PLUS            reduce using rule 41 (unaryop -> INC VAR .)
    MINUS           reduce using rule 41 (unaryop -> INC VAR .)
    TIMES           reduce using rule 41 (unaryop -> INC VAR .)
    DIVIDE          reduce using rule 41 (unaryop -> INC VAR .)
    MOD             reduce using rule 41 (unaryop -> INC VAR .)
    LT              reduce using rule 41 (unaryop -> INC VAR .)
    GT              reduce using rule 41 (unaryop -> INC VAR .)
    LE              reduce using rule 41 (unaryop -> INC VAR .)
    GE              reduce using rule 41 (unaryop -> INC VAR .)
    EQ              reduce using rule 41 (unaryop -> INC VAR .)
    NE              reduce using rule 41 (unaryop -> INC VAR .)
    OR              reduce using rule 41 (unaryop -> INC VAR .)
    AND             reduce using rule 41 (unaryop -> INC VAR .)
    NEWLINE         reduce using rule 41 (unaryop -> INC VAR .)
    RBRACKET        reduce using rule 41 (unaryop -> INC VAR .)
    RETURN          reduce using rule 41 (unaryop -> INC VAR .)
    PRINT           reduce using rule 41 (unaryop -> INC VAR .)
    WHILE           reduce using rule 41 (unaryop -> INC VAR .)
    FOR             reduce using rule 41 (unaryop -> INC VAR .)
    IF              reduce using rule 41 (unaryop -> INC VAR .)
    LBRACKET        reduce using rule 41 (unaryop -> INC VAR .)
    LPARENT         reduce using rule 41 (unaryop -> INC VAR .)
    FLOAT           reduce using rule 41 (unaryop -> INC VAR .)
    CONSTANT        reduce using rule 41 (unaryop -> INC VAR .)
    VAR             reduce using rule 41 (unaryop -> INC VAR .)
    UNARYMINUS      reduce using rule 41 (unaryop -> INC VAR .)
    UNARYPLUS       reduce using rule 41 (unaryop -> INC VAR .)
    INC             reduce using rule 41 (unaryop -> INC VAR .)
    DEC             reduce using rule 41 (unaryop -> INC VAR .)
    NOT             reduce using rule 41 (unaryop -> INC VAR .)
    BLTIN           reduce using rule 41 (unaryop -> INC VAR .)
    ELSE            reduce using rule 41 (unaryop -> INC VAR .)
    COMMA           reduce using rule 41 (unaryop -> INC VAR .)
    RPARENT         reduce using rule 41 (unaryop -> INC VAR .)
    SEMICOLON       reduce using rule 41 (unaryop -> INC VAR .)


state 85

    (28) stmtlist -> stmtlist newline .

    RBRACKET        reduce using rule 28 (stmtlist -> stmtlist newline .)
    NEWLINE         reduce using rule 28 (stmtlist -> stmtlist newline .)
    RETURN          reduce using rule 28 (stmtlist -> stmtlist newline .)
    PRINT           reduce using rule 28 (stmtlist -> stmtlist newline .)
    WHILE           reduce using rule 28 (stmtlist -> stmtlist newline .)
    FOR             reduce using rule 28 (stmtlist -> stmtlist newline .)
    IF              reduce using rule 28 (stmtlist -> stmtlist newline .)
    LBRACKET        reduce using rule 28 (stmtlist -> stmtlist newline .)
    LPARENT         reduce using rule 28 (stmtlist -> stmtlist newline .)
    FLOAT           reduce using rule 28 (stmtlist -> stmtlist newline .)
    CONSTANT        reduce using rule 28 (stmtlist -> stmtlist newline .)
    VAR             reduce using rule 28 (stmtlist -> stmtlist newline .)
    UNARYMINUS      reduce using rule 28 (stmtlist -> stmtlist newline .)
    UNARYPLUS       reduce using rule 28 (stmtlist -> stmtlist newline .)
    INC             reduce using rule 28 (stmtlist -> stmtlist newline .)
    DEC             reduce using rule 28 (stmtlist -> stmtlist newline .)
    NOT             reduce using rule 28 (stmtlist -> stmtlist newline .)
    BLTIN           reduce using rule 28 (stmtlist -> stmtlist newline .)


state 86

    (29) stmtlist -> stmtlist stmt .

    RBRACKET        reduce using rule 29 (stmtlist -> stmtlist stmt .)
    NEWLINE         reduce using rule 29 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 29 (stmtlist -> stmtlist stmt .)
    PRINT           reduce using rule 29 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 29 (stmtlist -> stmtlist stmt .)
    FOR             reduce using rule 29 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 29 (stmtlist -> stmtlist stmt .)
    LBRACKET        reduce using rule 29 (stmtlist -> stmtlist stmt .)
    LPARENT         reduce using rule 29 (stmtlist -> stmtlist stmt .)
    FLOAT           reduce using rule 29 (stmtlist -> stmtlist stmt .)
    CONSTANT        reduce using rule 29 (stmtlist -> stmtlist stmt .)
    VAR             reduce using rule 29 (stmtlist -> stmtlist stmt .)
    UNARYMINUS      reduce using rule 29 (stmtlist -> stmtlist stmt .)
    UNARYPLUS       reduce using rule 29 (stmtlist -> stmtlist stmt .)
    INC             reduce using rule 29 (stmtlist -> stmtlist stmt .)
    DEC             reduce using rule 29 (stmtlist -> stmtlist stmt .)
    NOT             reduce using rule 29 (stmtlist -> stmtlist stmt .)
    BLTIN           reduce using rule 29 (stmtlist -> stmtlist stmt .)


state 87

    (15) stmt -> expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    NEWLINE         reduce using rule 15 (stmt -> expr .)
    RBRACKET        reduce using rule 15 (stmt -> expr .)
    RETURN          reduce using rule 15 (stmt -> expr .)
    PRINT           reduce using rule 15 (stmt -> expr .)
    WHILE           reduce using rule 15 (stmt -> expr .)
    FOR             reduce using rule 15 (stmt -> expr .)
    IF              reduce using rule 15 (stmt -> expr .)
    LBRACKET        reduce using rule 15 (stmt -> expr .)
    LPARENT         reduce using rule 15 (stmt -> expr .)
    FLOAT           reduce using rule 15 (stmt -> expr .)
    CONSTANT        reduce using rule 15 (stmt -> expr .)
    VAR             reduce using rule 15 (stmt -> expr .)
    UNARYMINUS      reduce using rule 15 (stmt -> expr .)
    UNARYPLUS       reduce using rule 15 (stmt -> expr .)
    INC             reduce using rule 15 (stmt -> expr .)
    DEC             reduce using rule 15 (stmt -> expr .)
    NOT             reduce using rule 15 (stmt -> expr .)
    BLTIN           reduce using rule 15 (stmt -> expr .)
    ELSE            reduce using rule 15 (stmt -> expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65


state 88

    (23) stmt -> LBRACKET stmtlist RBRACKET .

    NEWLINE         reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    RBRACKET        reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    RETURN          reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    PRINT           reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    WHILE           reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    FOR             reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    IF              reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    LBRACKET        reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    LPARENT         reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    FLOAT           reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    CONSTANT        reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    VAR             reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    UNARYMINUS      reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    UNARYPLUS       reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    INC             reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    DEC             reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    NOT             reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    BLTIN           reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    ELSE            reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)


state 89

    (19) stmt -> WHILE LPARENT cond . RPARENT stmt end

    RPARENT         shift and go to state 119


state 90

    (26) cond -> expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    RPARENT         reduce using rule 26 (cond -> expr .)
    SEMICOLON       reduce using rule 26 (cond -> expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65


state 91

    (66) prlist -> prlist COMMA . expr
    (67) prlist -> prlist COMMA . STRING
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    STRING          shift and go to state 120
    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 121
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 92

    (34) expr -> LPARENT expr RPARENT .

    EXP             reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    PLUS            reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    MINUS           reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    TIMES           reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    DIVIDE          reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    MOD             reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    LT              reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    GT              reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    LE              reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    GE              reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    EQ              reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    NE              reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    OR              reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    AND             reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    NEWLINE         reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    RBRACKET        reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    RETURN          reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    PRINT           reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    WHILE           reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    FOR             reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    IF              reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    LBRACKET        reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    LPARENT         reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    FLOAT           reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    CONSTANT        reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    VAR             reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    UNARYMINUS      reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    UNARYPLUS       reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    INC             reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    DEC             reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    NOT             reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    BLTIN           reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    ELSE            reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    COMMA           reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    RPARENT         reduce using rule 34 (expr -> LPARENT expr RPARENT .)
    SEMICOLON       reduce using rule 34 (expr -> LPARENT expr RPARENT .)


state 93

    (20) stmt -> FOR LPARENT cond . SEMICOLON cond SEMICOLON cond RPARENT stmt end

    SEMICOLON       shift and go to state 122


state 94

    (62) callfunc -> BLTIN begin LPARENT . expr RPARENT
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 123
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 95

    (68) defn -> FUNC procname LPARENT . formals RPARENT stmt
    (71) formals -> . empty
    (72) formals -> . VAR
    (73) formals -> . formals COMMA VAR
    (77) empty -> .

    VAR             shift and go to state 124
    RPARENT         reduce using rule 77 (empty -> .)
    COMMA           reduce using rule 77 (empty -> .)

    empty                          shift and go to state 125
    formals                        shift and go to state 126

state 96

    (63) callfunc -> VAR begin LPARENT . arglist RPARENT
    (74) arglist -> . empty
    (75) arglist -> . expr
    (76) arglist -> . arglist COMMA expr
    (77) empty -> .
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    RPARENT         reduce using rule 77 (empty -> .)
    COMMA           reduce using rule 77 (empty -> .)
    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 128
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    arglist                        shift and go to state 127
    data                           shift and go to state 22
    empty                          shift and go to state 129

state 97

    (14) asgn -> VAR MODEQ expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    RPARENT         reduce using rule 14 (asgn -> VAR MODEQ expr .)
    NEWLINE         reduce using rule 14 (asgn -> VAR MODEQ expr .)
    RBRACKET        reduce using rule 14 (asgn -> VAR MODEQ expr .)
    RETURN          reduce using rule 14 (asgn -> VAR MODEQ expr .)
    PRINT           reduce using rule 14 (asgn -> VAR MODEQ expr .)
    WHILE           reduce using rule 14 (asgn -> VAR MODEQ expr .)
    FOR             reduce using rule 14 (asgn -> VAR MODEQ expr .)
    IF              reduce using rule 14 (asgn -> VAR MODEQ expr .)
    LBRACKET        reduce using rule 14 (asgn -> VAR MODEQ expr .)
    LPARENT         reduce using rule 14 (asgn -> VAR MODEQ expr .)
    FLOAT           reduce using rule 14 (asgn -> VAR MODEQ expr .)
    CONSTANT        reduce using rule 14 (asgn -> VAR MODEQ expr .)
    VAR             reduce using rule 14 (asgn -> VAR MODEQ expr .)
    UNARYMINUS      reduce using rule 14 (asgn -> VAR MODEQ expr .)
    UNARYPLUS       reduce using rule 14 (asgn -> VAR MODEQ expr .)
    INC             reduce using rule 14 (asgn -> VAR MODEQ expr .)
    DEC             reduce using rule 14 (asgn -> VAR MODEQ expr .)
    NOT             reduce using rule 14 (asgn -> VAR MODEQ expr .)
    BLTIN           reduce using rule 14 (asgn -> VAR MODEQ expr .)
    ELSE            reduce using rule 14 (asgn -> VAR MODEQ expr .)
    COMMA           reduce using rule 14 (asgn -> VAR MODEQ expr .)
    SEMICOLON       reduce using rule 14 (asgn -> VAR MODEQ expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65

  ! EXP             [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! PLUS            [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! MINUS           [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! TIMES           [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! DIVIDE          [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! MOD             [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! LT              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! GT              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! LE              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! GE              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! EQ              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! NE              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! OR              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! AND             [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]


state 98

    (11) asgn -> VAR SUBEQ expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    RPARENT         reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    NEWLINE         reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    RBRACKET        reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    RETURN          reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    PRINT           reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    WHILE           reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    FOR             reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    IF              reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    LBRACKET        reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    LPARENT         reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    FLOAT           reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    CONSTANT        reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    VAR             reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    UNARYMINUS      reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    UNARYPLUS       reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    INC             reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    DEC             reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    NOT             reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    BLTIN           reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    ELSE            reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    COMMA           reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    SEMICOLON       reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65

  ! EXP             [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! PLUS            [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! MINUS           [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! TIMES           [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! DIVIDE          [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! MOD             [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! LT              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! GT              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! LE              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! GE              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! EQ              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! NE              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! OR              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! AND             [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]


state 99

    (12) asgn -> VAR MULEQ expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    RPARENT         reduce using rule 12 (asgn -> VAR MULEQ expr .)
    NEWLINE         reduce using rule 12 (asgn -> VAR MULEQ expr .)
    RBRACKET        reduce using rule 12 (asgn -> VAR MULEQ expr .)
    RETURN          reduce using rule 12 (asgn -> VAR MULEQ expr .)
    PRINT           reduce using rule 12 (asgn -> VAR MULEQ expr .)
    WHILE           reduce using rule 12 (asgn -> VAR MULEQ expr .)
    FOR             reduce using rule 12 (asgn -> VAR MULEQ expr .)
    IF              reduce using rule 12 (asgn -> VAR MULEQ expr .)
    LBRACKET        reduce using rule 12 (asgn -> VAR MULEQ expr .)
    LPARENT         reduce using rule 12 (asgn -> VAR MULEQ expr .)
    FLOAT           reduce using rule 12 (asgn -> VAR MULEQ expr .)
    CONSTANT        reduce using rule 12 (asgn -> VAR MULEQ expr .)
    VAR             reduce using rule 12 (asgn -> VAR MULEQ expr .)
    UNARYMINUS      reduce using rule 12 (asgn -> VAR MULEQ expr .)
    UNARYPLUS       reduce using rule 12 (asgn -> VAR MULEQ expr .)
    INC             reduce using rule 12 (asgn -> VAR MULEQ expr .)
    DEC             reduce using rule 12 (asgn -> VAR MULEQ expr .)
    NOT             reduce using rule 12 (asgn -> VAR MULEQ expr .)
    BLTIN           reduce using rule 12 (asgn -> VAR MULEQ expr .)
    ELSE            reduce using rule 12 (asgn -> VAR MULEQ expr .)
    COMMA           reduce using rule 12 (asgn -> VAR MULEQ expr .)
    SEMICOLON       reduce using rule 12 (asgn -> VAR MULEQ expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65

  ! EXP             [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! PLUS            [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! MINUS           [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! TIMES           [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! DIVIDE          [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! MOD             [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! LT              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! GT              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! LE              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! GE              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! EQ              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! NE              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! OR              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! AND             [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]


state 100

    (10) asgn -> VAR ADDEQ expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    RPARENT         reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    NEWLINE         reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    RBRACKET        reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    RETURN          reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    PRINT           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    WHILE           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    FOR             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    IF              reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    LBRACKET        reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    LPARENT         reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    FLOAT           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    CONSTANT        reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    VAR             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    UNARYMINUS      reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    UNARYPLUS       reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    INC             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    DEC             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    NOT             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    BLTIN           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    ELSE            reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    COMMA           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    SEMICOLON       reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65

  ! EXP             [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! PLUS            [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! MINUS           [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! TIMES           [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! DIVIDE          [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! MOD             [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! LT              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! GT              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! LE              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! GE              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! EQ              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! NE              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! OR              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! AND             [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]


state 101

    (9) asgn -> VAR ASSIGN expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    RPARENT         reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    NEWLINE         reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    RBRACKET        reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    RETURN          reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    PRINT           reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    WHILE           reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    FOR             reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    IF              reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    LBRACKET        reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    LPARENT         reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    FLOAT           reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    CONSTANT        reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    VAR             reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    UNARYMINUS      reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    UNARYPLUS       reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    INC             reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    DEC             reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    NOT             reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    BLTIN           reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    ELSE            reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    COMMA           reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    SEMICOLON       reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65

  ! EXP             [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! PLUS            [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! MINUS           [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! TIMES           [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! DIVIDE          [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! MOD             [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! LT              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! GT              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! LE              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! GE              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! EQ              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! NE              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! OR              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! AND             [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]


state 102

    (13) asgn -> VAR DIVEQ expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    RPARENT         reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    NEWLINE         reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    RBRACKET        reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    RETURN          reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    PRINT           reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    WHILE           reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    FOR             reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    IF              reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    LBRACKET        reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    LPARENT         reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    FLOAT           reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    CONSTANT        reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    VAR             reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    UNARYMINUS      reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    UNARYPLUS       reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    INC             reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    DEC             reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    NOT             reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    BLTIN           reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    ELSE            reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    COMMA           reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    SEMICOLON       reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65

  ! EXP             [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! PLUS            [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! MINUS           [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! TIMES           [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! DIVIDE          [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! MOD             [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! LT              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! GT              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! LE              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! GE              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! EQ              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! NE              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! OR              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! AND             [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]


state 103

    (21) stmt -> IF LPARENT cond . RPARENT stmt end
    (22) stmt -> IF LPARENT cond . RPARENT stmt ELSE stmt end

    RPARENT         shift and go to state 130


state 104

    (61) logicop -> expr AND expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    OR              reduce using rule 61 (logicop -> expr AND expr .)
    AND             reduce using rule 61 (logicop -> expr AND expr .)
    NEWLINE         reduce using rule 61 (logicop -> expr AND expr .)
    RBRACKET        reduce using rule 61 (logicop -> expr AND expr .)
    RETURN          reduce using rule 61 (logicop -> expr AND expr .)
    PRINT           reduce using rule 61 (logicop -> expr AND expr .)
    WHILE           reduce using rule 61 (logicop -> expr AND expr .)
    FOR             reduce using rule 61 (logicop -> expr AND expr .)
    IF              reduce using rule 61 (logicop -> expr AND expr .)
    LBRACKET        reduce using rule 61 (logicop -> expr AND expr .)
    LPARENT         reduce using rule 61 (logicop -> expr AND expr .)
    FLOAT           reduce using rule 61 (logicop -> expr AND expr .)
    CONSTANT        reduce using rule 61 (logicop -> expr AND expr .)
    VAR             reduce using rule 61 (logicop -> expr AND expr .)
    UNARYMINUS      reduce using rule 61 (logicop -> expr AND expr .)
    UNARYPLUS       reduce using rule 61 (logicop -> expr AND expr .)
    INC             reduce using rule 61 (logicop -> expr AND expr .)
    DEC             reduce using rule 61 (logicop -> expr AND expr .)
    NOT             reduce using rule 61 (logicop -> expr AND expr .)
    BLTIN           reduce using rule 61 (logicop -> expr AND expr .)
    ELSE            reduce using rule 61 (logicop -> expr AND expr .)
    COMMA           reduce using rule 61 (logicop -> expr AND expr .)
    RPARENT         reduce using rule 61 (logicop -> expr AND expr .)
    SEMICOLON       reduce using rule 61 (logicop -> expr AND expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78

  ! EXP             [ reduce using rule 61 (logicop -> expr AND expr .) ]
  ! PLUS            [ reduce using rule 61 (logicop -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 61 (logicop -> expr AND expr .) ]
  ! TIMES           [ reduce using rule 61 (logicop -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 61 (logicop -> expr AND expr .) ]
  ! MOD             [ reduce using rule 61 (logicop -> expr AND expr .) ]
  ! LT              [ reduce using rule 61 (logicop -> expr AND expr .) ]
  ! GT              [ reduce using rule 61 (logicop -> expr AND expr .) ]
  ! LE              [ reduce using rule 61 (logicop -> expr AND expr .) ]
  ! GE              [ reduce using rule 61 (logicop -> expr AND expr .) ]
  ! EQ              [ reduce using rule 61 (logicop -> expr AND expr .) ]
  ! NE              [ reduce using rule 61 (logicop -> expr AND expr .) ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 105

    (60) logicop -> expr OR expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    OR              reduce using rule 60 (logicop -> expr OR expr .)
    NEWLINE         reduce using rule 60 (logicop -> expr OR expr .)
    RBRACKET        reduce using rule 60 (logicop -> expr OR expr .)
    RETURN          reduce using rule 60 (logicop -> expr OR expr .)
    PRINT           reduce using rule 60 (logicop -> expr OR expr .)
    WHILE           reduce using rule 60 (logicop -> expr OR expr .)
    FOR             reduce using rule 60 (logicop -> expr OR expr .)
    IF              reduce using rule 60 (logicop -> expr OR expr .)
    LBRACKET        reduce using rule 60 (logicop -> expr OR expr .)
    LPARENT         reduce using rule 60 (logicop -> expr OR expr .)
    FLOAT           reduce using rule 60 (logicop -> expr OR expr .)
    CONSTANT        reduce using rule 60 (logicop -> expr OR expr .)
    VAR             reduce using rule 60 (logicop -> expr OR expr .)
    UNARYMINUS      reduce using rule 60 (logicop -> expr OR expr .)
    UNARYPLUS       reduce using rule 60 (logicop -> expr OR expr .)
    INC             reduce using rule 60 (logicop -> expr OR expr .)
    DEC             reduce using rule 60 (logicop -> expr OR expr .)
    NOT             reduce using rule 60 (logicop -> expr OR expr .)
    BLTIN           reduce using rule 60 (logicop -> expr OR expr .)
    ELSE            reduce using rule 60 (logicop -> expr OR expr .)
    COMMA           reduce using rule 60 (logicop -> expr OR expr .)
    RPARENT         reduce using rule 60 (logicop -> expr OR expr .)
    SEMICOLON       reduce using rule 60 (logicop -> expr OR expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    AND             shift and go to state 65

  ! EXP             [ reduce using rule 60 (logicop -> expr OR expr .) ]
  ! PLUS            [ reduce using rule 60 (logicop -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 60 (logicop -> expr OR expr .) ]
  ! TIMES           [ reduce using rule 60 (logicop -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 60 (logicop -> expr OR expr .) ]
  ! MOD             [ reduce using rule 60 (logicop -> expr OR expr .) ]
  ! LT              [ reduce using rule 60 (logicop -> expr OR expr .) ]
  ! GT              [ reduce using rule 60 (logicop -> expr OR expr .) ]
  ! LE              [ reduce using rule 60 (logicop -> expr OR expr .) ]
  ! GE              [ reduce using rule 60 (logicop -> expr OR expr .) ]
  ! EQ              [ reduce using rule 60 (logicop -> expr OR expr .) ]
  ! NE              [ reduce using rule 60 (logicop -> expr OR expr .) ]
  ! AND             [ reduce using rule 60 (logicop -> expr OR expr .) ]
  ! OR              [ shift and go to state 66 ]


state 106

    (55) logicop -> expr GT expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    LT              reduce using rule 55 (logicop -> expr GT expr .)
    GT              reduce using rule 55 (logicop -> expr GT expr .)
    LE              reduce using rule 55 (logicop -> expr GT expr .)
    GE              reduce using rule 55 (logicop -> expr GT expr .)
    EQ              reduce using rule 55 (logicop -> expr GT expr .)
    NE              reduce using rule 55 (logicop -> expr GT expr .)
    OR              reduce using rule 55 (logicop -> expr GT expr .)
    AND             reduce using rule 55 (logicop -> expr GT expr .)
    NEWLINE         reduce using rule 55 (logicop -> expr GT expr .)
    RBRACKET        reduce using rule 55 (logicop -> expr GT expr .)
    RETURN          reduce using rule 55 (logicop -> expr GT expr .)
    PRINT           reduce using rule 55 (logicop -> expr GT expr .)
    WHILE           reduce using rule 55 (logicop -> expr GT expr .)
    FOR             reduce using rule 55 (logicop -> expr GT expr .)
    IF              reduce using rule 55 (logicop -> expr GT expr .)
    LBRACKET        reduce using rule 55 (logicop -> expr GT expr .)
    LPARENT         reduce using rule 55 (logicop -> expr GT expr .)
    FLOAT           reduce using rule 55 (logicop -> expr GT expr .)
    CONSTANT        reduce using rule 55 (logicop -> expr GT expr .)
    VAR             reduce using rule 55 (logicop -> expr GT expr .)
    UNARYMINUS      reduce using rule 55 (logicop -> expr GT expr .)
    UNARYPLUS       reduce using rule 55 (logicop -> expr GT expr .)
    INC             reduce using rule 55 (logicop -> expr GT expr .)
    DEC             reduce using rule 55 (logicop -> expr GT expr .)
    NOT             reduce using rule 55 (logicop -> expr GT expr .)
    BLTIN           reduce using rule 55 (logicop -> expr GT expr .)
    ELSE            reduce using rule 55 (logicop -> expr GT expr .)
    COMMA           reduce using rule 55 (logicop -> expr GT expr .)
    RPARENT         reduce using rule 55 (logicop -> expr GT expr .)
    SEMICOLON       reduce using rule 55 (logicop -> expr GT expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79

  ! EXP             [ reduce using rule 55 (logicop -> expr GT expr .) ]
  ! PLUS            [ reduce using rule 55 (logicop -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 55 (logicop -> expr GT expr .) ]
  ! TIMES           [ reduce using rule 55 (logicop -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 55 (logicop -> expr GT expr .) ]
  ! MOD             [ reduce using rule 55 (logicop -> expr GT expr .) ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 107

    (52) mathop -> expr DIVIDE expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    PLUS            reduce using rule 52 (mathop -> expr DIVIDE expr .)
    MINUS           reduce using rule 52 (mathop -> expr DIVIDE expr .)
    TIMES           reduce using rule 52 (mathop -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 52 (mathop -> expr DIVIDE expr .)
    MOD             reduce using rule 52 (mathop -> expr DIVIDE expr .)
    LT              reduce using rule 52 (mathop -> expr DIVIDE expr .)
    GT              reduce using rule 52 (mathop -> expr DIVIDE expr .)
    LE              reduce using rule 52 (mathop -> expr DIVIDE expr .)
    GE              reduce using rule 52 (mathop -> expr DIVIDE expr .)
    EQ              reduce using rule 52 (mathop -> expr DIVIDE expr .)
    NE              reduce using rule 52 (mathop -> expr DIVIDE expr .)
    OR              reduce using rule 52 (mathop -> expr DIVIDE expr .)
    AND             reduce using rule 52 (mathop -> expr DIVIDE expr .)
    RPARENT         reduce using rule 52 (mathop -> expr DIVIDE expr .)
    NEWLINE         reduce using rule 52 (mathop -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 52 (mathop -> expr DIVIDE expr .)
    RETURN          reduce using rule 52 (mathop -> expr DIVIDE expr .)
    PRINT           reduce using rule 52 (mathop -> expr DIVIDE expr .)
    WHILE           reduce using rule 52 (mathop -> expr DIVIDE expr .)
    FOR             reduce using rule 52 (mathop -> expr DIVIDE expr .)
    IF              reduce using rule 52 (mathop -> expr DIVIDE expr .)
    LBRACKET        reduce using rule 52 (mathop -> expr DIVIDE expr .)
    LPARENT         reduce using rule 52 (mathop -> expr DIVIDE expr .)
    FLOAT           reduce using rule 52 (mathop -> expr DIVIDE expr .)
    CONSTANT        reduce using rule 52 (mathop -> expr DIVIDE expr .)
    VAR             reduce using rule 52 (mathop -> expr DIVIDE expr .)
    UNARYMINUS      reduce using rule 52 (mathop -> expr DIVIDE expr .)
    UNARYPLUS       reduce using rule 52 (mathop -> expr DIVIDE expr .)
    INC             reduce using rule 52 (mathop -> expr DIVIDE expr .)
    DEC             reduce using rule 52 (mathop -> expr DIVIDE expr .)
    NOT             reduce using rule 52 (mathop -> expr DIVIDE expr .)
    BLTIN           reduce using rule 52 (mathop -> expr DIVIDE expr .)
    ELSE            reduce using rule 52 (mathop -> expr DIVIDE expr .)
    COMMA           reduce using rule 52 (mathop -> expr DIVIDE expr .)
    SEMICOLON       reduce using rule 52 (mathop -> expr DIVIDE expr .)
    EXP             shift and go to state 75

  ! EXP             [ reduce using rule 52 (mathop -> expr DIVIDE expr .) ]
  ! PLUS            [ shift and go to state 74 ]
  ! MINUS           [ shift and go to state 77 ]
  ! TIMES           [ shift and go to state 71 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 79 ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 108

    (57) logicop -> expr GE expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    LT              reduce using rule 57 (logicop -> expr GE expr .)
    GT              reduce using rule 57 (logicop -> expr GE expr .)
    LE              reduce using rule 57 (logicop -> expr GE expr .)
    GE              reduce using rule 57 (logicop -> expr GE expr .)
    EQ              reduce using rule 57 (logicop -> expr GE expr .)
    NE              reduce using rule 57 (logicop -> expr GE expr .)
    OR              reduce using rule 57 (logicop -> expr GE expr .)
    AND             reduce using rule 57 (logicop -> expr GE expr .)
    NEWLINE         reduce using rule 57 (logicop -> expr GE expr .)
    RBRACKET        reduce using rule 57 (logicop -> expr GE expr .)
    RETURN          reduce using rule 57 (logicop -> expr GE expr .)
    PRINT           reduce using rule 57 (logicop -> expr GE expr .)
    WHILE           reduce using rule 57 (logicop -> expr GE expr .)
    FOR             reduce using rule 57 (logicop -> expr GE expr .)
    IF              reduce using rule 57 (logicop -> expr GE expr .)
    LBRACKET        reduce using rule 57 (logicop -> expr GE expr .)
    LPARENT         reduce using rule 57 (logicop -> expr GE expr .)
    FLOAT           reduce using rule 57 (logicop -> expr GE expr .)
    CONSTANT        reduce using rule 57 (logicop -> expr GE expr .)
    VAR             reduce using rule 57 (logicop -> expr GE expr .)
    UNARYMINUS      reduce using rule 57 (logicop -> expr GE expr .)
    UNARYPLUS       reduce using rule 57 (logicop -> expr GE expr .)
    INC             reduce using rule 57 (logicop -> expr GE expr .)
    DEC             reduce using rule 57 (logicop -> expr GE expr .)
    NOT             reduce using rule 57 (logicop -> expr GE expr .)
    BLTIN           reduce using rule 57 (logicop -> expr GE expr .)
    ELSE            reduce using rule 57 (logicop -> expr GE expr .)
    COMMA           reduce using rule 57 (logicop -> expr GE expr .)
    RPARENT         reduce using rule 57 (logicop -> expr GE expr .)
    SEMICOLON       reduce using rule 57 (logicop -> expr GE expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79

  ! EXP             [ reduce using rule 57 (logicop -> expr GE expr .) ]
  ! PLUS            [ reduce using rule 57 (logicop -> expr GE expr .) ]
  ! MINUS           [ reduce using rule 57 (logicop -> expr GE expr .) ]
  ! TIMES           [ reduce using rule 57 (logicop -> expr GE expr .) ]
  ! DIVIDE          [ reduce using rule 57 (logicop -> expr GE expr .) ]
  ! MOD             [ reduce using rule 57 (logicop -> expr GE expr .) ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 109

    (51) mathop -> expr TIMES expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    PLUS            reduce using rule 51 (mathop -> expr TIMES expr .)
    MINUS           reduce using rule 51 (mathop -> expr TIMES expr .)
    TIMES           reduce using rule 51 (mathop -> expr TIMES expr .)
    DIVIDE          reduce using rule 51 (mathop -> expr TIMES expr .)
    MOD             reduce using rule 51 (mathop -> expr TIMES expr .)
    LT              reduce using rule 51 (mathop -> expr TIMES expr .)
    GT              reduce using rule 51 (mathop -> expr TIMES expr .)
    LE              reduce using rule 51 (mathop -> expr TIMES expr .)
    GE              reduce using rule 51 (mathop -> expr TIMES expr .)
    EQ              reduce using rule 51 (mathop -> expr TIMES expr .)
    NE              reduce using rule 51 (mathop -> expr TIMES expr .)
    OR              reduce using rule 51 (mathop -> expr TIMES expr .)
    AND             reduce using rule 51 (mathop -> expr TIMES expr .)
    RPARENT         reduce using rule 51 (mathop -> expr TIMES expr .)
    NEWLINE         reduce using rule 51 (mathop -> expr TIMES expr .)
    RBRACKET        reduce using rule 51 (mathop -> expr TIMES expr .)
    RETURN          reduce using rule 51 (mathop -> expr TIMES expr .)
    PRINT           reduce using rule 51 (mathop -> expr TIMES expr .)
    WHILE           reduce using rule 51 (mathop -> expr TIMES expr .)
    FOR             reduce using rule 51 (mathop -> expr TIMES expr .)
    IF              reduce using rule 51 (mathop -> expr TIMES expr .)
    LBRACKET        reduce using rule 51 (mathop -> expr TIMES expr .)
    LPARENT         reduce using rule 51 (mathop -> expr TIMES expr .)
    FLOAT           reduce using rule 51 (mathop -> expr TIMES expr .)
    CONSTANT        reduce using rule 51 (mathop -> expr TIMES expr .)
    VAR             reduce using rule 51 (mathop -> expr TIMES expr .)
    UNARYMINUS      reduce using rule 51 (mathop -> expr TIMES expr .)
    UNARYPLUS       reduce using rule 51 (mathop -> expr TIMES expr .)
    INC             reduce using rule 51 (mathop -> expr TIMES expr .)
    DEC             reduce using rule 51 (mathop -> expr TIMES expr .)
    NOT             reduce using rule 51 (mathop -> expr TIMES expr .)
    BLTIN           reduce using rule 51 (mathop -> expr TIMES expr .)
    ELSE            reduce using rule 51 (mathop -> expr TIMES expr .)
    COMMA           reduce using rule 51 (mathop -> expr TIMES expr .)
    SEMICOLON       reduce using rule 51 (mathop -> expr TIMES expr .)
    EXP             shift and go to state 75

  ! EXP             [ reduce using rule 51 (mathop -> expr TIMES expr .) ]
  ! PLUS            [ shift and go to state 74 ]
  ! MINUS           [ shift and go to state 77 ]
  ! TIMES           [ shift and go to state 71 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 79 ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 110

    (54) logicop -> expr LT expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    LT              reduce using rule 54 (logicop -> expr LT expr .)
    GT              reduce using rule 54 (logicop -> expr LT expr .)
    LE              reduce using rule 54 (logicop -> expr LT expr .)
    GE              reduce using rule 54 (logicop -> expr LT expr .)
    EQ              reduce using rule 54 (logicop -> expr LT expr .)
    NE              reduce using rule 54 (logicop -> expr LT expr .)
    OR              reduce using rule 54 (logicop -> expr LT expr .)
    AND             reduce using rule 54 (logicop -> expr LT expr .)
    NEWLINE         reduce using rule 54 (logicop -> expr LT expr .)
    RBRACKET        reduce using rule 54 (logicop -> expr LT expr .)
    RETURN          reduce using rule 54 (logicop -> expr LT expr .)
    PRINT           reduce using rule 54 (logicop -> expr LT expr .)
    WHILE           reduce using rule 54 (logicop -> expr LT expr .)
    FOR             reduce using rule 54 (logicop -> expr LT expr .)
    IF              reduce using rule 54 (logicop -> expr LT expr .)
    LBRACKET        reduce using rule 54 (logicop -> expr LT expr .)
    LPARENT         reduce using rule 54 (logicop -> expr LT expr .)
    FLOAT           reduce using rule 54 (logicop -> expr LT expr .)
    CONSTANT        reduce using rule 54 (logicop -> expr LT expr .)
    VAR             reduce using rule 54 (logicop -> expr LT expr .)
    UNARYMINUS      reduce using rule 54 (logicop -> expr LT expr .)
    UNARYPLUS       reduce using rule 54 (logicop -> expr LT expr .)
    INC             reduce using rule 54 (logicop -> expr LT expr .)
    DEC             reduce using rule 54 (logicop -> expr LT expr .)
    NOT             reduce using rule 54 (logicop -> expr LT expr .)
    BLTIN           reduce using rule 54 (logicop -> expr LT expr .)
    ELSE            reduce using rule 54 (logicop -> expr LT expr .)
    COMMA           reduce using rule 54 (logicop -> expr LT expr .)
    RPARENT         reduce using rule 54 (logicop -> expr LT expr .)
    SEMICOLON       reduce using rule 54 (logicop -> expr LT expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79

  ! EXP             [ reduce using rule 54 (logicop -> expr LT expr .) ]
  ! PLUS            [ reduce using rule 54 (logicop -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 54 (logicop -> expr LT expr .) ]
  ! TIMES           [ reduce using rule 54 (logicop -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 54 (logicop -> expr LT expr .) ]
  ! MOD             [ reduce using rule 54 (logicop -> expr LT expr .) ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 111

    (56) logicop -> expr LE expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    LT              reduce using rule 56 (logicop -> expr LE expr .)
    GT              reduce using rule 56 (logicop -> expr LE expr .)
    LE              reduce using rule 56 (logicop -> expr LE expr .)
    GE              reduce using rule 56 (logicop -> expr LE expr .)
    EQ              reduce using rule 56 (logicop -> expr LE expr .)
    NE              reduce using rule 56 (logicop -> expr LE expr .)
    OR              reduce using rule 56 (logicop -> expr LE expr .)
    AND             reduce using rule 56 (logicop -> expr LE expr .)
    NEWLINE         reduce using rule 56 (logicop -> expr LE expr .)
    RBRACKET        reduce using rule 56 (logicop -> expr LE expr .)
    RETURN          reduce using rule 56 (logicop -> expr LE expr .)
    PRINT           reduce using rule 56 (logicop -> expr LE expr .)
    WHILE           reduce using rule 56 (logicop -> expr LE expr .)
    FOR             reduce using rule 56 (logicop -> expr LE expr .)
    IF              reduce using rule 56 (logicop -> expr LE expr .)
    LBRACKET        reduce using rule 56 (logicop -> expr LE expr .)
    LPARENT         reduce using rule 56 (logicop -> expr LE expr .)
    FLOAT           reduce using rule 56 (logicop -> expr LE expr .)
    CONSTANT        reduce using rule 56 (logicop -> expr LE expr .)
    VAR             reduce using rule 56 (logicop -> expr LE expr .)
    UNARYMINUS      reduce using rule 56 (logicop -> expr LE expr .)
    UNARYPLUS       reduce using rule 56 (logicop -> expr LE expr .)
    INC             reduce using rule 56 (logicop -> expr LE expr .)
    DEC             reduce using rule 56 (logicop -> expr LE expr .)
    NOT             reduce using rule 56 (logicop -> expr LE expr .)
    BLTIN           reduce using rule 56 (logicop -> expr LE expr .)
    ELSE            reduce using rule 56 (logicop -> expr LE expr .)
    COMMA           reduce using rule 56 (logicop -> expr LE expr .)
    RPARENT         reduce using rule 56 (logicop -> expr LE expr .)
    SEMICOLON       reduce using rule 56 (logicop -> expr LE expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79

  ! EXP             [ reduce using rule 56 (logicop -> expr LE expr .) ]
  ! PLUS            [ reduce using rule 56 (logicop -> expr LE expr .) ]
  ! MINUS           [ reduce using rule 56 (logicop -> expr LE expr .) ]
  ! TIMES           [ reduce using rule 56 (logicop -> expr LE expr .) ]
  ! DIVIDE          [ reduce using rule 56 (logicop -> expr LE expr .) ]
  ! MOD             [ reduce using rule 56 (logicop -> expr LE expr .) ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 112

    (49) mathop -> expr PLUS expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    PLUS            reduce using rule 49 (mathop -> expr PLUS expr .)
    MINUS           reduce using rule 49 (mathop -> expr PLUS expr .)
    LT              reduce using rule 49 (mathop -> expr PLUS expr .)
    GT              reduce using rule 49 (mathop -> expr PLUS expr .)
    LE              reduce using rule 49 (mathop -> expr PLUS expr .)
    GE              reduce using rule 49 (mathop -> expr PLUS expr .)
    EQ              reduce using rule 49 (mathop -> expr PLUS expr .)
    NE              reduce using rule 49 (mathop -> expr PLUS expr .)
    OR              reduce using rule 49 (mathop -> expr PLUS expr .)
    AND             reduce using rule 49 (mathop -> expr PLUS expr .)
    RPARENT         reduce using rule 49 (mathop -> expr PLUS expr .)
    NEWLINE         reduce using rule 49 (mathop -> expr PLUS expr .)
    RBRACKET        reduce using rule 49 (mathop -> expr PLUS expr .)
    RETURN          reduce using rule 49 (mathop -> expr PLUS expr .)
    PRINT           reduce using rule 49 (mathop -> expr PLUS expr .)
    WHILE           reduce using rule 49 (mathop -> expr PLUS expr .)
    FOR             reduce using rule 49 (mathop -> expr PLUS expr .)
    IF              reduce using rule 49 (mathop -> expr PLUS expr .)
    LBRACKET        reduce using rule 49 (mathop -> expr PLUS expr .)
    LPARENT         reduce using rule 49 (mathop -> expr PLUS expr .)
    FLOAT           reduce using rule 49 (mathop -> expr PLUS expr .)
    CONSTANT        reduce using rule 49 (mathop -> expr PLUS expr .)
    VAR             reduce using rule 49 (mathop -> expr PLUS expr .)
    UNARYMINUS      reduce using rule 49 (mathop -> expr PLUS expr .)
    UNARYPLUS       reduce using rule 49 (mathop -> expr PLUS expr .)
    INC             reduce using rule 49 (mathop -> expr PLUS expr .)
    DEC             reduce using rule 49 (mathop -> expr PLUS expr .)
    NOT             reduce using rule 49 (mathop -> expr PLUS expr .)
    BLTIN           reduce using rule 49 (mathop -> expr PLUS expr .)
    ELSE            reduce using rule 49 (mathop -> expr PLUS expr .)
    COMMA           reduce using rule 49 (mathop -> expr PLUS expr .)
    SEMICOLON       reduce using rule 49 (mathop -> expr PLUS expr .)
    EXP             shift and go to state 75
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79

  ! EXP             [ reduce using rule 49 (mathop -> expr PLUS expr .) ]
  ! TIMES           [ reduce using rule 49 (mathop -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 49 (mathop -> expr PLUS expr .) ]
  ! MOD             [ reduce using rule 49 (mathop -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 74 ]
  ! MINUS           [ shift and go to state 77 ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 113

    (48) mathop -> expr EXP expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    EXP             reduce using rule 48 (mathop -> expr EXP expr .)
    PLUS            reduce using rule 48 (mathop -> expr EXP expr .)
    MINUS           reduce using rule 48 (mathop -> expr EXP expr .)
    TIMES           reduce using rule 48 (mathop -> expr EXP expr .)
    DIVIDE          reduce using rule 48 (mathop -> expr EXP expr .)
    MOD             reduce using rule 48 (mathop -> expr EXP expr .)
    LT              reduce using rule 48 (mathop -> expr EXP expr .)
    GT              reduce using rule 48 (mathop -> expr EXP expr .)
    LE              reduce using rule 48 (mathop -> expr EXP expr .)
    GE              reduce using rule 48 (mathop -> expr EXP expr .)
    EQ              reduce using rule 48 (mathop -> expr EXP expr .)
    NE              reduce using rule 48 (mathop -> expr EXP expr .)
    OR              reduce using rule 48 (mathop -> expr EXP expr .)
    AND             reduce using rule 48 (mathop -> expr EXP expr .)
    RPARENT         reduce using rule 48 (mathop -> expr EXP expr .)
    NEWLINE         reduce using rule 48 (mathop -> expr EXP expr .)
    RBRACKET        reduce using rule 48 (mathop -> expr EXP expr .)
    RETURN          reduce using rule 48 (mathop -> expr EXP expr .)
    PRINT           reduce using rule 48 (mathop -> expr EXP expr .)
    WHILE           reduce using rule 48 (mathop -> expr EXP expr .)
    FOR             reduce using rule 48 (mathop -> expr EXP expr .)
    IF              reduce using rule 48 (mathop -> expr EXP expr .)
    LBRACKET        reduce using rule 48 (mathop -> expr EXP expr .)
    LPARENT         reduce using rule 48 (mathop -> expr EXP expr .)
    FLOAT           reduce using rule 48 (mathop -> expr EXP expr .)
    CONSTANT        reduce using rule 48 (mathop -> expr EXP expr .)
    VAR             reduce using rule 48 (mathop -> expr EXP expr .)
    UNARYMINUS      reduce using rule 48 (mathop -> expr EXP expr .)
    UNARYPLUS       reduce using rule 48 (mathop -> expr EXP expr .)
    INC             reduce using rule 48 (mathop -> expr EXP expr .)
    DEC             reduce using rule 48 (mathop -> expr EXP expr .)
    NOT             reduce using rule 48 (mathop -> expr EXP expr .)
    BLTIN           reduce using rule 48 (mathop -> expr EXP expr .)
    ELSE            reduce using rule 48 (mathop -> expr EXP expr .)
    COMMA           reduce using rule 48 (mathop -> expr EXP expr .)
    SEMICOLON       reduce using rule 48 (mathop -> expr EXP expr .)

  ! EXP             [ shift and go to state 75 ]
  ! PLUS            [ shift and go to state 74 ]
  ! MINUS           [ shift and go to state 77 ]
  ! TIMES           [ shift and go to state 71 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 79 ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 114

    (58) logicop -> expr EQ expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    LT              reduce using rule 58 (logicop -> expr EQ expr .)
    GT              reduce using rule 58 (logicop -> expr EQ expr .)
    LE              reduce using rule 58 (logicop -> expr EQ expr .)
    GE              reduce using rule 58 (logicop -> expr EQ expr .)
    EQ              reduce using rule 58 (logicop -> expr EQ expr .)
    NE              reduce using rule 58 (logicop -> expr EQ expr .)
    OR              reduce using rule 58 (logicop -> expr EQ expr .)
    AND             reduce using rule 58 (logicop -> expr EQ expr .)
    NEWLINE         reduce using rule 58 (logicop -> expr EQ expr .)
    RBRACKET        reduce using rule 58 (logicop -> expr EQ expr .)
    RETURN          reduce using rule 58 (logicop -> expr EQ expr .)
    PRINT           reduce using rule 58 (logicop -> expr EQ expr .)
    WHILE           reduce using rule 58 (logicop -> expr EQ expr .)
    FOR             reduce using rule 58 (logicop -> expr EQ expr .)
    IF              reduce using rule 58 (logicop -> expr EQ expr .)
    LBRACKET        reduce using rule 58 (logicop -> expr EQ expr .)
    LPARENT         reduce using rule 58 (logicop -> expr EQ expr .)
    FLOAT           reduce using rule 58 (logicop -> expr EQ expr .)
    CONSTANT        reduce using rule 58 (logicop -> expr EQ expr .)
    VAR             reduce using rule 58 (logicop -> expr EQ expr .)
    UNARYMINUS      reduce using rule 58 (logicop -> expr EQ expr .)
    UNARYPLUS       reduce using rule 58 (logicop -> expr EQ expr .)
    INC             reduce using rule 58 (logicop -> expr EQ expr .)
    DEC             reduce using rule 58 (logicop -> expr EQ expr .)
    NOT             reduce using rule 58 (logicop -> expr EQ expr .)
    BLTIN           reduce using rule 58 (logicop -> expr EQ expr .)
    ELSE            reduce using rule 58 (logicop -> expr EQ expr .)
    COMMA           reduce using rule 58 (logicop -> expr EQ expr .)
    RPARENT         reduce using rule 58 (logicop -> expr EQ expr .)
    SEMICOLON       reduce using rule 58 (logicop -> expr EQ expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79

  ! EXP             [ reduce using rule 58 (logicop -> expr EQ expr .) ]
  ! PLUS            [ reduce using rule 58 (logicop -> expr EQ expr .) ]
  ! MINUS           [ reduce using rule 58 (logicop -> expr EQ expr .) ]
  ! TIMES           [ reduce using rule 58 (logicop -> expr EQ expr .) ]
  ! DIVIDE          [ reduce using rule 58 (logicop -> expr EQ expr .) ]
  ! MOD             [ reduce using rule 58 (logicop -> expr EQ expr .) ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 115

    (50) mathop -> expr MINUS expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    PLUS            reduce using rule 50 (mathop -> expr MINUS expr .)
    MINUS           reduce using rule 50 (mathop -> expr MINUS expr .)
    LT              reduce using rule 50 (mathop -> expr MINUS expr .)
    GT              reduce using rule 50 (mathop -> expr MINUS expr .)
    LE              reduce using rule 50 (mathop -> expr MINUS expr .)
    GE              reduce using rule 50 (mathop -> expr MINUS expr .)
    EQ              reduce using rule 50 (mathop -> expr MINUS expr .)
    NE              reduce using rule 50 (mathop -> expr MINUS expr .)
    OR              reduce using rule 50 (mathop -> expr MINUS expr .)
    AND             reduce using rule 50 (mathop -> expr MINUS expr .)
    RPARENT         reduce using rule 50 (mathop -> expr MINUS expr .)
    NEWLINE         reduce using rule 50 (mathop -> expr MINUS expr .)
    RBRACKET        reduce using rule 50 (mathop -> expr MINUS expr .)
    RETURN          reduce using rule 50 (mathop -> expr MINUS expr .)
    PRINT           reduce using rule 50 (mathop -> expr MINUS expr .)
    WHILE           reduce using rule 50 (mathop -> expr MINUS expr .)
    FOR             reduce using rule 50 (mathop -> expr MINUS expr .)
    IF              reduce using rule 50 (mathop -> expr MINUS expr .)
    LBRACKET        reduce using rule 50 (mathop -> expr MINUS expr .)
    LPARENT         reduce using rule 50 (mathop -> expr MINUS expr .)
    FLOAT           reduce using rule 50 (mathop -> expr MINUS expr .)
    CONSTANT        reduce using rule 50 (mathop -> expr MINUS expr .)
    VAR             reduce using rule 50 (mathop -> expr MINUS expr .)
    UNARYMINUS      reduce using rule 50 (mathop -> expr MINUS expr .)
    UNARYPLUS       reduce using rule 50 (mathop -> expr MINUS expr .)
    INC             reduce using rule 50 (mathop -> expr MINUS expr .)
    DEC             reduce using rule 50 (mathop -> expr MINUS expr .)
    NOT             reduce using rule 50 (mathop -> expr MINUS expr .)
    BLTIN           reduce using rule 50 (mathop -> expr MINUS expr .)
    ELSE            reduce using rule 50 (mathop -> expr MINUS expr .)
    COMMA           reduce using rule 50 (mathop -> expr MINUS expr .)
    SEMICOLON       reduce using rule 50 (mathop -> expr MINUS expr .)
    EXP             shift and go to state 75
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79

  ! EXP             [ reduce using rule 50 (mathop -> expr MINUS expr .) ]
  ! TIMES           [ reduce using rule 50 (mathop -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 50 (mathop -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 50 (mathop -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 74 ]
  ! MINUS           [ shift and go to state 77 ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 116

    (59) logicop -> expr NE expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    LT              reduce using rule 59 (logicop -> expr NE expr .)
    GT              reduce using rule 59 (logicop -> expr NE expr .)
    LE              reduce using rule 59 (logicop -> expr NE expr .)
    GE              reduce using rule 59 (logicop -> expr NE expr .)
    EQ              reduce using rule 59 (logicop -> expr NE expr .)
    NE              reduce using rule 59 (logicop -> expr NE expr .)
    OR              reduce using rule 59 (logicop -> expr NE expr .)
    AND             reduce using rule 59 (logicop -> expr NE expr .)
    NEWLINE         reduce using rule 59 (logicop -> expr NE expr .)
    RBRACKET        reduce using rule 59 (logicop -> expr NE expr .)
    RETURN          reduce using rule 59 (logicop -> expr NE expr .)
    PRINT           reduce using rule 59 (logicop -> expr NE expr .)
    WHILE           reduce using rule 59 (logicop -> expr NE expr .)
    FOR             reduce using rule 59 (logicop -> expr NE expr .)
    IF              reduce using rule 59 (logicop -> expr NE expr .)
    LBRACKET        reduce using rule 59 (logicop -> expr NE expr .)
    LPARENT         reduce using rule 59 (logicop -> expr NE expr .)
    FLOAT           reduce using rule 59 (logicop -> expr NE expr .)
    CONSTANT        reduce using rule 59 (logicop -> expr NE expr .)
    VAR             reduce using rule 59 (logicop -> expr NE expr .)
    UNARYMINUS      reduce using rule 59 (logicop -> expr NE expr .)
    UNARYPLUS       reduce using rule 59 (logicop -> expr NE expr .)
    INC             reduce using rule 59 (logicop -> expr NE expr .)
    DEC             reduce using rule 59 (logicop -> expr NE expr .)
    NOT             reduce using rule 59 (logicop -> expr NE expr .)
    BLTIN           reduce using rule 59 (logicop -> expr NE expr .)
    ELSE            reduce using rule 59 (logicop -> expr NE expr .)
    COMMA           reduce using rule 59 (logicop -> expr NE expr .)
    RPARENT         reduce using rule 59 (logicop -> expr NE expr .)
    SEMICOLON       reduce using rule 59 (logicop -> expr NE expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79

  ! EXP             [ reduce using rule 59 (logicop -> expr NE expr .) ]
  ! PLUS            [ reduce using rule 59 (logicop -> expr NE expr .) ]
  ! MINUS           [ reduce using rule 59 (logicop -> expr NE expr .) ]
  ! TIMES           [ reduce using rule 59 (logicop -> expr NE expr .) ]
  ! DIVIDE          [ reduce using rule 59 (logicop -> expr NE expr .) ]
  ! MOD             [ reduce using rule 59 (logicop -> expr NE expr .) ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 117

    (53) mathop -> expr MOD expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    PLUS            reduce using rule 53 (mathop -> expr MOD expr .)
    MINUS           reduce using rule 53 (mathop -> expr MOD expr .)
    TIMES           reduce using rule 53 (mathop -> expr MOD expr .)
    DIVIDE          reduce using rule 53 (mathop -> expr MOD expr .)
    MOD             reduce using rule 53 (mathop -> expr MOD expr .)
    LT              reduce using rule 53 (mathop -> expr MOD expr .)
    GT              reduce using rule 53 (mathop -> expr MOD expr .)
    LE              reduce using rule 53 (mathop -> expr MOD expr .)
    GE              reduce using rule 53 (mathop -> expr MOD expr .)
    EQ              reduce using rule 53 (mathop -> expr MOD expr .)
    NE              reduce using rule 53 (mathop -> expr MOD expr .)
    OR              reduce using rule 53 (mathop -> expr MOD expr .)
    AND             reduce using rule 53 (mathop -> expr MOD expr .)
    RPARENT         reduce using rule 53 (mathop -> expr MOD expr .)
    NEWLINE         reduce using rule 53 (mathop -> expr MOD expr .)
    RBRACKET        reduce using rule 53 (mathop -> expr MOD expr .)
    RETURN          reduce using rule 53 (mathop -> expr MOD expr .)
    PRINT           reduce using rule 53 (mathop -> expr MOD expr .)
    WHILE           reduce using rule 53 (mathop -> expr MOD expr .)
    FOR             reduce using rule 53 (mathop -> expr MOD expr .)
    IF              reduce using rule 53 (mathop -> expr MOD expr .)
    LBRACKET        reduce using rule 53 (mathop -> expr MOD expr .)
    LPARENT         reduce using rule 53 (mathop -> expr MOD expr .)
    FLOAT           reduce using rule 53 (mathop -> expr MOD expr .)
    CONSTANT        reduce using rule 53 (mathop -> expr MOD expr .)
    VAR             reduce using rule 53 (mathop -> expr MOD expr .)
    UNARYMINUS      reduce using rule 53 (mathop -> expr MOD expr .)
    UNARYPLUS       reduce using rule 53 (mathop -> expr MOD expr .)
    INC             reduce using rule 53 (mathop -> expr MOD expr .)
    DEC             reduce using rule 53 (mathop -> expr MOD expr .)
    NOT             reduce using rule 53 (mathop -> expr MOD expr .)
    BLTIN           reduce using rule 53 (mathop -> expr MOD expr .)
    ELSE            reduce using rule 53 (mathop -> expr MOD expr .)
    COMMA           reduce using rule 53 (mathop -> expr MOD expr .)
    SEMICOLON       reduce using rule 53 (mathop -> expr MOD expr .)
    EXP             shift and go to state 75

  ! EXP             [ reduce using rule 53 (mathop -> expr MOD expr .) ]
  ! PLUS            [ shift and go to state 74 ]
  ! MINUS           [ shift and go to state 77 ]
  ! TIMES           [ shift and go to state 71 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 79 ]
  ! LT              [ shift and go to state 72 ]
  ! GT              [ shift and go to state 67 ]
  ! LE              [ shift and go to state 73 ]
  ! GE              [ shift and go to state 70 ]
  ! EQ              [ shift and go to state 76 ]
  ! NE              [ shift and go to state 78 ]
  ! OR              [ shift and go to state 66 ]
  ! AND             [ shift and go to state 65 ]


state 118

    (69) defn -> PROC procname LPARENT . formals RPARENT stmt
    (71) formals -> . empty
    (72) formals -> . VAR
    (73) formals -> . formals COMMA VAR
    (77) empty -> .

    VAR             shift and go to state 124
    RPARENT         reduce using rule 77 (empty -> .)
    COMMA           reduce using rule 77 (empty -> .)

    empty                          shift and go to state 125
    formals                        shift and go to state 131

state 119

    (19) stmt -> WHILE LPARENT cond RPARENT . stmt end
    (15) stmt -> . expr
    (16) stmt -> . RETURN expr
    (17) stmt -> . RETURN
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt end
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end
    (21) stmt -> . IF LPARENT cond RPARENT stmt end
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt end
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 87
    callfunc                       shift and go to state 26
    stmt                           shift and go to state 132
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 120

    (67) prlist -> prlist COMMA STRING .

    COMMA           reduce using rule 67 (prlist -> prlist COMMA STRING .)
    NEWLINE         reduce using rule 67 (prlist -> prlist COMMA STRING .)
    RBRACKET        reduce using rule 67 (prlist -> prlist COMMA STRING .)
    RETURN          reduce using rule 67 (prlist -> prlist COMMA STRING .)
    PRINT           reduce using rule 67 (prlist -> prlist COMMA STRING .)
    WHILE           reduce using rule 67 (prlist -> prlist COMMA STRING .)
    FOR             reduce using rule 67 (prlist -> prlist COMMA STRING .)
    IF              reduce using rule 67 (prlist -> prlist COMMA STRING .)
    LBRACKET        reduce using rule 67 (prlist -> prlist COMMA STRING .)
    LPARENT         reduce using rule 67 (prlist -> prlist COMMA STRING .)
    FLOAT           reduce using rule 67 (prlist -> prlist COMMA STRING .)
    CONSTANT        reduce using rule 67 (prlist -> prlist COMMA STRING .)
    VAR             reduce using rule 67 (prlist -> prlist COMMA STRING .)
    UNARYMINUS      reduce using rule 67 (prlist -> prlist COMMA STRING .)
    UNARYPLUS       reduce using rule 67 (prlist -> prlist COMMA STRING .)
    INC             reduce using rule 67 (prlist -> prlist COMMA STRING .)
    DEC             reduce using rule 67 (prlist -> prlist COMMA STRING .)
    NOT             reduce using rule 67 (prlist -> prlist COMMA STRING .)
    BLTIN           reduce using rule 67 (prlist -> prlist COMMA STRING .)
    ELSE            reduce using rule 67 (prlist -> prlist COMMA STRING .)


state 121

    (66) prlist -> prlist COMMA expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    COMMA           reduce using rule 66 (prlist -> prlist COMMA expr .)
    NEWLINE         reduce using rule 66 (prlist -> prlist COMMA expr .)
    RBRACKET        reduce using rule 66 (prlist -> prlist COMMA expr .)
    RETURN          reduce using rule 66 (prlist -> prlist COMMA expr .)
    PRINT           reduce using rule 66 (prlist -> prlist COMMA expr .)
    WHILE           reduce using rule 66 (prlist -> prlist COMMA expr .)
    FOR             reduce using rule 66 (prlist -> prlist COMMA expr .)
    IF              reduce using rule 66 (prlist -> prlist COMMA expr .)
    LBRACKET        reduce using rule 66 (prlist -> prlist COMMA expr .)
    LPARENT         reduce using rule 66 (prlist -> prlist COMMA expr .)
    FLOAT           reduce using rule 66 (prlist -> prlist COMMA expr .)
    CONSTANT        reduce using rule 66 (prlist -> prlist COMMA expr .)
    VAR             reduce using rule 66 (prlist -> prlist COMMA expr .)
    UNARYMINUS      reduce using rule 66 (prlist -> prlist COMMA expr .)
    UNARYPLUS       reduce using rule 66 (prlist -> prlist COMMA expr .)
    INC             reduce using rule 66 (prlist -> prlist COMMA expr .)
    DEC             reduce using rule 66 (prlist -> prlist COMMA expr .)
    NOT             reduce using rule 66 (prlist -> prlist COMMA expr .)
    BLTIN           reduce using rule 66 (prlist -> prlist COMMA expr .)
    ELSE            reduce using rule 66 (prlist -> prlist COMMA expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65


state 122

    (20) stmt -> FOR LPARENT cond SEMICOLON . cond SEMICOLON cond RPARENT stmt end
    (26) cond -> . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 90
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    cond                           shift and go to state 133
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 123

    (62) callfunc -> BLTIN begin LPARENT expr . RPARENT
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    RPARENT         shift and go to state 134
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65


state 124

    (72) formals -> VAR .

    RPARENT         reduce using rule 72 (formals -> VAR .)
    COMMA           reduce using rule 72 (formals -> VAR .)


state 125

    (71) formals -> empty .

    RPARENT         reduce using rule 71 (formals -> empty .)
    COMMA           reduce using rule 71 (formals -> empty .)


state 126

    (68) defn -> FUNC procname LPARENT formals . RPARENT stmt
    (73) formals -> formals . COMMA VAR

    RPARENT         shift and go to state 136
    COMMA           shift and go to state 135


state 127

    (63) callfunc -> VAR begin LPARENT arglist . RPARENT
    (76) arglist -> arglist . COMMA expr

    RPARENT         shift and go to state 138
    COMMA           shift and go to state 137


state 128

    (75) arglist -> expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    RPARENT         reduce using rule 75 (arglist -> expr .)
    COMMA           reduce using rule 75 (arglist -> expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65


state 129

    (74) arglist -> empty .

    RPARENT         reduce using rule 74 (arglist -> empty .)
    COMMA           reduce using rule 74 (arglist -> empty .)


state 130

    (21) stmt -> IF LPARENT cond RPARENT . stmt end
    (22) stmt -> IF LPARENT cond RPARENT . stmt ELSE stmt end
    (15) stmt -> . expr
    (16) stmt -> . RETURN expr
    (17) stmt -> . RETURN
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt end
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end
    (21) stmt -> . IF LPARENT cond RPARENT stmt end
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt end
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 87
    callfunc                       shift and go to state 26
    stmt                           shift and go to state 139
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 131

    (69) defn -> PROC procname LPARENT formals . RPARENT stmt
    (73) formals -> formals . COMMA VAR

    RPARENT         shift and go to state 140
    COMMA           shift and go to state 135


state 132

    (19) stmt -> WHILE LPARENT cond RPARENT stmt . end
    (24) end -> .

    NEWLINE         reduce using rule 24 (end -> .)
    RBRACKET        reduce using rule 24 (end -> .)
    RETURN          reduce using rule 24 (end -> .)
    PRINT           reduce using rule 24 (end -> .)
    WHILE           reduce using rule 24 (end -> .)
    FOR             reduce using rule 24 (end -> .)
    IF              reduce using rule 24 (end -> .)
    LBRACKET        reduce using rule 24 (end -> .)
    LPARENT         reduce using rule 24 (end -> .)
    FLOAT           reduce using rule 24 (end -> .)
    CONSTANT        reduce using rule 24 (end -> .)
    VAR             reduce using rule 24 (end -> .)
    UNARYMINUS      reduce using rule 24 (end -> .)
    UNARYPLUS       reduce using rule 24 (end -> .)
    INC             reduce using rule 24 (end -> .)
    DEC             reduce using rule 24 (end -> .)
    NOT             reduce using rule 24 (end -> .)
    BLTIN           reduce using rule 24 (end -> .)
    ELSE            reduce using rule 24 (end -> .)

    end                            shift and go to state 141

state 133

    (20) stmt -> FOR LPARENT cond SEMICOLON cond . SEMICOLON cond RPARENT stmt end

    SEMICOLON       shift and go to state 142


state 134

    (62) callfunc -> BLTIN begin LPARENT expr RPARENT .

    EXP             reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    PLUS            reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    MINUS           reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    TIMES           reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    DIVIDE          reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    MOD             reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    LT              reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    GT              reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    LE              reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    GE              reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    EQ              reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    NE              reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    OR              reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    AND             reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    COMMA           reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    NEWLINE         reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    RBRACKET        reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    RETURN          reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    PRINT           reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    WHILE           reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    FOR             reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    IF              reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    LBRACKET        reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    LPARENT         reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    FLOAT           reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    CONSTANT        reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    VAR             reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    UNARYMINUS      reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    UNARYPLUS       reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    INC             reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    DEC             reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    NOT             reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    BLTIN           reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    ELSE            reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    RPARENT         reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)
    SEMICOLON       reduce using rule 62 (callfunc -> BLTIN begin LPARENT expr RPARENT .)


state 135

    (73) formals -> formals COMMA . VAR

    VAR             shift and go to state 143


state 136

    (68) defn -> FUNC procname LPARENT formals RPARENT . stmt
    (15) stmt -> . expr
    (16) stmt -> . RETURN expr
    (17) stmt -> . RETURN
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt end
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end
    (21) stmt -> . IF LPARENT cond RPARENT stmt end
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt end
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 87
    callfunc                       shift and go to state 26
    stmt                           shift and go to state 144
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 137

    (76) arglist -> arglist COMMA . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 145
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 138

    (63) callfunc -> VAR begin LPARENT arglist RPARENT .

    EXP             reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    PLUS            reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    MINUS           reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    TIMES           reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    DIVIDE          reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    MOD             reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    LT              reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    GT              reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    LE              reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    GE              reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    EQ              reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    NE              reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    OR              reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    AND             reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    COMMA           reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    NEWLINE         reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    RBRACKET        reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    RETURN          reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    PRINT           reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    WHILE           reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    FOR             reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    IF              reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    LBRACKET        reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    LPARENT         reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    FLOAT           reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    CONSTANT        reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    VAR             reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    UNARYMINUS      reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    UNARYPLUS       reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    INC             reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    DEC             reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    NOT             reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    BLTIN           reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    ELSE            reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    RPARENT         reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)
    SEMICOLON       reduce using rule 63 (callfunc -> VAR begin LPARENT arglist RPARENT .)


state 139

    (21) stmt -> IF LPARENT cond RPARENT stmt . end
    (22) stmt -> IF LPARENT cond RPARENT stmt . ELSE stmt end
    (24) end -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 147
    NEWLINE         reduce using rule 24 (end -> .)
    RBRACKET        reduce using rule 24 (end -> .)
    RETURN          reduce using rule 24 (end -> .)
    PRINT           reduce using rule 24 (end -> .)
    WHILE           reduce using rule 24 (end -> .)
    FOR             reduce using rule 24 (end -> .)
    IF              reduce using rule 24 (end -> .)
    LBRACKET        reduce using rule 24 (end -> .)
    LPARENT         reduce using rule 24 (end -> .)
    FLOAT           reduce using rule 24 (end -> .)
    CONSTANT        reduce using rule 24 (end -> .)
    VAR             reduce using rule 24 (end -> .)
    UNARYMINUS      reduce using rule 24 (end -> .)
    UNARYPLUS       reduce using rule 24 (end -> .)
    INC             reduce using rule 24 (end -> .)
    DEC             reduce using rule 24 (end -> .)
    NOT             reduce using rule 24 (end -> .)
    BLTIN           reduce using rule 24 (end -> .)

  ! ELSE            [ reduce using rule 24 (end -> .) ]

    end                            shift and go to state 146

state 140

    (69) defn -> PROC procname LPARENT formals RPARENT . stmt
    (15) stmt -> . expr
    (16) stmt -> . RETURN expr
    (17) stmt -> . RETURN
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt end
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end
    (21) stmt -> . IF LPARENT cond RPARENT stmt end
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt end
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 87
    callfunc                       shift and go to state 26
    stmt                           shift and go to state 148
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 141

    (19) stmt -> WHILE LPARENT cond RPARENT stmt end .

    NEWLINE         reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    RBRACKET        reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    RETURN          reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    PRINT           reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    WHILE           reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    FOR             reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    IF              reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    LBRACKET        reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    LPARENT         reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    FLOAT           reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    CONSTANT        reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    VAR             reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    UNARYMINUS      reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    UNARYPLUS       reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    INC             reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    DEC             reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    NOT             reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    BLTIN           reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)
    ELSE            reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt end .)


state 142

    (20) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON . cond RPARENT stmt end
    (26) cond -> . expr
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    unaryop                        shift and go to state 16
    expr                           shift and go to state 90
    callfunc                       shift and go to state 26
    asgn                           shift and go to state 35
    cond                           shift and go to state 149
    mathop                         shift and go to state 29
    binaryop                       shift and go to state 30
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 143

    (73) formals -> formals COMMA VAR .

    RPARENT         reduce using rule 73 (formals -> formals COMMA VAR .)
    COMMA           reduce using rule 73 (formals -> formals COMMA VAR .)


state 144

    (68) defn -> FUNC procname LPARENT formals RPARENT stmt .

    NEWLINE         reduce using rule 68 (defn -> FUNC procname LPARENT formals RPARENT stmt .)


state 145

    (76) arglist -> arglist COMMA expr .
    (48) mathop -> expr . EXP expr
    (49) mathop -> expr . PLUS expr
    (50) mathop -> expr . MINUS expr
    (51) mathop -> expr . TIMES expr
    (52) mathop -> expr . DIVIDE expr
    (53) mathop -> expr . MOD expr
    (54) logicop -> expr . LT expr
    (55) logicop -> expr . GT expr
    (56) logicop -> expr . LE expr
    (57) logicop -> expr . GE expr
    (58) logicop -> expr . EQ expr
    (59) logicop -> expr . NE expr
    (60) logicop -> expr . OR expr
    (61) logicop -> expr . AND expr

    RPARENT         reduce using rule 76 (arglist -> arglist COMMA expr .)
    COMMA           reduce using rule 76 (arglist -> arglist COMMA expr .)
    EXP             shift and go to state 75
    PLUS            shift and go to state 74
    MINUS           shift and go to state 77
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 79
    LT              shift and go to state 72
    GT              shift and go to state 67
    LE              shift and go to state 73
    GE              shift and go to state 70
    EQ              shift and go to state 76
    NE              shift and go to state 78
    OR              shift and go to state 66
    AND             shift and go to state 65


state 146

    (21) stmt -> IF LPARENT cond RPARENT stmt end .

    NEWLINE         reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    RBRACKET        reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    RETURN          reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    PRINT           reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    WHILE           reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    FOR             reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    IF              reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    LBRACKET        reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    LPARENT         reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    FLOAT           reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    CONSTANT        reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    VAR             reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    UNARYMINUS      reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    UNARYPLUS       reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    INC             reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    DEC             reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    NOT             reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    BLTIN           reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)
    ELSE            reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt end .)


state 147

    (22) stmt -> IF LPARENT cond RPARENT stmt ELSE . stmt end
    (15) stmt -> . expr
    (16) stmt -> . RETURN expr
    (17) stmt -> . RETURN
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt end
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end
    (21) stmt -> . IF LPARENT cond RPARENT stmt end
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt end
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 87
    callfunc                       shift and go to state 26
    stmt                           shift and go to state 150
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 148

    (69) defn -> PROC procname LPARENT formals RPARENT stmt .

    NEWLINE         reduce using rule 69 (defn -> PROC procname LPARENT formals RPARENT stmt .)


state 149

    (20) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond . RPARENT stmt end

    RPARENT         shift and go to state 151


state 150

    (22) stmt -> IF LPARENT cond RPARENT stmt ELSE stmt . end
    (24) end -> .

    NEWLINE         reduce using rule 24 (end -> .)
    RBRACKET        reduce using rule 24 (end -> .)
    RETURN          reduce using rule 24 (end -> .)
    PRINT           reduce using rule 24 (end -> .)
    WHILE           reduce using rule 24 (end -> .)
    FOR             reduce using rule 24 (end -> .)
    IF              reduce using rule 24 (end -> .)
    LBRACKET        reduce using rule 24 (end -> .)
    LPARENT         reduce using rule 24 (end -> .)
    FLOAT           reduce using rule 24 (end -> .)
    CONSTANT        reduce using rule 24 (end -> .)
    VAR             reduce using rule 24 (end -> .)
    UNARYMINUS      reduce using rule 24 (end -> .)
    UNARYPLUS       reduce using rule 24 (end -> .)
    INC             reduce using rule 24 (end -> .)
    DEC             reduce using rule 24 (end -> .)
    NOT             reduce using rule 24 (end -> .)
    BLTIN           reduce using rule 24 (end -> .)
    ELSE            reduce using rule 24 (end -> .)

    end                            shift and go to state 152

state 151

    (20) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT . stmt end
    (15) stmt -> . expr
    (16) stmt -> . RETURN expr
    (17) stmt -> . RETURN
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt end
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end
    (21) stmt -> . IF LPARENT cond RPARENT stmt end
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt end
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (30) expr -> . data
    (31) expr -> . asgn
    (32) expr -> . unaryop
    (33) expr -> . binaryop
    (34) expr -> . LPARENT expr RPARENT
    (35) expr -> . callfunc
    (36) data -> . FLOAT
    (37) data -> . CONSTANT
    (38) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (39) unaryop -> . UNARYMINUS expr
    (40) unaryop -> . UNARYPLUS expr
    (41) unaryop -> . INC VAR
    (42) unaryop -> . DEC VAR
    (43) unaryop -> . VAR INC
    (44) unaryop -> . VAR DEC
    (45) unaryop -> . NOT expr
    (46) binaryop -> . mathop
    (47) binaryop -> . logicop
    (62) callfunc -> . BLTIN begin LPARENT expr RPARENT
    (63) callfunc -> . VAR begin LPARENT arglist RPARENT
    (48) mathop -> . expr EXP expr
    (49) mathop -> . expr PLUS expr
    (50) mathop -> . expr MINUS expr
    (51) mathop -> . expr TIMES expr
    (52) mathop -> . expr DIVIDE expr
    (53) mathop -> . expr MOD expr
    (54) logicop -> . expr LT expr
    (55) logicop -> . expr GT expr
    (56) logicop -> . expr LE expr
    (57) logicop -> . expr GE expr
    (58) logicop -> . expr EQ expr
    (59) logicop -> . expr NE expr
    (60) logicop -> . expr OR expr
    (61) logicop -> . expr AND expr

    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 15
    IF              shift and go to state 24
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 11
    FLOAT           shift and go to state 27
    CONSTANT        shift and go to state 7
    VAR             shift and go to state 36
    UNARYMINUS      shift and go to state 28
    UNARYPLUS       shift and go to state 14
    INC             shift and go to state 34
    DEC             shift and go to state 8
    NOT             shift and go to state 32
    BLTIN           shift and go to state 19

    binaryop                       shift and go to state 30
    unaryop                        shift and go to state 16
    expr                           shift and go to state 87
    callfunc                       shift and go to state 26
    stmt                           shift and go to state 153
    asgn                           shift and go to state 35
    mathop                         shift and go to state 29
    logicop                        shift and go to state 9
    data                           shift and go to state 22

state 152

    (22) stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .

    NEWLINE         reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    RBRACKET        reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    RETURN          reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    PRINT           reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    WHILE           reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    FOR             reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    IF              reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    LBRACKET        reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    LPARENT         reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    FLOAT           reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    CONSTANT        reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    VAR             reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    UNARYMINUS      reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    UNARYPLUS       reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    INC             reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    DEC             reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    NOT             reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    BLTIN           reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)
    ELSE            reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt end .)


state 153

    (20) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt . end
    (24) end -> .

    NEWLINE         reduce using rule 24 (end -> .)
    RBRACKET        reduce using rule 24 (end -> .)
    RETURN          reduce using rule 24 (end -> .)
    PRINT           reduce using rule 24 (end -> .)
    WHILE           reduce using rule 24 (end -> .)
    FOR             reduce using rule 24 (end -> .)
    IF              reduce using rule 24 (end -> .)
    LBRACKET        reduce using rule 24 (end -> .)
    LPARENT         reduce using rule 24 (end -> .)
    FLOAT           reduce using rule 24 (end -> .)
    CONSTANT        reduce using rule 24 (end -> .)
    VAR             reduce using rule 24 (end -> .)
    UNARYMINUS      reduce using rule 24 (end -> .)
    UNARYPLUS       reduce using rule 24 (end -> .)
    INC             reduce using rule 24 (end -> .)
    DEC             reduce using rule 24 (end -> .)
    NOT             reduce using rule 24 (end -> .)
    BLTIN           reduce using rule 24 (end -> .)
    ELSE            reduce using rule 24 (end -> .)

    end                            shift and go to state 154

state 154

    (20) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .

    NEWLINE         reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    RBRACKET        reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    RETURN          reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    PRINT           reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    WHILE           reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    FOR             reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    IF              reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    LBRACKET        reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    LPARENT         reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    FLOAT           reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    CONSTANT        reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    VAR             reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    UNARYMINUS      reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    UNARYPLUS       reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    INC             reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    DEC             reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    NOT             reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    BLTIN           reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)
    ELSE            reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt end .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPARENT in state 3 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 3 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 3 resolved as shift
WARNING: shift/reduce conflict for VAR in state 3 resolved as shift
WARNING: shift/reduce conflict for UNARYMINUS in state 3 resolved as shift
WARNING: shift/reduce conflict for UNARYPLUS in state 3 resolved as shift
WARNING: shift/reduce conflict for INC in state 3 resolved as shift
WARNING: shift/reduce conflict for DEC in state 3 resolved as shift
WARNING: shift/reduce conflict for NOT in state 3 resolved as shift
WARNING: shift/reduce conflict for BLTIN in state 3 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 13 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 25 resolved as shift
WARNING: shift/reduce conflict for EXP in state 48 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 48 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 48 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 48 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 48 resolved as shift
WARNING: shift/reduce conflict for MOD in state 48 resolved as shift
WARNING: shift/reduce conflict for LT in state 48 resolved as shift
WARNING: shift/reduce conflict for GT in state 48 resolved as shift
WARNING: shift/reduce conflict for LE in state 48 resolved as shift
WARNING: shift/reduce conflict for GE in state 48 resolved as shift
WARNING: shift/reduce conflict for EQ in state 48 resolved as shift
WARNING: shift/reduce conflict for NE in state 48 resolved as shift
WARNING: shift/reduce conflict for OR in state 48 resolved as shift
WARNING: shift/reduce conflict for AND in state 48 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 139 resolved as shift
WARNING: reduce/reduce conflict in state 36 resolved using rule (begin -> <empty>)
WARNING: rejected rule (data -> VAR) in state 36
