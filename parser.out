Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    COS
    LOG
    COSH
    SQRT
    LOG10
    ASIN
    ATAN
    TANH
    SIN
    ERFC
    ACOS
    TAN
    SINH
    INT
    ERF
    ABS

Grammar

Rule 0     S' -> list
Rule 1     list -> empty
Rule 2     list -> list newline
Rule 3     list -> list defn newline
Rule 4     list -> list asgn newline
Rule 5     list -> list stmt newline
Rule 6     list -> list expr newline
Rule 7     list -> list error newline
Rule 8     list -> list COMMENT newline
Rule 9     asgn -> VAR ASSIGN expr
Rule 10    asgn -> VAR ADDEQ expr
Rule 11    asgn -> VAR SUBEQ expr
Rule 12    asgn -> VAR MULEQ expr
Rule 13    asgn -> VAR DIVEQ expr
Rule 14    asgn -> VAR MODEQ expr
Rule 15    stmt -> expr
Rule 16    stmt -> RETURN
Rule 17    stmt -> RETURN expr
Rule 18    stmt -> PRINT prlist
Rule 19    stmt -> WHILE LPARENT cond RPARENT stmt
Rule 20    stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt
Rule 21    stmt -> IF LPARENT cond RPARENT stmt
Rule 22    stmt -> IF LPARENT cond RPARENT stmt ELSE stmt
Rule 23    stmt -> LBRACKET stmtlist RBRACKET
Rule 24    cond -> expr
Rule 25    stmtlist -> empty
Rule 26    stmtlist -> stmtlist newline
Rule 27    stmtlist -> stmtlist stmt
Rule 28    expr -> data
Rule 29    expr -> asgn
Rule 30    expr -> unaryop
Rule 31    expr -> binaryop
Rule 32    expr -> LPARENT expr RPARENT
Rule 33    expr -> callfunc
Rule 34    data -> FLOAT
Rule 35    data -> constant
Rule 36    data -> VAR
Rule 37    unaryop -> UNARYMINUS expr
Rule 38    unaryop -> INC VAR
Rule 39    unaryop -> DEC VAR
Rule 40    unaryop -> VAR INC
Rule 41    unaryop -> VAR DEC
Rule 42    unaryop -> NOT expr
Rule 43    binaryop -> mathop
Rule 44    binaryop -> logicop
Rule 45    mathop -> expr EXP expr
Rule 46    mathop -> expr PLUS expr
Rule 47    mathop -> expr MINUS expr
Rule 48    mathop -> expr TIMES expr
Rule 49    mathop -> expr DIVIDE expr
Rule 50    mathop -> expr MOD expr
Rule 51    logicop -> expr LT expr
Rule 52    logicop -> expr GT expr
Rule 53    logicop -> expr LE expr
Rule 54    logicop -> expr GE expr
Rule 55    logicop -> expr EQ expr
Rule 56    logicop -> expr NE expr
Rule 57    logicop -> expr OR expr
Rule 58    logicop -> expr AND expr
Rule 59    callfunc -> BLTIN LPARENT arglist RPARENT
Rule 60    callfunc -> FUNCTION LPARENT arglist RPARENT
Rule 61    prlist -> expr
Rule 62    prlist -> STRING
Rule 63    prlist -> prlist COMMA expr
Rule 64    prlist -> prlist COMMA STRING
Rule 65    defn -> FUNC procname LPARENT formals RPARENT stmt
Rule 66    procname -> VAR
Rule 67    procname -> FUNCTION
Rule 68    procname -> PROCEDURE
Rule 69    formals -> empty
Rule 70    formals -> VAR
Rule 71    formals -> formals COMMA VAR
Rule 72    arglist -> empty
Rule 73    arglist -> expr
Rule 74    arglist -> arglist COMMA expr
Rule 75    empty -> <empty>
Rule 76    newline -> NEWLINE
Rule 77    constant -> PI
Rule 78    constant -> PHI
Rule 79    constant -> GAMMA
Rule 80    constant -> E
Rule 81    constant -> DEG
Rule 82    constant -> PREC

Terminals, with rules where they appear

ABS                  : 
ACOS                 : 
ADDEQ                : 10
AND                  : 58
ASIN                 : 
ASSIGN               : 9
ATAN                 : 
BLTIN                : 59
COMMA                : 63 64 71 74
COMMENT              : 8
COS                  : 
COSH                 : 
DEC                  : 39 41
DEG                  : 81
DIVEQ                : 13
DIVIDE               : 49
E                    : 80
ELSE                 : 22
EQ                   : 55
ERF                  : 
ERFC                 : 
EXP                  : 45
FLOAT                : 34
FOR                  : 20
FUNC                 : 65
FUNCTION             : 60 67
GAMMA                : 79
GE                   : 54
GT                   : 52
IF                   : 21 22
INC                  : 38 40
INT                  : 
LBRACKET             : 23
LE                   : 53
LOG                  : 
LOG10                : 
LPARENT              : 19 20 21 22 32 59 60 65
LT                   : 51
MINUS                : 47
MOD                  : 50
MODEQ                : 14
MULEQ                : 12
NE                   : 56
NEWLINE              : 76
NOT                  : 42
OR                   : 57
PHI                  : 78
PI                   : 77
PLUS                 : 46
PREC                 : 82
PRINT                : 18
PROCEDURE            : 68
RBRACKET             : 23
RETURN               : 16 17
RPARENT              : 19 20 21 22 32 59 60 65
SEMICOLON            : 20 20
SIN                  : 
SINH                 : 
SQRT                 : 
STRING               : 62 64
SUBEQ                : 11
TAN                  : 
TANH                 : 
TIMES                : 48
UNARYMINUS           : 37
VAR                  : 9 10 11 12 13 14 36 38 39 40 41 66 70 71
WHILE                : 19
error                : 7

Nonterminals, with rules where they appear

arglist              : 59 60 74
asgn                 : 4 29
binaryop             : 31
callfunc             : 33
cond                 : 19 20 20 20 21 22
constant             : 35
data                 : 28
defn                 : 3
empty                : 1 25 69 72
expr                 : 6 9 10 11 12 13 14 15 17 24 32 37 42 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 61 63 73 74
formals              : 65 71
list                 : 2 3 4 5 6 7 8 0
logicop              : 44
mathop               : 43
newline              : 2 3 4 5 6 7 8 26
prlist               : 18 63 64
procname             : 65
stmt                 : 5 19 20 21 22 22 27 65
stmtlist             : 23 26 27
unaryop              : 30

Parsing method: LALR

state 0

    (0) S' -> . list
    (1) list -> . empty
    (2) list -> . list newline
    (3) list -> . list defn newline
    (4) list -> . list asgn newline
    (5) list -> . list stmt newline
    (6) list -> . list expr newline
    (7) list -> . list error newline
    (8) list -> . list COMMENT newline
    (75) empty -> .

    error           reduce using rule 75 (empty -> .)
    COMMENT         reduce using rule 75 (empty -> .)
    NEWLINE         reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)
    VAR             reduce using rule 75 (empty -> .)
    RETURN          reduce using rule 75 (empty -> .)
    PRINT           reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FOR             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    LBRACKET        reduce using rule 75 (empty -> .)
    LPARENT         reduce using rule 75 (empty -> .)
    FLOAT           reduce using rule 75 (empty -> .)
    UNARYMINUS      reduce using rule 75 (empty -> .)
    INC             reduce using rule 75 (empty -> .)
    DEC             reduce using rule 75 (empty -> .)
    NOT             reduce using rule 75 (empty -> .)
    BLTIN           reduce using rule 75 (empty -> .)
    FUNCTION        reduce using rule 75 (empty -> .)
    PI              reduce using rule 75 (empty -> .)
    PHI             reduce using rule 75 (empty -> .)
    GAMMA           reduce using rule 75 (empty -> .)
    E               reduce using rule 75 (empty -> .)
    DEG             reduce using rule 75 (empty -> .)
    PREC            reduce using rule 75 (empty -> .)
    $end            reduce using rule 75 (empty -> .)

    list                           shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> list .
    (2) list -> list . newline
    (3) list -> list . defn newline
    (4) list -> list . asgn newline
    (5) list -> list . stmt newline
    (6) list -> list . expr newline
    (7) list -> list . error newline
    (8) list -> list . COMMENT newline
    (76) newline -> . NEWLINE
    (65) defn -> . FUNC procname LPARENT formals RPARENT stmt
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (15) stmt -> . expr
    (16) stmt -> . RETURN
    (17) stmt -> . RETURN expr
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt
    (21) stmt -> . IF LPARENT cond RPARENT stmt
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    error           shift and go to state 37
    COMMENT         shift and go to state 12
    NEWLINE         shift and go to state 14
    FUNC            shift and go to state 24
    VAR             shift and go to state 25
    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 19
    IF              shift and go to state 28
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    binaryop                       shift and go to state 36
    unaryop                        shift and go to state 20
    expr                           shift and go to state 30
    callfunc                       shift and go to state 31
    newline                        shift and go to state 21
    stmt                           shift and go to state 22
    asgn                           shift and go to state 15
    mathop                         shift and go to state 35
    logicop                        shift and go to state 9
    data                           shift and go to state 26
    defn                           shift and go to state 27

state 2

    (1) list -> empty .

    error           reduce using rule 1 (list -> empty .)
    COMMENT         reduce using rule 1 (list -> empty .)
    NEWLINE         reduce using rule 1 (list -> empty .)
    FUNC            reduce using rule 1 (list -> empty .)
    VAR             reduce using rule 1 (list -> empty .)
    RETURN          reduce using rule 1 (list -> empty .)
    PRINT           reduce using rule 1 (list -> empty .)
    WHILE           reduce using rule 1 (list -> empty .)
    FOR             reduce using rule 1 (list -> empty .)
    IF              reduce using rule 1 (list -> empty .)
    LBRACKET        reduce using rule 1 (list -> empty .)
    LPARENT         reduce using rule 1 (list -> empty .)
    FLOAT           reduce using rule 1 (list -> empty .)
    UNARYMINUS      reduce using rule 1 (list -> empty .)
    INC             reduce using rule 1 (list -> empty .)
    DEC             reduce using rule 1 (list -> empty .)
    NOT             reduce using rule 1 (list -> empty .)
    BLTIN           reduce using rule 1 (list -> empty .)
    FUNCTION        reduce using rule 1 (list -> empty .)
    PI              reduce using rule 1 (list -> empty .)
    PHI             reduce using rule 1 (list -> empty .)
    GAMMA           reduce using rule 1 (list -> empty .)
    E               reduce using rule 1 (list -> empty .)
    DEG             reduce using rule 1 (list -> empty .)
    PREC            reduce using rule 1 (list -> empty .)
    $end            reduce using rule 1 (list -> empty .)


state 3

    (16) stmt -> RETURN .
    (17) stmt -> RETURN . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

  ! shift/reduce conflict for LPARENT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for UNARYMINUS resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for BLTIN resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PI resolved as shift
  ! shift/reduce conflict for PHI resolved as shift
  ! shift/reduce conflict for GAMMA resolved as shift
  ! shift/reduce conflict for E resolved as shift
  ! shift/reduce conflict for DEG resolved as shift
  ! shift/reduce conflict for PREC resolved as shift
    NEWLINE         reduce using rule 16 (stmt -> RETURN .)
    RBRACKET        reduce using rule 16 (stmt -> RETURN .)
    RETURN          reduce using rule 16 (stmt -> RETURN .)
    PRINT           reduce using rule 16 (stmt -> RETURN .)
    WHILE           reduce using rule 16 (stmt -> RETURN .)
    FOR             reduce using rule 16 (stmt -> RETURN .)
    IF              reduce using rule 16 (stmt -> RETURN .)
    LBRACKET        reduce using rule 16 (stmt -> RETURN .)
    ELSE            reduce using rule 16 (stmt -> RETURN .)
    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

  ! LPARENT         [ reduce using rule 16 (stmt -> RETURN .) ]
  ! FLOAT           [ reduce using rule 16 (stmt -> RETURN .) ]
  ! VAR             [ reduce using rule 16 (stmt -> RETURN .) ]
  ! UNARYMINUS      [ reduce using rule 16 (stmt -> RETURN .) ]
  ! INC             [ reduce using rule 16 (stmt -> RETURN .) ]
  ! DEC             [ reduce using rule 16 (stmt -> RETURN .) ]
  ! NOT             [ reduce using rule 16 (stmt -> RETURN .) ]
  ! BLTIN           [ reduce using rule 16 (stmt -> RETURN .) ]
  ! FUNCTION        [ reduce using rule 16 (stmt -> RETURN .) ]
  ! PI              [ reduce using rule 16 (stmt -> RETURN .) ]
  ! PHI             [ reduce using rule 16 (stmt -> RETURN .) ]
  ! GAMMA           [ reduce using rule 16 (stmt -> RETURN .) ]
  ! E               [ reduce using rule 16 (stmt -> RETURN .) ]
  ! DEG             [ reduce using rule 16 (stmt -> RETURN .) ]
  ! PREC            [ reduce using rule 16 (stmt -> RETURN .) ]

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 42
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 4

    (23) stmt -> LBRACKET . stmtlist RBRACKET
    (25) stmtlist -> . empty
    (26) stmtlist -> . stmtlist newline
    (27) stmtlist -> . stmtlist stmt
    (75) empty -> .

    RBRACKET        reduce using rule 75 (empty -> .)
    NEWLINE         reduce using rule 75 (empty -> .)
    RETURN          reduce using rule 75 (empty -> .)
    PRINT           reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FOR             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    LBRACKET        reduce using rule 75 (empty -> .)
    LPARENT         reduce using rule 75 (empty -> .)
    FLOAT           reduce using rule 75 (empty -> .)
    VAR             reduce using rule 75 (empty -> .)
    UNARYMINUS      reduce using rule 75 (empty -> .)
    INC             reduce using rule 75 (empty -> .)
    DEC             reduce using rule 75 (empty -> .)
    NOT             reduce using rule 75 (empty -> .)
    BLTIN           reduce using rule 75 (empty -> .)
    FUNCTION        reduce using rule 75 (empty -> .)
    PI              reduce using rule 75 (empty -> .)
    PHI             reduce using rule 75 (empty -> .)
    GAMMA           reduce using rule 75 (empty -> .)
    E               reduce using rule 75 (empty -> .)
    DEG             reduce using rule 75 (empty -> .)
    PREC            reduce using rule 75 (empty -> .)

    empty                          shift and go to state 44
    stmtlist                       shift and go to state 43

state 5

    (19) stmt -> WHILE . LPARENT cond RPARENT stmt

    LPARENT         shift and go to state 45


state 6

    (18) stmt -> PRINT . prlist
    (61) prlist -> . expr
    (62) prlist -> . STRING
    (63) prlist -> . prlist COMMA expr
    (64) prlist -> . prlist COMMA STRING
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    STRING          shift and go to state 46
    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 47
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    prlist                         shift and go to state 48
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 7

    (35) data -> constant .

    EXP             reduce using rule 35 (data -> constant .)
    PLUS            reduce using rule 35 (data -> constant .)
    MINUS           reduce using rule 35 (data -> constant .)
    TIMES           reduce using rule 35 (data -> constant .)
    DIVIDE          reduce using rule 35 (data -> constant .)
    MOD             reduce using rule 35 (data -> constant .)
    LT              reduce using rule 35 (data -> constant .)
    GT              reduce using rule 35 (data -> constant .)
    LE              reduce using rule 35 (data -> constant .)
    GE              reduce using rule 35 (data -> constant .)
    EQ              reduce using rule 35 (data -> constant .)
    NE              reduce using rule 35 (data -> constant .)
    OR              reduce using rule 35 (data -> constant .)
    AND             reduce using rule 35 (data -> constant .)
    SEMICOLON       reduce using rule 35 (data -> constant .)
    NEWLINE         reduce using rule 35 (data -> constant .)
    RBRACKET        reduce using rule 35 (data -> constant .)
    RETURN          reduce using rule 35 (data -> constant .)
    PRINT           reduce using rule 35 (data -> constant .)
    WHILE           reduce using rule 35 (data -> constant .)
    FOR             reduce using rule 35 (data -> constant .)
    IF              reduce using rule 35 (data -> constant .)
    LBRACKET        reduce using rule 35 (data -> constant .)
    LPARENT         reduce using rule 35 (data -> constant .)
    FLOAT           reduce using rule 35 (data -> constant .)
    VAR             reduce using rule 35 (data -> constant .)
    UNARYMINUS      reduce using rule 35 (data -> constant .)
    INC             reduce using rule 35 (data -> constant .)
    DEC             reduce using rule 35 (data -> constant .)
    NOT             reduce using rule 35 (data -> constant .)
    BLTIN           reduce using rule 35 (data -> constant .)
    FUNCTION        reduce using rule 35 (data -> constant .)
    PI              reduce using rule 35 (data -> constant .)
    PHI             reduce using rule 35 (data -> constant .)
    GAMMA           reduce using rule 35 (data -> constant .)
    E               reduce using rule 35 (data -> constant .)
    DEG             reduce using rule 35 (data -> constant .)
    PREC            reduce using rule 35 (data -> constant .)
    ELSE            reduce using rule 35 (data -> constant .)
    COMMA           reduce using rule 35 (data -> constant .)
    RPARENT         reduce using rule 35 (data -> constant .)


state 8

    (39) unaryop -> DEC . VAR

    VAR             shift and go to state 49


state 9

    (44) binaryop -> logicop .

    EXP             reduce using rule 44 (binaryop -> logicop .)
    PLUS            reduce using rule 44 (binaryop -> logicop .)
    MINUS           reduce using rule 44 (binaryop -> logicop .)
    TIMES           reduce using rule 44 (binaryop -> logicop .)
    DIVIDE          reduce using rule 44 (binaryop -> logicop .)
    MOD             reduce using rule 44 (binaryop -> logicop .)
    LT              reduce using rule 44 (binaryop -> logicop .)
    GT              reduce using rule 44 (binaryop -> logicop .)
    LE              reduce using rule 44 (binaryop -> logicop .)
    GE              reduce using rule 44 (binaryop -> logicop .)
    EQ              reduce using rule 44 (binaryop -> logicop .)
    NE              reduce using rule 44 (binaryop -> logicop .)
    OR              reduce using rule 44 (binaryop -> logicop .)
    AND             reduce using rule 44 (binaryop -> logicop .)
    NEWLINE         reduce using rule 44 (binaryop -> logicop .)
    RBRACKET        reduce using rule 44 (binaryop -> logicop .)
    RETURN          reduce using rule 44 (binaryop -> logicop .)
    PRINT           reduce using rule 44 (binaryop -> logicop .)
    WHILE           reduce using rule 44 (binaryop -> logicop .)
    FOR             reduce using rule 44 (binaryop -> logicop .)
    IF              reduce using rule 44 (binaryop -> logicop .)
    LBRACKET        reduce using rule 44 (binaryop -> logicop .)
    LPARENT         reduce using rule 44 (binaryop -> logicop .)
    FLOAT           reduce using rule 44 (binaryop -> logicop .)
    VAR             reduce using rule 44 (binaryop -> logicop .)
    UNARYMINUS      reduce using rule 44 (binaryop -> logicop .)
    INC             reduce using rule 44 (binaryop -> logicop .)
    DEC             reduce using rule 44 (binaryop -> logicop .)
    NOT             reduce using rule 44 (binaryop -> logicop .)
    BLTIN           reduce using rule 44 (binaryop -> logicop .)
    FUNCTION        reduce using rule 44 (binaryop -> logicop .)
    PI              reduce using rule 44 (binaryop -> logicop .)
    PHI             reduce using rule 44 (binaryop -> logicop .)
    GAMMA           reduce using rule 44 (binaryop -> logicop .)
    E               reduce using rule 44 (binaryop -> logicop .)
    DEG             reduce using rule 44 (binaryop -> logicop .)
    PREC            reduce using rule 44 (binaryop -> logicop .)
    ELSE            reduce using rule 44 (binaryop -> logicop .)
    COMMA           reduce using rule 44 (binaryop -> logicop .)
    RPARENT         reduce using rule 44 (binaryop -> logicop .)
    SEMICOLON       reduce using rule 44 (binaryop -> logicop .)


state 10

    (79) constant -> GAMMA .

    EXP             reduce using rule 79 (constant -> GAMMA .)
    PLUS            reduce using rule 79 (constant -> GAMMA .)
    MINUS           reduce using rule 79 (constant -> GAMMA .)
    TIMES           reduce using rule 79 (constant -> GAMMA .)
    DIVIDE          reduce using rule 79 (constant -> GAMMA .)
    MOD             reduce using rule 79 (constant -> GAMMA .)
    LT              reduce using rule 79 (constant -> GAMMA .)
    GT              reduce using rule 79 (constant -> GAMMA .)
    LE              reduce using rule 79 (constant -> GAMMA .)
    GE              reduce using rule 79 (constant -> GAMMA .)
    EQ              reduce using rule 79 (constant -> GAMMA .)
    NE              reduce using rule 79 (constant -> GAMMA .)
    OR              reduce using rule 79 (constant -> GAMMA .)
    AND             reduce using rule 79 (constant -> GAMMA .)
    RPARENT         reduce using rule 79 (constant -> GAMMA .)
    COMMA           reduce using rule 79 (constant -> GAMMA .)
    RBRACKET        reduce using rule 79 (constant -> GAMMA .)
    NEWLINE         reduce using rule 79 (constant -> GAMMA .)
    RETURN          reduce using rule 79 (constant -> GAMMA .)
    PRINT           reduce using rule 79 (constant -> GAMMA .)
    WHILE           reduce using rule 79 (constant -> GAMMA .)
    FOR             reduce using rule 79 (constant -> GAMMA .)
    IF              reduce using rule 79 (constant -> GAMMA .)
    LBRACKET        reduce using rule 79 (constant -> GAMMA .)
    LPARENT         reduce using rule 79 (constant -> GAMMA .)
    FLOAT           reduce using rule 79 (constant -> GAMMA .)
    VAR             reduce using rule 79 (constant -> GAMMA .)
    UNARYMINUS      reduce using rule 79 (constant -> GAMMA .)
    INC             reduce using rule 79 (constant -> GAMMA .)
    DEC             reduce using rule 79 (constant -> GAMMA .)
    NOT             reduce using rule 79 (constant -> GAMMA .)
    BLTIN           reduce using rule 79 (constant -> GAMMA .)
    FUNCTION        reduce using rule 79 (constant -> GAMMA .)
    PI              reduce using rule 79 (constant -> GAMMA .)
    PHI             reduce using rule 79 (constant -> GAMMA .)
    GAMMA           reduce using rule 79 (constant -> GAMMA .)
    E               reduce using rule 79 (constant -> GAMMA .)
    DEG             reduce using rule 79 (constant -> GAMMA .)
    PREC            reduce using rule 79 (constant -> GAMMA .)
    ELSE            reduce using rule 79 (constant -> GAMMA .)
    SEMICOLON       reduce using rule 79 (constant -> GAMMA .)


state 11

    (81) constant -> DEG .

    EXP             reduce using rule 81 (constant -> DEG .)
    PLUS            reduce using rule 81 (constant -> DEG .)
    MINUS           reduce using rule 81 (constant -> DEG .)
    TIMES           reduce using rule 81 (constant -> DEG .)
    DIVIDE          reduce using rule 81 (constant -> DEG .)
    MOD             reduce using rule 81 (constant -> DEG .)
    LT              reduce using rule 81 (constant -> DEG .)
    GT              reduce using rule 81 (constant -> DEG .)
    LE              reduce using rule 81 (constant -> DEG .)
    GE              reduce using rule 81 (constant -> DEG .)
    EQ              reduce using rule 81 (constant -> DEG .)
    NE              reduce using rule 81 (constant -> DEG .)
    OR              reduce using rule 81 (constant -> DEG .)
    AND             reduce using rule 81 (constant -> DEG .)
    RPARENT         reduce using rule 81 (constant -> DEG .)
    COMMA           reduce using rule 81 (constant -> DEG .)
    RBRACKET        reduce using rule 81 (constant -> DEG .)
    NEWLINE         reduce using rule 81 (constant -> DEG .)
    RETURN          reduce using rule 81 (constant -> DEG .)
    PRINT           reduce using rule 81 (constant -> DEG .)
    WHILE           reduce using rule 81 (constant -> DEG .)
    FOR             reduce using rule 81 (constant -> DEG .)
    IF              reduce using rule 81 (constant -> DEG .)
    LBRACKET        reduce using rule 81 (constant -> DEG .)
    LPARENT         reduce using rule 81 (constant -> DEG .)
    FLOAT           reduce using rule 81 (constant -> DEG .)
    VAR             reduce using rule 81 (constant -> DEG .)
    UNARYMINUS      reduce using rule 81 (constant -> DEG .)
    INC             reduce using rule 81 (constant -> DEG .)
    DEC             reduce using rule 81 (constant -> DEG .)
    NOT             reduce using rule 81 (constant -> DEG .)
    BLTIN           reduce using rule 81 (constant -> DEG .)
    FUNCTION        reduce using rule 81 (constant -> DEG .)
    PI              reduce using rule 81 (constant -> DEG .)
    PHI             reduce using rule 81 (constant -> DEG .)
    GAMMA           reduce using rule 81 (constant -> DEG .)
    E               reduce using rule 81 (constant -> DEG .)
    DEG             reduce using rule 81 (constant -> DEG .)
    PREC            reduce using rule 81 (constant -> DEG .)
    ELSE            reduce using rule 81 (constant -> DEG .)
    SEMICOLON       reduce using rule 81 (constant -> DEG .)


state 12

    (8) list -> list COMMENT . newline
    (76) newline -> . NEWLINE

    NEWLINE         shift and go to state 14

    newline                        shift and go to state 50

state 13

    (32) expr -> LPARENT . expr RPARENT
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 51
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 14

    (76) newline -> NEWLINE .

    RBRACKET        reduce using rule 76 (newline -> NEWLINE .)
    NEWLINE         reduce using rule 76 (newline -> NEWLINE .)
    RETURN          reduce using rule 76 (newline -> NEWLINE .)
    PRINT           reduce using rule 76 (newline -> NEWLINE .)
    WHILE           reduce using rule 76 (newline -> NEWLINE .)
    FOR             reduce using rule 76 (newline -> NEWLINE .)
    IF              reduce using rule 76 (newline -> NEWLINE .)
    LBRACKET        reduce using rule 76 (newline -> NEWLINE .)
    LPARENT         reduce using rule 76 (newline -> NEWLINE .)
    FLOAT           reduce using rule 76 (newline -> NEWLINE .)
    VAR             reduce using rule 76 (newline -> NEWLINE .)
    UNARYMINUS      reduce using rule 76 (newline -> NEWLINE .)
    INC             reduce using rule 76 (newline -> NEWLINE .)
    DEC             reduce using rule 76 (newline -> NEWLINE .)
    NOT             reduce using rule 76 (newline -> NEWLINE .)
    BLTIN           reduce using rule 76 (newline -> NEWLINE .)
    FUNCTION        reduce using rule 76 (newline -> NEWLINE .)
    PI              reduce using rule 76 (newline -> NEWLINE .)
    PHI             reduce using rule 76 (newline -> NEWLINE .)
    GAMMA           reduce using rule 76 (newline -> NEWLINE .)
    E               reduce using rule 76 (newline -> NEWLINE .)
    DEG             reduce using rule 76 (newline -> NEWLINE .)
    PREC            reduce using rule 76 (newline -> NEWLINE .)
    error           reduce using rule 76 (newline -> NEWLINE .)
    COMMENT         reduce using rule 76 (newline -> NEWLINE .)
    FUNC            reduce using rule 76 (newline -> NEWLINE .)
    $end            reduce using rule 76 (newline -> NEWLINE .)


state 15

    (4) list -> list asgn . newline
    (29) expr -> asgn .
    (76) newline -> . NEWLINE

  ! shift/reduce conflict for NEWLINE resolved as shift
    EXP             reduce using rule 29 (expr -> asgn .)
    PLUS            reduce using rule 29 (expr -> asgn .)
    MINUS           reduce using rule 29 (expr -> asgn .)
    TIMES           reduce using rule 29 (expr -> asgn .)
    DIVIDE          reduce using rule 29 (expr -> asgn .)
    MOD             reduce using rule 29 (expr -> asgn .)
    LT              reduce using rule 29 (expr -> asgn .)
    GT              reduce using rule 29 (expr -> asgn .)
    LE              reduce using rule 29 (expr -> asgn .)
    GE              reduce using rule 29 (expr -> asgn .)
    EQ              reduce using rule 29 (expr -> asgn .)
    NE              reduce using rule 29 (expr -> asgn .)
    OR              reduce using rule 29 (expr -> asgn .)
    AND             reduce using rule 29 (expr -> asgn .)
    NEWLINE         shift and go to state 14

  ! NEWLINE         [ reduce using rule 29 (expr -> asgn .) ]

    newline                        shift and go to state 52

state 16

    (77) constant -> PI .

    EXP             reduce using rule 77 (constant -> PI .)
    PLUS            reduce using rule 77 (constant -> PI .)
    MINUS           reduce using rule 77 (constant -> PI .)
    TIMES           reduce using rule 77 (constant -> PI .)
    DIVIDE          reduce using rule 77 (constant -> PI .)
    MOD             reduce using rule 77 (constant -> PI .)
    LT              reduce using rule 77 (constant -> PI .)
    GT              reduce using rule 77 (constant -> PI .)
    LE              reduce using rule 77 (constant -> PI .)
    GE              reduce using rule 77 (constant -> PI .)
    EQ              reduce using rule 77 (constant -> PI .)
    NE              reduce using rule 77 (constant -> PI .)
    OR              reduce using rule 77 (constant -> PI .)
    AND             reduce using rule 77 (constant -> PI .)
    RPARENT         reduce using rule 77 (constant -> PI .)
    COMMA           reduce using rule 77 (constant -> PI .)
    RBRACKET        reduce using rule 77 (constant -> PI .)
    NEWLINE         reduce using rule 77 (constant -> PI .)
    RETURN          reduce using rule 77 (constant -> PI .)
    PRINT           reduce using rule 77 (constant -> PI .)
    WHILE           reduce using rule 77 (constant -> PI .)
    FOR             reduce using rule 77 (constant -> PI .)
    IF              reduce using rule 77 (constant -> PI .)
    LBRACKET        reduce using rule 77 (constant -> PI .)
    LPARENT         reduce using rule 77 (constant -> PI .)
    FLOAT           reduce using rule 77 (constant -> PI .)
    VAR             reduce using rule 77 (constant -> PI .)
    UNARYMINUS      reduce using rule 77 (constant -> PI .)
    INC             reduce using rule 77 (constant -> PI .)
    DEC             reduce using rule 77 (constant -> PI .)
    NOT             reduce using rule 77 (constant -> PI .)
    BLTIN           reduce using rule 77 (constant -> PI .)
    FUNCTION        reduce using rule 77 (constant -> PI .)
    PI              reduce using rule 77 (constant -> PI .)
    PHI             reduce using rule 77 (constant -> PI .)
    GAMMA           reduce using rule 77 (constant -> PI .)
    E               reduce using rule 77 (constant -> PI .)
    DEG             reduce using rule 77 (constant -> PI .)
    PREC            reduce using rule 77 (constant -> PI .)
    ELSE            reduce using rule 77 (constant -> PI .)
    SEMICOLON       reduce using rule 77 (constant -> PI .)


state 17

    (60) callfunc -> FUNCTION . LPARENT arglist RPARENT

    LPARENT         shift and go to state 53


state 18

    (80) constant -> E .

    EXP             reduce using rule 80 (constant -> E .)
    PLUS            reduce using rule 80 (constant -> E .)
    MINUS           reduce using rule 80 (constant -> E .)
    TIMES           reduce using rule 80 (constant -> E .)
    DIVIDE          reduce using rule 80 (constant -> E .)
    MOD             reduce using rule 80 (constant -> E .)
    LT              reduce using rule 80 (constant -> E .)
    GT              reduce using rule 80 (constant -> E .)
    LE              reduce using rule 80 (constant -> E .)
    GE              reduce using rule 80 (constant -> E .)
    EQ              reduce using rule 80 (constant -> E .)
    NE              reduce using rule 80 (constant -> E .)
    OR              reduce using rule 80 (constant -> E .)
    AND             reduce using rule 80 (constant -> E .)
    RPARENT         reduce using rule 80 (constant -> E .)
    COMMA           reduce using rule 80 (constant -> E .)
    RBRACKET        reduce using rule 80 (constant -> E .)
    NEWLINE         reduce using rule 80 (constant -> E .)
    RETURN          reduce using rule 80 (constant -> E .)
    PRINT           reduce using rule 80 (constant -> E .)
    WHILE           reduce using rule 80 (constant -> E .)
    FOR             reduce using rule 80 (constant -> E .)
    IF              reduce using rule 80 (constant -> E .)
    LBRACKET        reduce using rule 80 (constant -> E .)
    LPARENT         reduce using rule 80 (constant -> E .)
    FLOAT           reduce using rule 80 (constant -> E .)
    VAR             reduce using rule 80 (constant -> E .)
    UNARYMINUS      reduce using rule 80 (constant -> E .)
    INC             reduce using rule 80 (constant -> E .)
    DEC             reduce using rule 80 (constant -> E .)
    NOT             reduce using rule 80 (constant -> E .)
    BLTIN           reduce using rule 80 (constant -> E .)
    FUNCTION        reduce using rule 80 (constant -> E .)
    PI              reduce using rule 80 (constant -> E .)
    PHI             reduce using rule 80 (constant -> E .)
    GAMMA           reduce using rule 80 (constant -> E .)
    E               reduce using rule 80 (constant -> E .)
    DEG             reduce using rule 80 (constant -> E .)
    PREC            reduce using rule 80 (constant -> E .)
    ELSE            reduce using rule 80 (constant -> E .)
    SEMICOLON       reduce using rule 80 (constant -> E .)


state 19

    (20) stmt -> FOR . LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt

    LPARENT         shift and go to state 54


state 20

    (30) expr -> unaryop .

    EXP             reduce using rule 30 (expr -> unaryop .)
    PLUS            reduce using rule 30 (expr -> unaryop .)
    MINUS           reduce using rule 30 (expr -> unaryop .)
    TIMES           reduce using rule 30 (expr -> unaryop .)
    DIVIDE          reduce using rule 30 (expr -> unaryop .)
    MOD             reduce using rule 30 (expr -> unaryop .)
    LT              reduce using rule 30 (expr -> unaryop .)
    GT              reduce using rule 30 (expr -> unaryop .)
    LE              reduce using rule 30 (expr -> unaryop .)
    GE              reduce using rule 30 (expr -> unaryop .)
    EQ              reduce using rule 30 (expr -> unaryop .)
    NE              reduce using rule 30 (expr -> unaryop .)
    OR              reduce using rule 30 (expr -> unaryop .)
    AND             reduce using rule 30 (expr -> unaryop .)
    NEWLINE         reduce using rule 30 (expr -> unaryop .)
    RBRACKET        reduce using rule 30 (expr -> unaryop .)
    RETURN          reduce using rule 30 (expr -> unaryop .)
    PRINT           reduce using rule 30 (expr -> unaryop .)
    WHILE           reduce using rule 30 (expr -> unaryop .)
    FOR             reduce using rule 30 (expr -> unaryop .)
    IF              reduce using rule 30 (expr -> unaryop .)
    LBRACKET        reduce using rule 30 (expr -> unaryop .)
    LPARENT         reduce using rule 30 (expr -> unaryop .)
    FLOAT           reduce using rule 30 (expr -> unaryop .)
    VAR             reduce using rule 30 (expr -> unaryop .)
    UNARYMINUS      reduce using rule 30 (expr -> unaryop .)
    INC             reduce using rule 30 (expr -> unaryop .)
    DEC             reduce using rule 30 (expr -> unaryop .)
    NOT             reduce using rule 30 (expr -> unaryop .)
    BLTIN           reduce using rule 30 (expr -> unaryop .)
    FUNCTION        reduce using rule 30 (expr -> unaryop .)
    PI              reduce using rule 30 (expr -> unaryop .)
    PHI             reduce using rule 30 (expr -> unaryop .)
    GAMMA           reduce using rule 30 (expr -> unaryop .)
    E               reduce using rule 30 (expr -> unaryop .)
    DEG             reduce using rule 30 (expr -> unaryop .)
    PREC            reduce using rule 30 (expr -> unaryop .)
    ELSE            reduce using rule 30 (expr -> unaryop .)
    COMMA           reduce using rule 30 (expr -> unaryop .)
    RPARENT         reduce using rule 30 (expr -> unaryop .)
    SEMICOLON       reduce using rule 30 (expr -> unaryop .)


state 21

    (2) list -> list newline .

    error           reduce using rule 2 (list -> list newline .)
    COMMENT         reduce using rule 2 (list -> list newline .)
    NEWLINE         reduce using rule 2 (list -> list newline .)
    FUNC            reduce using rule 2 (list -> list newline .)
    VAR             reduce using rule 2 (list -> list newline .)
    RETURN          reduce using rule 2 (list -> list newline .)
    PRINT           reduce using rule 2 (list -> list newline .)
    WHILE           reduce using rule 2 (list -> list newline .)
    FOR             reduce using rule 2 (list -> list newline .)
    IF              reduce using rule 2 (list -> list newline .)
    LBRACKET        reduce using rule 2 (list -> list newline .)
    LPARENT         reduce using rule 2 (list -> list newline .)
    FLOAT           reduce using rule 2 (list -> list newline .)
    UNARYMINUS      reduce using rule 2 (list -> list newline .)
    INC             reduce using rule 2 (list -> list newline .)
    DEC             reduce using rule 2 (list -> list newline .)
    NOT             reduce using rule 2 (list -> list newline .)
    BLTIN           reduce using rule 2 (list -> list newline .)
    FUNCTION        reduce using rule 2 (list -> list newline .)
    PI              reduce using rule 2 (list -> list newline .)
    PHI             reduce using rule 2 (list -> list newline .)
    GAMMA           reduce using rule 2 (list -> list newline .)
    E               reduce using rule 2 (list -> list newline .)
    DEG             reduce using rule 2 (list -> list newline .)
    PREC            reduce using rule 2 (list -> list newline .)
    $end            reduce using rule 2 (list -> list newline .)


state 22

    (5) list -> list stmt . newline
    (76) newline -> . NEWLINE

    NEWLINE         shift and go to state 14

    newline                        shift and go to state 55

state 23

    (59) callfunc -> BLTIN . LPARENT arglist RPARENT

    LPARENT         shift and go to state 56


state 24

    (65) defn -> FUNC . procname LPARENT formals RPARENT stmt
    (66) procname -> . VAR
    (67) procname -> . FUNCTION
    (68) procname -> . PROCEDURE

    VAR             shift and go to state 59
    FUNCTION        shift and go to state 57
    PROCEDURE       shift and go to state 60

    procname                       shift and go to state 58

state 25

    (9) asgn -> VAR . ASSIGN expr
    (10) asgn -> VAR . ADDEQ expr
    (11) asgn -> VAR . SUBEQ expr
    (12) asgn -> VAR . MULEQ expr
    (13) asgn -> VAR . DIVEQ expr
    (14) asgn -> VAR . MODEQ expr
    (36) data -> VAR .
    (40) unaryop -> VAR . INC
    (41) unaryop -> VAR . DEC

    ASSIGN          shift and go to state 66
    ADDEQ           shift and go to state 64
    SUBEQ           shift and go to state 62
    MULEQ           shift and go to state 63
    DIVEQ           shift and go to state 67
    MODEQ           shift and go to state 61
    EXP             reduce using rule 36 (data -> VAR .)
    PLUS            reduce using rule 36 (data -> VAR .)
    MINUS           reduce using rule 36 (data -> VAR .)
    TIMES           reduce using rule 36 (data -> VAR .)
    DIVIDE          reduce using rule 36 (data -> VAR .)
    MOD             reduce using rule 36 (data -> VAR .)
    LT              reduce using rule 36 (data -> VAR .)
    GT              reduce using rule 36 (data -> VAR .)
    LE              reduce using rule 36 (data -> VAR .)
    GE              reduce using rule 36 (data -> VAR .)
    EQ              reduce using rule 36 (data -> VAR .)
    NE              reduce using rule 36 (data -> VAR .)
    OR              reduce using rule 36 (data -> VAR .)
    AND             reduce using rule 36 (data -> VAR .)
    NEWLINE         reduce using rule 36 (data -> VAR .)
    INC             shift and go to state 68
    DEC             shift and go to state 65


state 26

    (28) expr -> data .

    EXP             reduce using rule 28 (expr -> data .)
    PLUS            reduce using rule 28 (expr -> data .)
    MINUS           reduce using rule 28 (expr -> data .)
    TIMES           reduce using rule 28 (expr -> data .)
    DIVIDE          reduce using rule 28 (expr -> data .)
    MOD             reduce using rule 28 (expr -> data .)
    LT              reduce using rule 28 (expr -> data .)
    GT              reduce using rule 28 (expr -> data .)
    LE              reduce using rule 28 (expr -> data .)
    GE              reduce using rule 28 (expr -> data .)
    EQ              reduce using rule 28 (expr -> data .)
    NE              reduce using rule 28 (expr -> data .)
    OR              reduce using rule 28 (expr -> data .)
    AND             reduce using rule 28 (expr -> data .)
    NEWLINE         reduce using rule 28 (expr -> data .)
    RBRACKET        reduce using rule 28 (expr -> data .)
    RETURN          reduce using rule 28 (expr -> data .)
    PRINT           reduce using rule 28 (expr -> data .)
    WHILE           reduce using rule 28 (expr -> data .)
    FOR             reduce using rule 28 (expr -> data .)
    IF              reduce using rule 28 (expr -> data .)
    LBRACKET        reduce using rule 28 (expr -> data .)
    LPARENT         reduce using rule 28 (expr -> data .)
    FLOAT           reduce using rule 28 (expr -> data .)
    VAR             reduce using rule 28 (expr -> data .)
    UNARYMINUS      reduce using rule 28 (expr -> data .)
    INC             reduce using rule 28 (expr -> data .)
    DEC             reduce using rule 28 (expr -> data .)
    NOT             reduce using rule 28 (expr -> data .)
    BLTIN           reduce using rule 28 (expr -> data .)
    FUNCTION        reduce using rule 28 (expr -> data .)
    PI              reduce using rule 28 (expr -> data .)
    PHI             reduce using rule 28 (expr -> data .)
    GAMMA           reduce using rule 28 (expr -> data .)
    E               reduce using rule 28 (expr -> data .)
    DEG             reduce using rule 28 (expr -> data .)
    PREC            reduce using rule 28 (expr -> data .)
    ELSE            reduce using rule 28 (expr -> data .)
    COMMA           reduce using rule 28 (expr -> data .)
    RPARENT         reduce using rule 28 (expr -> data .)
    SEMICOLON       reduce using rule 28 (expr -> data .)


state 27

    (3) list -> list defn . newline
    (76) newline -> . NEWLINE

    NEWLINE         shift and go to state 14

    newline                        shift and go to state 69

state 28

    (21) stmt -> IF . LPARENT cond RPARENT stmt
    (22) stmt -> IF . LPARENT cond RPARENT stmt ELSE stmt

    LPARENT         shift and go to state 70


state 29

    (78) constant -> PHI .

    EXP             reduce using rule 78 (constant -> PHI .)
    PLUS            reduce using rule 78 (constant -> PHI .)
    MINUS           reduce using rule 78 (constant -> PHI .)
    TIMES           reduce using rule 78 (constant -> PHI .)
    DIVIDE          reduce using rule 78 (constant -> PHI .)
    MOD             reduce using rule 78 (constant -> PHI .)
    LT              reduce using rule 78 (constant -> PHI .)
    GT              reduce using rule 78 (constant -> PHI .)
    LE              reduce using rule 78 (constant -> PHI .)
    GE              reduce using rule 78 (constant -> PHI .)
    EQ              reduce using rule 78 (constant -> PHI .)
    NE              reduce using rule 78 (constant -> PHI .)
    OR              reduce using rule 78 (constant -> PHI .)
    AND             reduce using rule 78 (constant -> PHI .)
    RPARENT         reduce using rule 78 (constant -> PHI .)
    COMMA           reduce using rule 78 (constant -> PHI .)
    RBRACKET        reduce using rule 78 (constant -> PHI .)
    NEWLINE         reduce using rule 78 (constant -> PHI .)
    RETURN          reduce using rule 78 (constant -> PHI .)
    PRINT           reduce using rule 78 (constant -> PHI .)
    WHILE           reduce using rule 78 (constant -> PHI .)
    FOR             reduce using rule 78 (constant -> PHI .)
    IF              reduce using rule 78 (constant -> PHI .)
    LBRACKET        reduce using rule 78 (constant -> PHI .)
    LPARENT         reduce using rule 78 (constant -> PHI .)
    FLOAT           reduce using rule 78 (constant -> PHI .)
    VAR             reduce using rule 78 (constant -> PHI .)
    UNARYMINUS      reduce using rule 78 (constant -> PHI .)
    INC             reduce using rule 78 (constant -> PHI .)
    DEC             reduce using rule 78 (constant -> PHI .)
    NOT             reduce using rule 78 (constant -> PHI .)
    BLTIN           reduce using rule 78 (constant -> PHI .)
    FUNCTION        reduce using rule 78 (constant -> PHI .)
    PI              reduce using rule 78 (constant -> PHI .)
    PHI             reduce using rule 78 (constant -> PHI .)
    GAMMA           reduce using rule 78 (constant -> PHI .)
    E               reduce using rule 78 (constant -> PHI .)
    DEG             reduce using rule 78 (constant -> PHI .)
    PREC            reduce using rule 78 (constant -> PHI .)
    ELSE            reduce using rule 78 (constant -> PHI .)
    SEMICOLON       reduce using rule 78 (constant -> PHI .)


state 30

    (6) list -> list expr . newline
    (15) stmt -> expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr
    (76) newline -> . NEWLINE

  ! shift/reduce conflict for NEWLINE resolved as shift
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71
    NEWLINE         shift and go to state 14

  ! NEWLINE         [ reduce using rule 15 (stmt -> expr .) ]

    newline                        shift and go to state 75

state 31

    (33) expr -> callfunc .

    EXP             reduce using rule 33 (expr -> callfunc .)
    PLUS            reduce using rule 33 (expr -> callfunc .)
    MINUS           reduce using rule 33 (expr -> callfunc .)
    TIMES           reduce using rule 33 (expr -> callfunc .)
    DIVIDE          reduce using rule 33 (expr -> callfunc .)
    MOD             reduce using rule 33 (expr -> callfunc .)
    LT              reduce using rule 33 (expr -> callfunc .)
    GT              reduce using rule 33 (expr -> callfunc .)
    LE              reduce using rule 33 (expr -> callfunc .)
    GE              reduce using rule 33 (expr -> callfunc .)
    EQ              reduce using rule 33 (expr -> callfunc .)
    NE              reduce using rule 33 (expr -> callfunc .)
    OR              reduce using rule 33 (expr -> callfunc .)
    AND             reduce using rule 33 (expr -> callfunc .)
    NEWLINE         reduce using rule 33 (expr -> callfunc .)
    RBRACKET        reduce using rule 33 (expr -> callfunc .)
    RETURN          reduce using rule 33 (expr -> callfunc .)
    PRINT           reduce using rule 33 (expr -> callfunc .)
    WHILE           reduce using rule 33 (expr -> callfunc .)
    FOR             reduce using rule 33 (expr -> callfunc .)
    IF              reduce using rule 33 (expr -> callfunc .)
    LBRACKET        reduce using rule 33 (expr -> callfunc .)
    LPARENT         reduce using rule 33 (expr -> callfunc .)
    FLOAT           reduce using rule 33 (expr -> callfunc .)
    VAR             reduce using rule 33 (expr -> callfunc .)
    UNARYMINUS      reduce using rule 33 (expr -> callfunc .)
    INC             reduce using rule 33 (expr -> callfunc .)
    DEC             reduce using rule 33 (expr -> callfunc .)
    NOT             reduce using rule 33 (expr -> callfunc .)
    BLTIN           reduce using rule 33 (expr -> callfunc .)
    FUNCTION        reduce using rule 33 (expr -> callfunc .)
    PI              reduce using rule 33 (expr -> callfunc .)
    PHI             reduce using rule 33 (expr -> callfunc .)
    GAMMA           reduce using rule 33 (expr -> callfunc .)
    E               reduce using rule 33 (expr -> callfunc .)
    DEG             reduce using rule 33 (expr -> callfunc .)
    PREC            reduce using rule 33 (expr -> callfunc .)
    ELSE            reduce using rule 33 (expr -> callfunc .)
    COMMA           reduce using rule 33 (expr -> callfunc .)
    RPARENT         reduce using rule 33 (expr -> callfunc .)
    SEMICOLON       reduce using rule 33 (expr -> callfunc .)


state 32

    (34) data -> FLOAT .

    EXP             reduce using rule 34 (data -> FLOAT .)
    PLUS            reduce using rule 34 (data -> FLOAT .)
    MINUS           reduce using rule 34 (data -> FLOAT .)
    TIMES           reduce using rule 34 (data -> FLOAT .)
    DIVIDE          reduce using rule 34 (data -> FLOAT .)
    MOD             reduce using rule 34 (data -> FLOAT .)
    LT              reduce using rule 34 (data -> FLOAT .)
    GT              reduce using rule 34 (data -> FLOAT .)
    LE              reduce using rule 34 (data -> FLOAT .)
    GE              reduce using rule 34 (data -> FLOAT .)
    EQ              reduce using rule 34 (data -> FLOAT .)
    NE              reduce using rule 34 (data -> FLOAT .)
    OR              reduce using rule 34 (data -> FLOAT .)
    AND             reduce using rule 34 (data -> FLOAT .)
    SEMICOLON       reduce using rule 34 (data -> FLOAT .)
    NEWLINE         reduce using rule 34 (data -> FLOAT .)
    RBRACKET        reduce using rule 34 (data -> FLOAT .)
    RETURN          reduce using rule 34 (data -> FLOAT .)
    PRINT           reduce using rule 34 (data -> FLOAT .)
    WHILE           reduce using rule 34 (data -> FLOAT .)
    FOR             reduce using rule 34 (data -> FLOAT .)
    IF              reduce using rule 34 (data -> FLOAT .)
    LBRACKET        reduce using rule 34 (data -> FLOAT .)
    LPARENT         reduce using rule 34 (data -> FLOAT .)
    FLOAT           reduce using rule 34 (data -> FLOAT .)
    VAR             reduce using rule 34 (data -> FLOAT .)
    UNARYMINUS      reduce using rule 34 (data -> FLOAT .)
    INC             reduce using rule 34 (data -> FLOAT .)
    DEC             reduce using rule 34 (data -> FLOAT .)
    NOT             reduce using rule 34 (data -> FLOAT .)
    BLTIN           reduce using rule 34 (data -> FLOAT .)
    FUNCTION        reduce using rule 34 (data -> FLOAT .)
    PI              reduce using rule 34 (data -> FLOAT .)
    PHI             reduce using rule 34 (data -> FLOAT .)
    GAMMA           reduce using rule 34 (data -> FLOAT .)
    E               reduce using rule 34 (data -> FLOAT .)
    DEG             reduce using rule 34 (data -> FLOAT .)
    PREC            reduce using rule 34 (data -> FLOAT .)
    ELSE            reduce using rule 34 (data -> FLOAT .)
    COMMA           reduce using rule 34 (data -> FLOAT .)
    RPARENT         reduce using rule 34 (data -> FLOAT .)


state 33

    (82) constant -> PREC .

    EXP             reduce using rule 82 (constant -> PREC .)
    PLUS            reduce using rule 82 (constant -> PREC .)
    MINUS           reduce using rule 82 (constant -> PREC .)
    TIMES           reduce using rule 82 (constant -> PREC .)
    DIVIDE          reduce using rule 82 (constant -> PREC .)
    MOD             reduce using rule 82 (constant -> PREC .)
    LT              reduce using rule 82 (constant -> PREC .)
    GT              reduce using rule 82 (constant -> PREC .)
    LE              reduce using rule 82 (constant -> PREC .)
    GE              reduce using rule 82 (constant -> PREC .)
    EQ              reduce using rule 82 (constant -> PREC .)
    NE              reduce using rule 82 (constant -> PREC .)
    OR              reduce using rule 82 (constant -> PREC .)
    AND             reduce using rule 82 (constant -> PREC .)
    RPARENT         reduce using rule 82 (constant -> PREC .)
    COMMA           reduce using rule 82 (constant -> PREC .)
    RBRACKET        reduce using rule 82 (constant -> PREC .)
    NEWLINE         reduce using rule 82 (constant -> PREC .)
    RETURN          reduce using rule 82 (constant -> PREC .)
    PRINT           reduce using rule 82 (constant -> PREC .)
    WHILE           reduce using rule 82 (constant -> PREC .)
    FOR             reduce using rule 82 (constant -> PREC .)
    IF              reduce using rule 82 (constant -> PREC .)
    LBRACKET        reduce using rule 82 (constant -> PREC .)
    LPARENT         reduce using rule 82 (constant -> PREC .)
    FLOAT           reduce using rule 82 (constant -> PREC .)
    VAR             reduce using rule 82 (constant -> PREC .)
    UNARYMINUS      reduce using rule 82 (constant -> PREC .)
    INC             reduce using rule 82 (constant -> PREC .)
    DEC             reduce using rule 82 (constant -> PREC .)
    NOT             reduce using rule 82 (constant -> PREC .)
    BLTIN           reduce using rule 82 (constant -> PREC .)
    FUNCTION        reduce using rule 82 (constant -> PREC .)
    PI              reduce using rule 82 (constant -> PREC .)
    PHI             reduce using rule 82 (constant -> PREC .)
    GAMMA           reduce using rule 82 (constant -> PREC .)
    E               reduce using rule 82 (constant -> PREC .)
    DEG             reduce using rule 82 (constant -> PREC .)
    PREC            reduce using rule 82 (constant -> PREC .)
    ELSE            reduce using rule 82 (constant -> PREC .)
    SEMICOLON       reduce using rule 82 (constant -> PREC .)


state 34

    (37) unaryop -> UNARYMINUS . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 86
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 35

    (43) binaryop -> mathop .

    EXP             reduce using rule 43 (binaryop -> mathop .)
    PLUS            reduce using rule 43 (binaryop -> mathop .)
    MINUS           reduce using rule 43 (binaryop -> mathop .)
    TIMES           reduce using rule 43 (binaryop -> mathop .)
    DIVIDE          reduce using rule 43 (binaryop -> mathop .)
    MOD             reduce using rule 43 (binaryop -> mathop .)
    LT              reduce using rule 43 (binaryop -> mathop .)
    GT              reduce using rule 43 (binaryop -> mathop .)
    LE              reduce using rule 43 (binaryop -> mathop .)
    GE              reduce using rule 43 (binaryop -> mathop .)
    EQ              reduce using rule 43 (binaryop -> mathop .)
    NE              reduce using rule 43 (binaryop -> mathop .)
    OR              reduce using rule 43 (binaryop -> mathop .)
    AND             reduce using rule 43 (binaryop -> mathop .)
    NEWLINE         reduce using rule 43 (binaryop -> mathop .)
    RBRACKET        reduce using rule 43 (binaryop -> mathop .)
    RETURN          reduce using rule 43 (binaryop -> mathop .)
    PRINT           reduce using rule 43 (binaryop -> mathop .)
    WHILE           reduce using rule 43 (binaryop -> mathop .)
    FOR             reduce using rule 43 (binaryop -> mathop .)
    IF              reduce using rule 43 (binaryop -> mathop .)
    LBRACKET        reduce using rule 43 (binaryop -> mathop .)
    LPARENT         reduce using rule 43 (binaryop -> mathop .)
    FLOAT           reduce using rule 43 (binaryop -> mathop .)
    VAR             reduce using rule 43 (binaryop -> mathop .)
    UNARYMINUS      reduce using rule 43 (binaryop -> mathop .)
    INC             reduce using rule 43 (binaryop -> mathop .)
    DEC             reduce using rule 43 (binaryop -> mathop .)
    NOT             reduce using rule 43 (binaryop -> mathop .)
    BLTIN           reduce using rule 43 (binaryop -> mathop .)
    FUNCTION        reduce using rule 43 (binaryop -> mathop .)
    PI              reduce using rule 43 (binaryop -> mathop .)
    PHI             reduce using rule 43 (binaryop -> mathop .)
    GAMMA           reduce using rule 43 (binaryop -> mathop .)
    E               reduce using rule 43 (binaryop -> mathop .)
    DEG             reduce using rule 43 (binaryop -> mathop .)
    PREC            reduce using rule 43 (binaryop -> mathop .)
    ELSE            reduce using rule 43 (binaryop -> mathop .)
    COMMA           reduce using rule 43 (binaryop -> mathop .)
    RPARENT         reduce using rule 43 (binaryop -> mathop .)
    SEMICOLON       reduce using rule 43 (binaryop -> mathop .)


state 36

    (31) expr -> binaryop .

    EXP             reduce using rule 31 (expr -> binaryop .)
    PLUS            reduce using rule 31 (expr -> binaryop .)
    MINUS           reduce using rule 31 (expr -> binaryop .)
    TIMES           reduce using rule 31 (expr -> binaryop .)
    DIVIDE          reduce using rule 31 (expr -> binaryop .)
    MOD             reduce using rule 31 (expr -> binaryop .)
    LT              reduce using rule 31 (expr -> binaryop .)
    GT              reduce using rule 31 (expr -> binaryop .)
    LE              reduce using rule 31 (expr -> binaryop .)
    GE              reduce using rule 31 (expr -> binaryop .)
    EQ              reduce using rule 31 (expr -> binaryop .)
    NE              reduce using rule 31 (expr -> binaryop .)
    OR              reduce using rule 31 (expr -> binaryop .)
    AND             reduce using rule 31 (expr -> binaryop .)
    NEWLINE         reduce using rule 31 (expr -> binaryop .)
    RBRACKET        reduce using rule 31 (expr -> binaryop .)
    RETURN          reduce using rule 31 (expr -> binaryop .)
    PRINT           reduce using rule 31 (expr -> binaryop .)
    WHILE           reduce using rule 31 (expr -> binaryop .)
    FOR             reduce using rule 31 (expr -> binaryop .)
    IF              reduce using rule 31 (expr -> binaryop .)
    LBRACKET        reduce using rule 31 (expr -> binaryop .)
    LPARENT         reduce using rule 31 (expr -> binaryop .)
    FLOAT           reduce using rule 31 (expr -> binaryop .)
    VAR             reduce using rule 31 (expr -> binaryop .)
    UNARYMINUS      reduce using rule 31 (expr -> binaryop .)
    INC             reduce using rule 31 (expr -> binaryop .)
    DEC             reduce using rule 31 (expr -> binaryop .)
    NOT             reduce using rule 31 (expr -> binaryop .)
    BLTIN           reduce using rule 31 (expr -> binaryop .)
    FUNCTION        reduce using rule 31 (expr -> binaryop .)
    PI              reduce using rule 31 (expr -> binaryop .)
    PHI             reduce using rule 31 (expr -> binaryop .)
    GAMMA           reduce using rule 31 (expr -> binaryop .)
    E               reduce using rule 31 (expr -> binaryop .)
    DEG             reduce using rule 31 (expr -> binaryop .)
    PREC            reduce using rule 31 (expr -> binaryop .)
    ELSE            reduce using rule 31 (expr -> binaryop .)
    COMMA           reduce using rule 31 (expr -> binaryop .)
    RPARENT         reduce using rule 31 (expr -> binaryop .)
    SEMICOLON       reduce using rule 31 (expr -> binaryop .)


state 37

    (7) list -> list error . newline
    (76) newline -> . NEWLINE

    NEWLINE         shift and go to state 14

    newline                        shift and go to state 87

state 38

    (42) unaryop -> NOT . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 88
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 39

    (38) unaryop -> INC . VAR

    VAR             shift and go to state 89


state 40

    (29) expr -> asgn .

    EXP             reduce using rule 29 (expr -> asgn .)
    PLUS            reduce using rule 29 (expr -> asgn .)
    MINUS           reduce using rule 29 (expr -> asgn .)
    TIMES           reduce using rule 29 (expr -> asgn .)
    DIVIDE          reduce using rule 29 (expr -> asgn .)
    MOD             reduce using rule 29 (expr -> asgn .)
    LT              reduce using rule 29 (expr -> asgn .)
    GT              reduce using rule 29 (expr -> asgn .)
    LE              reduce using rule 29 (expr -> asgn .)
    GE              reduce using rule 29 (expr -> asgn .)
    EQ              reduce using rule 29 (expr -> asgn .)
    NE              reduce using rule 29 (expr -> asgn .)
    OR              reduce using rule 29 (expr -> asgn .)
    AND             reduce using rule 29 (expr -> asgn .)
    NEWLINE         reduce using rule 29 (expr -> asgn .)
    RBRACKET        reduce using rule 29 (expr -> asgn .)
    RETURN          reduce using rule 29 (expr -> asgn .)
    PRINT           reduce using rule 29 (expr -> asgn .)
    WHILE           reduce using rule 29 (expr -> asgn .)
    FOR             reduce using rule 29 (expr -> asgn .)
    IF              reduce using rule 29 (expr -> asgn .)
    LBRACKET        reduce using rule 29 (expr -> asgn .)
    LPARENT         reduce using rule 29 (expr -> asgn .)
    FLOAT           reduce using rule 29 (expr -> asgn .)
    VAR             reduce using rule 29 (expr -> asgn .)
    UNARYMINUS      reduce using rule 29 (expr -> asgn .)
    INC             reduce using rule 29 (expr -> asgn .)
    DEC             reduce using rule 29 (expr -> asgn .)
    NOT             reduce using rule 29 (expr -> asgn .)
    BLTIN           reduce using rule 29 (expr -> asgn .)
    FUNCTION        reduce using rule 29 (expr -> asgn .)
    PI              reduce using rule 29 (expr -> asgn .)
    PHI             reduce using rule 29 (expr -> asgn .)
    GAMMA           reduce using rule 29 (expr -> asgn .)
    E               reduce using rule 29 (expr -> asgn .)
    DEG             reduce using rule 29 (expr -> asgn .)
    PREC            reduce using rule 29 (expr -> asgn .)
    ELSE            reduce using rule 29 (expr -> asgn .)
    COMMA           reduce using rule 29 (expr -> asgn .)
    RPARENT         reduce using rule 29 (expr -> asgn .)
    SEMICOLON       reduce using rule 29 (expr -> asgn .)


state 41

    (36) data -> VAR .
    (9) asgn -> VAR . ASSIGN expr
    (10) asgn -> VAR . ADDEQ expr
    (11) asgn -> VAR . SUBEQ expr
    (12) asgn -> VAR . MULEQ expr
    (13) asgn -> VAR . DIVEQ expr
    (14) asgn -> VAR . MODEQ expr
    (40) unaryop -> VAR . INC
    (41) unaryop -> VAR . DEC

    EXP             reduce using rule 36 (data -> VAR .)
    PLUS            reduce using rule 36 (data -> VAR .)
    MINUS           reduce using rule 36 (data -> VAR .)
    TIMES           reduce using rule 36 (data -> VAR .)
    DIVIDE          reduce using rule 36 (data -> VAR .)
    MOD             reduce using rule 36 (data -> VAR .)
    LT              reduce using rule 36 (data -> VAR .)
    GT              reduce using rule 36 (data -> VAR .)
    LE              reduce using rule 36 (data -> VAR .)
    GE              reduce using rule 36 (data -> VAR .)
    EQ              reduce using rule 36 (data -> VAR .)
    NE              reduce using rule 36 (data -> VAR .)
    OR              reduce using rule 36 (data -> VAR .)
    AND             reduce using rule 36 (data -> VAR .)
    SEMICOLON       reduce using rule 36 (data -> VAR .)
    NEWLINE         reduce using rule 36 (data -> VAR .)
    RBRACKET        reduce using rule 36 (data -> VAR .)
    RETURN          reduce using rule 36 (data -> VAR .)
    PRINT           reduce using rule 36 (data -> VAR .)
    WHILE           reduce using rule 36 (data -> VAR .)
    FOR             reduce using rule 36 (data -> VAR .)
    IF              reduce using rule 36 (data -> VAR .)
    LBRACKET        reduce using rule 36 (data -> VAR .)
    LPARENT         reduce using rule 36 (data -> VAR .)
    FLOAT           reduce using rule 36 (data -> VAR .)
    VAR             reduce using rule 36 (data -> VAR .)
    UNARYMINUS      reduce using rule 36 (data -> VAR .)
    INC             reduce using rule 36 (data -> VAR .)
    DEC             reduce using rule 36 (data -> VAR .)
    NOT             reduce using rule 36 (data -> VAR .)
    BLTIN           reduce using rule 36 (data -> VAR .)
    FUNCTION        reduce using rule 36 (data -> VAR .)
    PI              reduce using rule 36 (data -> VAR .)
    PHI             reduce using rule 36 (data -> VAR .)
    GAMMA           reduce using rule 36 (data -> VAR .)
    E               reduce using rule 36 (data -> VAR .)
    DEG             reduce using rule 36 (data -> VAR .)
    PREC            reduce using rule 36 (data -> VAR .)
    ELSE            reduce using rule 36 (data -> VAR .)
    COMMA           reduce using rule 36 (data -> VAR .)
    RPARENT         reduce using rule 36 (data -> VAR .)
    ASSIGN          shift and go to state 66
    ADDEQ           shift and go to state 64
    SUBEQ           shift and go to state 62
    MULEQ           shift and go to state 63
    DIVEQ           shift and go to state 67
    MODEQ           shift and go to state 61

  ! INC             [ shift and go to state 68 ]
  ! DEC             [ shift and go to state 65 ]


state 42

    (17) stmt -> RETURN expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    NEWLINE         reduce using rule 17 (stmt -> RETURN expr .)
    RBRACKET        reduce using rule 17 (stmt -> RETURN expr .)
    RETURN          reduce using rule 17 (stmt -> RETURN expr .)
    PRINT           reduce using rule 17 (stmt -> RETURN expr .)
    WHILE           reduce using rule 17 (stmt -> RETURN expr .)
    FOR             reduce using rule 17 (stmt -> RETURN expr .)
    IF              reduce using rule 17 (stmt -> RETURN expr .)
    LBRACKET        reduce using rule 17 (stmt -> RETURN expr .)
    LPARENT         reduce using rule 17 (stmt -> RETURN expr .)
    FLOAT           reduce using rule 17 (stmt -> RETURN expr .)
    VAR             reduce using rule 17 (stmt -> RETURN expr .)
    UNARYMINUS      reduce using rule 17 (stmt -> RETURN expr .)
    INC             reduce using rule 17 (stmt -> RETURN expr .)
    DEC             reduce using rule 17 (stmt -> RETURN expr .)
    NOT             reduce using rule 17 (stmt -> RETURN expr .)
    BLTIN           reduce using rule 17 (stmt -> RETURN expr .)
    FUNCTION        reduce using rule 17 (stmt -> RETURN expr .)
    PI              reduce using rule 17 (stmt -> RETURN expr .)
    PHI             reduce using rule 17 (stmt -> RETURN expr .)
    GAMMA           reduce using rule 17 (stmt -> RETURN expr .)
    E               reduce using rule 17 (stmt -> RETURN expr .)
    DEG             reduce using rule 17 (stmt -> RETURN expr .)
    PREC            reduce using rule 17 (stmt -> RETURN expr .)
    ELSE            reduce using rule 17 (stmt -> RETURN expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71


state 43

    (23) stmt -> LBRACKET stmtlist . RBRACKET
    (26) stmtlist -> stmtlist . newline
    (27) stmtlist -> stmtlist . stmt
    (76) newline -> . NEWLINE
    (15) stmt -> . expr
    (16) stmt -> . RETURN
    (17) stmt -> . RETURN expr
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt
    (21) stmt -> . IF LPARENT cond RPARENT stmt
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    RBRACKET        shift and go to state 93
    NEWLINE         shift and go to state 14
    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 19
    IF              shift and go to state 28
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    binaryop                       shift and go to state 36
    unaryop                        shift and go to state 20
    expr                           shift and go to state 92
    callfunc                       shift and go to state 31
    newline                        shift and go to state 90
    stmt                           shift and go to state 91
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 44

    (25) stmtlist -> empty .

    RBRACKET        reduce using rule 25 (stmtlist -> empty .)
    NEWLINE         reduce using rule 25 (stmtlist -> empty .)
    RETURN          reduce using rule 25 (stmtlist -> empty .)
    PRINT           reduce using rule 25 (stmtlist -> empty .)
    WHILE           reduce using rule 25 (stmtlist -> empty .)
    FOR             reduce using rule 25 (stmtlist -> empty .)
    IF              reduce using rule 25 (stmtlist -> empty .)
    LBRACKET        reduce using rule 25 (stmtlist -> empty .)
    LPARENT         reduce using rule 25 (stmtlist -> empty .)
    FLOAT           reduce using rule 25 (stmtlist -> empty .)
    VAR             reduce using rule 25 (stmtlist -> empty .)
    UNARYMINUS      reduce using rule 25 (stmtlist -> empty .)
    INC             reduce using rule 25 (stmtlist -> empty .)
    DEC             reduce using rule 25 (stmtlist -> empty .)
    NOT             reduce using rule 25 (stmtlist -> empty .)
    BLTIN           reduce using rule 25 (stmtlist -> empty .)
    FUNCTION        reduce using rule 25 (stmtlist -> empty .)
    PI              reduce using rule 25 (stmtlist -> empty .)
    PHI             reduce using rule 25 (stmtlist -> empty .)
    GAMMA           reduce using rule 25 (stmtlist -> empty .)
    E               reduce using rule 25 (stmtlist -> empty .)
    DEG             reduce using rule 25 (stmtlist -> empty .)
    PREC            reduce using rule 25 (stmtlist -> empty .)


state 45

    (19) stmt -> WHILE LPARENT . cond RPARENT stmt
    (24) cond -> . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 95
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    cond                           shift and go to state 94
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 46

    (62) prlist -> STRING .

    COMMA           reduce using rule 62 (prlist -> STRING .)
    NEWLINE         reduce using rule 62 (prlist -> STRING .)
    RBRACKET        reduce using rule 62 (prlist -> STRING .)
    RETURN          reduce using rule 62 (prlist -> STRING .)
    PRINT           reduce using rule 62 (prlist -> STRING .)
    WHILE           reduce using rule 62 (prlist -> STRING .)
    FOR             reduce using rule 62 (prlist -> STRING .)
    IF              reduce using rule 62 (prlist -> STRING .)
    LBRACKET        reduce using rule 62 (prlist -> STRING .)
    LPARENT         reduce using rule 62 (prlist -> STRING .)
    FLOAT           reduce using rule 62 (prlist -> STRING .)
    VAR             reduce using rule 62 (prlist -> STRING .)
    UNARYMINUS      reduce using rule 62 (prlist -> STRING .)
    INC             reduce using rule 62 (prlist -> STRING .)
    DEC             reduce using rule 62 (prlist -> STRING .)
    NOT             reduce using rule 62 (prlist -> STRING .)
    BLTIN           reduce using rule 62 (prlist -> STRING .)
    FUNCTION        reduce using rule 62 (prlist -> STRING .)
    PI              reduce using rule 62 (prlist -> STRING .)
    PHI             reduce using rule 62 (prlist -> STRING .)
    GAMMA           reduce using rule 62 (prlist -> STRING .)
    E               reduce using rule 62 (prlist -> STRING .)
    DEG             reduce using rule 62 (prlist -> STRING .)
    PREC            reduce using rule 62 (prlist -> STRING .)
    ELSE            reduce using rule 62 (prlist -> STRING .)


state 47

    (61) prlist -> expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    COMMA           reduce using rule 61 (prlist -> expr .)
    NEWLINE         reduce using rule 61 (prlist -> expr .)
    RBRACKET        reduce using rule 61 (prlist -> expr .)
    RETURN          reduce using rule 61 (prlist -> expr .)
    PRINT           reduce using rule 61 (prlist -> expr .)
    WHILE           reduce using rule 61 (prlist -> expr .)
    FOR             reduce using rule 61 (prlist -> expr .)
    IF              reduce using rule 61 (prlist -> expr .)
    LBRACKET        reduce using rule 61 (prlist -> expr .)
    LPARENT         reduce using rule 61 (prlist -> expr .)
    FLOAT           reduce using rule 61 (prlist -> expr .)
    VAR             reduce using rule 61 (prlist -> expr .)
    UNARYMINUS      reduce using rule 61 (prlist -> expr .)
    INC             reduce using rule 61 (prlist -> expr .)
    DEC             reduce using rule 61 (prlist -> expr .)
    NOT             reduce using rule 61 (prlist -> expr .)
    BLTIN           reduce using rule 61 (prlist -> expr .)
    FUNCTION        reduce using rule 61 (prlist -> expr .)
    PI              reduce using rule 61 (prlist -> expr .)
    PHI             reduce using rule 61 (prlist -> expr .)
    GAMMA           reduce using rule 61 (prlist -> expr .)
    E               reduce using rule 61 (prlist -> expr .)
    DEG             reduce using rule 61 (prlist -> expr .)
    PREC            reduce using rule 61 (prlist -> expr .)
    ELSE            reduce using rule 61 (prlist -> expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71


state 48

    (18) stmt -> PRINT prlist .
    (63) prlist -> prlist . COMMA expr
    (64) prlist -> prlist . COMMA STRING

    NEWLINE         reduce using rule 18 (stmt -> PRINT prlist .)
    RBRACKET        reduce using rule 18 (stmt -> PRINT prlist .)
    RETURN          reduce using rule 18 (stmt -> PRINT prlist .)
    PRINT           reduce using rule 18 (stmt -> PRINT prlist .)
    WHILE           reduce using rule 18 (stmt -> PRINT prlist .)
    FOR             reduce using rule 18 (stmt -> PRINT prlist .)
    IF              reduce using rule 18 (stmt -> PRINT prlist .)
    LBRACKET        reduce using rule 18 (stmt -> PRINT prlist .)
    LPARENT         reduce using rule 18 (stmt -> PRINT prlist .)
    FLOAT           reduce using rule 18 (stmt -> PRINT prlist .)
    VAR             reduce using rule 18 (stmt -> PRINT prlist .)
    UNARYMINUS      reduce using rule 18 (stmt -> PRINT prlist .)
    INC             reduce using rule 18 (stmt -> PRINT prlist .)
    DEC             reduce using rule 18 (stmt -> PRINT prlist .)
    NOT             reduce using rule 18 (stmt -> PRINT prlist .)
    BLTIN           reduce using rule 18 (stmt -> PRINT prlist .)
    FUNCTION        reduce using rule 18 (stmt -> PRINT prlist .)
    PI              reduce using rule 18 (stmt -> PRINT prlist .)
    PHI             reduce using rule 18 (stmt -> PRINT prlist .)
    GAMMA           reduce using rule 18 (stmt -> PRINT prlist .)
    E               reduce using rule 18 (stmt -> PRINT prlist .)
    DEG             reduce using rule 18 (stmt -> PRINT prlist .)
    PREC            reduce using rule 18 (stmt -> PRINT prlist .)
    ELSE            reduce using rule 18 (stmt -> PRINT prlist .)
    COMMA           shift and go to state 96


state 49

    (39) unaryop -> DEC VAR .

    EXP             reduce using rule 39 (unaryop -> DEC VAR .)
    PLUS            reduce using rule 39 (unaryop -> DEC VAR .)
    MINUS           reduce using rule 39 (unaryop -> DEC VAR .)
    TIMES           reduce using rule 39 (unaryop -> DEC VAR .)
    DIVIDE          reduce using rule 39 (unaryop -> DEC VAR .)
    MOD             reduce using rule 39 (unaryop -> DEC VAR .)
    LT              reduce using rule 39 (unaryop -> DEC VAR .)
    GT              reduce using rule 39 (unaryop -> DEC VAR .)
    LE              reduce using rule 39 (unaryop -> DEC VAR .)
    GE              reduce using rule 39 (unaryop -> DEC VAR .)
    EQ              reduce using rule 39 (unaryop -> DEC VAR .)
    NE              reduce using rule 39 (unaryop -> DEC VAR .)
    OR              reduce using rule 39 (unaryop -> DEC VAR .)
    AND             reduce using rule 39 (unaryop -> DEC VAR .)
    NEWLINE         reduce using rule 39 (unaryop -> DEC VAR .)
    RBRACKET        reduce using rule 39 (unaryop -> DEC VAR .)
    RETURN          reduce using rule 39 (unaryop -> DEC VAR .)
    PRINT           reduce using rule 39 (unaryop -> DEC VAR .)
    WHILE           reduce using rule 39 (unaryop -> DEC VAR .)
    FOR             reduce using rule 39 (unaryop -> DEC VAR .)
    IF              reduce using rule 39 (unaryop -> DEC VAR .)
    LBRACKET        reduce using rule 39 (unaryop -> DEC VAR .)
    LPARENT         reduce using rule 39 (unaryop -> DEC VAR .)
    FLOAT           reduce using rule 39 (unaryop -> DEC VAR .)
    VAR             reduce using rule 39 (unaryop -> DEC VAR .)
    UNARYMINUS      reduce using rule 39 (unaryop -> DEC VAR .)
    INC             reduce using rule 39 (unaryop -> DEC VAR .)
    DEC             reduce using rule 39 (unaryop -> DEC VAR .)
    NOT             reduce using rule 39 (unaryop -> DEC VAR .)
    BLTIN           reduce using rule 39 (unaryop -> DEC VAR .)
    FUNCTION        reduce using rule 39 (unaryop -> DEC VAR .)
    PI              reduce using rule 39 (unaryop -> DEC VAR .)
    PHI             reduce using rule 39 (unaryop -> DEC VAR .)
    GAMMA           reduce using rule 39 (unaryop -> DEC VAR .)
    E               reduce using rule 39 (unaryop -> DEC VAR .)
    DEG             reduce using rule 39 (unaryop -> DEC VAR .)
    PREC            reduce using rule 39 (unaryop -> DEC VAR .)
    ELSE            reduce using rule 39 (unaryop -> DEC VAR .)
    COMMA           reduce using rule 39 (unaryop -> DEC VAR .)
    RPARENT         reduce using rule 39 (unaryop -> DEC VAR .)
    SEMICOLON       reduce using rule 39 (unaryop -> DEC VAR .)


state 50

    (8) list -> list COMMENT newline .

    error           reduce using rule 8 (list -> list COMMENT newline .)
    COMMENT         reduce using rule 8 (list -> list COMMENT newline .)
    NEWLINE         reduce using rule 8 (list -> list COMMENT newline .)
    FUNC            reduce using rule 8 (list -> list COMMENT newline .)
    VAR             reduce using rule 8 (list -> list COMMENT newline .)
    RETURN          reduce using rule 8 (list -> list COMMENT newline .)
    PRINT           reduce using rule 8 (list -> list COMMENT newline .)
    WHILE           reduce using rule 8 (list -> list COMMENT newline .)
    FOR             reduce using rule 8 (list -> list COMMENT newline .)
    IF              reduce using rule 8 (list -> list COMMENT newline .)
    LBRACKET        reduce using rule 8 (list -> list COMMENT newline .)
    LPARENT         reduce using rule 8 (list -> list COMMENT newline .)
    FLOAT           reduce using rule 8 (list -> list COMMENT newline .)
    UNARYMINUS      reduce using rule 8 (list -> list COMMENT newline .)
    INC             reduce using rule 8 (list -> list COMMENT newline .)
    DEC             reduce using rule 8 (list -> list COMMENT newline .)
    NOT             reduce using rule 8 (list -> list COMMENT newline .)
    BLTIN           reduce using rule 8 (list -> list COMMENT newline .)
    FUNCTION        reduce using rule 8 (list -> list COMMENT newline .)
    PI              reduce using rule 8 (list -> list COMMENT newline .)
    PHI             reduce using rule 8 (list -> list COMMENT newline .)
    GAMMA           reduce using rule 8 (list -> list COMMENT newline .)
    E               reduce using rule 8 (list -> list COMMENT newline .)
    DEG             reduce using rule 8 (list -> list COMMENT newline .)
    PREC            reduce using rule 8 (list -> list COMMENT newline .)
    $end            reduce using rule 8 (list -> list COMMENT newline .)


state 51

    (32) expr -> LPARENT expr . RPARENT
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    RPARENT         shift and go to state 97
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71


state 52

    (4) list -> list asgn newline .

    error           reduce using rule 4 (list -> list asgn newline .)
    COMMENT         reduce using rule 4 (list -> list asgn newline .)
    NEWLINE         reduce using rule 4 (list -> list asgn newline .)
    FUNC            reduce using rule 4 (list -> list asgn newline .)
    VAR             reduce using rule 4 (list -> list asgn newline .)
    RETURN          reduce using rule 4 (list -> list asgn newline .)
    PRINT           reduce using rule 4 (list -> list asgn newline .)
    WHILE           reduce using rule 4 (list -> list asgn newline .)
    FOR             reduce using rule 4 (list -> list asgn newline .)
    IF              reduce using rule 4 (list -> list asgn newline .)
    LBRACKET        reduce using rule 4 (list -> list asgn newline .)
    LPARENT         reduce using rule 4 (list -> list asgn newline .)
    FLOAT           reduce using rule 4 (list -> list asgn newline .)
    UNARYMINUS      reduce using rule 4 (list -> list asgn newline .)
    INC             reduce using rule 4 (list -> list asgn newline .)
    DEC             reduce using rule 4 (list -> list asgn newline .)
    NOT             reduce using rule 4 (list -> list asgn newline .)
    BLTIN           reduce using rule 4 (list -> list asgn newline .)
    FUNCTION        reduce using rule 4 (list -> list asgn newline .)
    PI              reduce using rule 4 (list -> list asgn newline .)
    PHI             reduce using rule 4 (list -> list asgn newline .)
    GAMMA           reduce using rule 4 (list -> list asgn newline .)
    E               reduce using rule 4 (list -> list asgn newline .)
    DEG             reduce using rule 4 (list -> list asgn newline .)
    PREC            reduce using rule 4 (list -> list asgn newline .)
    $end            reduce using rule 4 (list -> list asgn newline .)


state 53

    (60) callfunc -> FUNCTION LPARENT . arglist RPARENT
    (72) arglist -> . empty
    (73) arglist -> . expr
    (74) arglist -> . arglist COMMA expr
    (75) empty -> .
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    RPARENT         reduce using rule 75 (empty -> .)
    COMMA           reduce using rule 75 (empty -> .)
    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 99
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    arglist                        shift and go to state 98
    data                           shift and go to state 26
    empty                          shift and go to state 100

state 54

    (20) stmt -> FOR LPARENT . cond SEMICOLON cond SEMICOLON cond RPARENT stmt
    (24) cond -> . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 95
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    cond                           shift and go to state 101
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 55

    (5) list -> list stmt newline .

    error           reduce using rule 5 (list -> list stmt newline .)
    COMMENT         reduce using rule 5 (list -> list stmt newline .)
    NEWLINE         reduce using rule 5 (list -> list stmt newline .)
    FUNC            reduce using rule 5 (list -> list stmt newline .)
    VAR             reduce using rule 5 (list -> list stmt newline .)
    RETURN          reduce using rule 5 (list -> list stmt newline .)
    PRINT           reduce using rule 5 (list -> list stmt newline .)
    WHILE           reduce using rule 5 (list -> list stmt newline .)
    FOR             reduce using rule 5 (list -> list stmt newline .)
    IF              reduce using rule 5 (list -> list stmt newline .)
    LBRACKET        reduce using rule 5 (list -> list stmt newline .)
    LPARENT         reduce using rule 5 (list -> list stmt newline .)
    FLOAT           reduce using rule 5 (list -> list stmt newline .)
    UNARYMINUS      reduce using rule 5 (list -> list stmt newline .)
    INC             reduce using rule 5 (list -> list stmt newline .)
    DEC             reduce using rule 5 (list -> list stmt newline .)
    NOT             reduce using rule 5 (list -> list stmt newline .)
    BLTIN           reduce using rule 5 (list -> list stmt newline .)
    FUNCTION        reduce using rule 5 (list -> list stmt newline .)
    PI              reduce using rule 5 (list -> list stmt newline .)
    PHI             reduce using rule 5 (list -> list stmt newline .)
    GAMMA           reduce using rule 5 (list -> list stmt newline .)
    E               reduce using rule 5 (list -> list stmt newline .)
    DEG             reduce using rule 5 (list -> list stmt newline .)
    PREC            reduce using rule 5 (list -> list stmt newline .)
    $end            reduce using rule 5 (list -> list stmt newline .)


state 56

    (59) callfunc -> BLTIN LPARENT . arglist RPARENT
    (72) arglist -> . empty
    (73) arglist -> . expr
    (74) arglist -> . arglist COMMA expr
    (75) empty -> .
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    RPARENT         reduce using rule 75 (empty -> .)
    COMMA           reduce using rule 75 (empty -> .)
    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 99
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    arglist                        shift and go to state 102
    data                           shift and go to state 26
    empty                          shift and go to state 100

state 57

    (67) procname -> FUNCTION .

    LPARENT         reduce using rule 67 (procname -> FUNCTION .)


state 58

    (65) defn -> FUNC procname . LPARENT formals RPARENT stmt

    LPARENT         shift and go to state 103


state 59

    (66) procname -> VAR .

    LPARENT         reduce using rule 66 (procname -> VAR .)


state 60

    (68) procname -> PROCEDURE .

    LPARENT         reduce using rule 68 (procname -> PROCEDURE .)


state 61

    (14) asgn -> VAR MODEQ . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 104
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 62

    (11) asgn -> VAR SUBEQ . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 105
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 63

    (12) asgn -> VAR MULEQ . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 106
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 64

    (10) asgn -> VAR ADDEQ . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 107
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 65

    (41) unaryop -> VAR DEC .

    EXP             reduce using rule 41 (unaryop -> VAR DEC .)
    PLUS            reduce using rule 41 (unaryop -> VAR DEC .)
    MINUS           reduce using rule 41 (unaryop -> VAR DEC .)
    TIMES           reduce using rule 41 (unaryop -> VAR DEC .)
    DIVIDE          reduce using rule 41 (unaryop -> VAR DEC .)
    MOD             reduce using rule 41 (unaryop -> VAR DEC .)
    LT              reduce using rule 41 (unaryop -> VAR DEC .)
    GT              reduce using rule 41 (unaryop -> VAR DEC .)
    LE              reduce using rule 41 (unaryop -> VAR DEC .)
    GE              reduce using rule 41 (unaryop -> VAR DEC .)
    EQ              reduce using rule 41 (unaryop -> VAR DEC .)
    NE              reduce using rule 41 (unaryop -> VAR DEC .)
    OR              reduce using rule 41 (unaryop -> VAR DEC .)
    AND             reduce using rule 41 (unaryop -> VAR DEC .)
    NEWLINE         reduce using rule 41 (unaryop -> VAR DEC .)
    RBRACKET        reduce using rule 41 (unaryop -> VAR DEC .)
    RETURN          reduce using rule 41 (unaryop -> VAR DEC .)
    PRINT           reduce using rule 41 (unaryop -> VAR DEC .)
    WHILE           reduce using rule 41 (unaryop -> VAR DEC .)
    FOR             reduce using rule 41 (unaryop -> VAR DEC .)
    IF              reduce using rule 41 (unaryop -> VAR DEC .)
    LBRACKET        reduce using rule 41 (unaryop -> VAR DEC .)
    LPARENT         reduce using rule 41 (unaryop -> VAR DEC .)
    FLOAT           reduce using rule 41 (unaryop -> VAR DEC .)
    VAR             reduce using rule 41 (unaryop -> VAR DEC .)
    UNARYMINUS      reduce using rule 41 (unaryop -> VAR DEC .)
    INC             reduce using rule 41 (unaryop -> VAR DEC .)
    DEC             reduce using rule 41 (unaryop -> VAR DEC .)
    NOT             reduce using rule 41 (unaryop -> VAR DEC .)
    BLTIN           reduce using rule 41 (unaryop -> VAR DEC .)
    FUNCTION        reduce using rule 41 (unaryop -> VAR DEC .)
    PI              reduce using rule 41 (unaryop -> VAR DEC .)
    PHI             reduce using rule 41 (unaryop -> VAR DEC .)
    GAMMA           reduce using rule 41 (unaryop -> VAR DEC .)
    E               reduce using rule 41 (unaryop -> VAR DEC .)
    DEG             reduce using rule 41 (unaryop -> VAR DEC .)
    PREC            reduce using rule 41 (unaryop -> VAR DEC .)
    ELSE            reduce using rule 41 (unaryop -> VAR DEC .)
    COMMA           reduce using rule 41 (unaryop -> VAR DEC .)
    RPARENT         reduce using rule 41 (unaryop -> VAR DEC .)
    SEMICOLON       reduce using rule 41 (unaryop -> VAR DEC .)


state 66

    (9) asgn -> VAR ASSIGN . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 108
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 67

    (13) asgn -> VAR DIVEQ . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 109
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 68

    (40) unaryop -> VAR INC .

    EXP             reduce using rule 40 (unaryop -> VAR INC .)
    PLUS            reduce using rule 40 (unaryop -> VAR INC .)
    MINUS           reduce using rule 40 (unaryop -> VAR INC .)
    TIMES           reduce using rule 40 (unaryop -> VAR INC .)
    DIVIDE          reduce using rule 40 (unaryop -> VAR INC .)
    MOD             reduce using rule 40 (unaryop -> VAR INC .)
    LT              reduce using rule 40 (unaryop -> VAR INC .)
    GT              reduce using rule 40 (unaryop -> VAR INC .)
    LE              reduce using rule 40 (unaryop -> VAR INC .)
    GE              reduce using rule 40 (unaryop -> VAR INC .)
    EQ              reduce using rule 40 (unaryop -> VAR INC .)
    NE              reduce using rule 40 (unaryop -> VAR INC .)
    OR              reduce using rule 40 (unaryop -> VAR INC .)
    AND             reduce using rule 40 (unaryop -> VAR INC .)
    NEWLINE         reduce using rule 40 (unaryop -> VAR INC .)
    RBRACKET        reduce using rule 40 (unaryop -> VAR INC .)
    RETURN          reduce using rule 40 (unaryop -> VAR INC .)
    PRINT           reduce using rule 40 (unaryop -> VAR INC .)
    WHILE           reduce using rule 40 (unaryop -> VAR INC .)
    FOR             reduce using rule 40 (unaryop -> VAR INC .)
    IF              reduce using rule 40 (unaryop -> VAR INC .)
    LBRACKET        reduce using rule 40 (unaryop -> VAR INC .)
    LPARENT         reduce using rule 40 (unaryop -> VAR INC .)
    FLOAT           reduce using rule 40 (unaryop -> VAR INC .)
    VAR             reduce using rule 40 (unaryop -> VAR INC .)
    UNARYMINUS      reduce using rule 40 (unaryop -> VAR INC .)
    INC             reduce using rule 40 (unaryop -> VAR INC .)
    DEC             reduce using rule 40 (unaryop -> VAR INC .)
    NOT             reduce using rule 40 (unaryop -> VAR INC .)
    BLTIN           reduce using rule 40 (unaryop -> VAR INC .)
    FUNCTION        reduce using rule 40 (unaryop -> VAR INC .)
    PI              reduce using rule 40 (unaryop -> VAR INC .)
    PHI             reduce using rule 40 (unaryop -> VAR INC .)
    GAMMA           reduce using rule 40 (unaryop -> VAR INC .)
    E               reduce using rule 40 (unaryop -> VAR INC .)
    DEG             reduce using rule 40 (unaryop -> VAR INC .)
    PREC            reduce using rule 40 (unaryop -> VAR INC .)
    ELSE            reduce using rule 40 (unaryop -> VAR INC .)
    COMMA           reduce using rule 40 (unaryop -> VAR INC .)
    RPARENT         reduce using rule 40 (unaryop -> VAR INC .)
    SEMICOLON       reduce using rule 40 (unaryop -> VAR INC .)


state 69

    (3) list -> list defn newline .

    error           reduce using rule 3 (list -> list defn newline .)
    COMMENT         reduce using rule 3 (list -> list defn newline .)
    NEWLINE         reduce using rule 3 (list -> list defn newline .)
    FUNC            reduce using rule 3 (list -> list defn newline .)
    VAR             reduce using rule 3 (list -> list defn newline .)
    RETURN          reduce using rule 3 (list -> list defn newline .)
    PRINT           reduce using rule 3 (list -> list defn newline .)
    WHILE           reduce using rule 3 (list -> list defn newline .)
    FOR             reduce using rule 3 (list -> list defn newline .)
    IF              reduce using rule 3 (list -> list defn newline .)
    LBRACKET        reduce using rule 3 (list -> list defn newline .)
    LPARENT         reduce using rule 3 (list -> list defn newline .)
    FLOAT           reduce using rule 3 (list -> list defn newline .)
    UNARYMINUS      reduce using rule 3 (list -> list defn newline .)
    INC             reduce using rule 3 (list -> list defn newline .)
    DEC             reduce using rule 3 (list -> list defn newline .)
    NOT             reduce using rule 3 (list -> list defn newline .)
    BLTIN           reduce using rule 3 (list -> list defn newline .)
    FUNCTION        reduce using rule 3 (list -> list defn newline .)
    PI              reduce using rule 3 (list -> list defn newline .)
    PHI             reduce using rule 3 (list -> list defn newline .)
    GAMMA           reduce using rule 3 (list -> list defn newline .)
    E               reduce using rule 3 (list -> list defn newline .)
    DEG             reduce using rule 3 (list -> list defn newline .)
    PREC            reduce using rule 3 (list -> list defn newline .)
    $end            reduce using rule 3 (list -> list defn newline .)


state 70

    (21) stmt -> IF LPARENT . cond RPARENT stmt
    (22) stmt -> IF LPARENT . cond RPARENT stmt ELSE stmt
    (24) cond -> . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 95
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    cond                           shift and go to state 110
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 71

    (58) logicop -> expr AND . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 111
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 72

    (57) logicop -> expr OR . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 112
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 73

    (52) logicop -> expr GT . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 113
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 74

    (49) mathop -> expr DIVIDE . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 114
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 75

    (6) list -> list expr newline .

    error           reduce using rule 6 (list -> list expr newline .)
    COMMENT         reduce using rule 6 (list -> list expr newline .)
    NEWLINE         reduce using rule 6 (list -> list expr newline .)
    FUNC            reduce using rule 6 (list -> list expr newline .)
    VAR             reduce using rule 6 (list -> list expr newline .)
    RETURN          reduce using rule 6 (list -> list expr newline .)
    PRINT           reduce using rule 6 (list -> list expr newline .)
    WHILE           reduce using rule 6 (list -> list expr newline .)
    FOR             reduce using rule 6 (list -> list expr newline .)
    IF              reduce using rule 6 (list -> list expr newline .)
    LBRACKET        reduce using rule 6 (list -> list expr newline .)
    LPARENT         reduce using rule 6 (list -> list expr newline .)
    FLOAT           reduce using rule 6 (list -> list expr newline .)
    UNARYMINUS      reduce using rule 6 (list -> list expr newline .)
    INC             reduce using rule 6 (list -> list expr newline .)
    DEC             reduce using rule 6 (list -> list expr newline .)
    NOT             reduce using rule 6 (list -> list expr newline .)
    BLTIN           reduce using rule 6 (list -> list expr newline .)
    FUNCTION        reduce using rule 6 (list -> list expr newline .)
    PI              reduce using rule 6 (list -> list expr newline .)
    PHI             reduce using rule 6 (list -> list expr newline .)
    GAMMA           reduce using rule 6 (list -> list expr newline .)
    E               reduce using rule 6 (list -> list expr newline .)
    DEG             reduce using rule 6 (list -> list expr newline .)
    PREC            reduce using rule 6 (list -> list expr newline .)
    $end            reduce using rule 6 (list -> list expr newline .)


state 76

    (54) logicop -> expr GE . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 115
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 77

    (48) mathop -> expr TIMES . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 116
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 78

    (51) logicop -> expr LT . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 117
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 79

    (53) logicop -> expr LE . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 118
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 80

    (46) mathop -> expr PLUS . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 119
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 81

    (45) mathop -> expr EXP . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 120
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 82

    (55) logicop -> expr EQ . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 121
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 83

    (47) mathop -> expr MINUS . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 122
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 84

    (56) logicop -> expr NE . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 123
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 85

    (50) mathop -> expr MOD . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 124
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 86

    (37) unaryop -> UNARYMINUS expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    PLUS            reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    MINUS           reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    TIMES           reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    DIVIDE          reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    MOD             reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    LT              reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    GT              reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    LE              reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    GE              reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    EQ              reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    NE              reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    OR              reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    AND             reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    NEWLINE         reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    RBRACKET        reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    RETURN          reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    PRINT           reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    WHILE           reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    FOR             reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    IF              reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    LBRACKET        reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    LPARENT         reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    FLOAT           reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    VAR             reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    UNARYMINUS      reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    INC             reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    DEC             reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    NOT             reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    BLTIN           reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    FUNCTION        reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    PI              reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    PHI             reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    GAMMA           reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    E               reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    DEG             reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    PREC            reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    ELSE            reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    COMMA           reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    RPARENT         reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    SEMICOLON       reduce using rule 37 (unaryop -> UNARYMINUS expr .)
    EXP             shift and go to state 81

  ! EXP             [ reduce using rule 37 (unaryop -> UNARYMINUS expr .) ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 83 ]
  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 87

    (7) list -> list error newline .

    error           reduce using rule 7 (list -> list error newline .)
    COMMENT         reduce using rule 7 (list -> list error newline .)
    NEWLINE         reduce using rule 7 (list -> list error newline .)
    FUNC            reduce using rule 7 (list -> list error newline .)
    VAR             reduce using rule 7 (list -> list error newline .)
    RETURN          reduce using rule 7 (list -> list error newline .)
    PRINT           reduce using rule 7 (list -> list error newline .)
    WHILE           reduce using rule 7 (list -> list error newline .)
    FOR             reduce using rule 7 (list -> list error newline .)
    IF              reduce using rule 7 (list -> list error newline .)
    LBRACKET        reduce using rule 7 (list -> list error newline .)
    LPARENT         reduce using rule 7 (list -> list error newline .)
    FLOAT           reduce using rule 7 (list -> list error newline .)
    UNARYMINUS      reduce using rule 7 (list -> list error newline .)
    INC             reduce using rule 7 (list -> list error newline .)
    DEC             reduce using rule 7 (list -> list error newline .)
    NOT             reduce using rule 7 (list -> list error newline .)
    BLTIN           reduce using rule 7 (list -> list error newline .)
    FUNCTION        reduce using rule 7 (list -> list error newline .)
    PI              reduce using rule 7 (list -> list error newline .)
    PHI             reduce using rule 7 (list -> list error newline .)
    GAMMA           reduce using rule 7 (list -> list error newline .)
    E               reduce using rule 7 (list -> list error newline .)
    DEG             reduce using rule 7 (list -> list error newline .)
    PREC            reduce using rule 7 (list -> list error newline .)
    $end            reduce using rule 7 (list -> list error newline .)


state 88

    (42) unaryop -> NOT expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    PLUS            reduce using rule 42 (unaryop -> NOT expr .)
    MINUS           reduce using rule 42 (unaryop -> NOT expr .)
    TIMES           reduce using rule 42 (unaryop -> NOT expr .)
    DIVIDE          reduce using rule 42 (unaryop -> NOT expr .)
    MOD             reduce using rule 42 (unaryop -> NOT expr .)
    LT              reduce using rule 42 (unaryop -> NOT expr .)
    GT              reduce using rule 42 (unaryop -> NOT expr .)
    LE              reduce using rule 42 (unaryop -> NOT expr .)
    GE              reduce using rule 42 (unaryop -> NOT expr .)
    EQ              reduce using rule 42 (unaryop -> NOT expr .)
    NE              reduce using rule 42 (unaryop -> NOT expr .)
    OR              reduce using rule 42 (unaryop -> NOT expr .)
    AND             reduce using rule 42 (unaryop -> NOT expr .)
    NEWLINE         reduce using rule 42 (unaryop -> NOT expr .)
    RBRACKET        reduce using rule 42 (unaryop -> NOT expr .)
    RETURN          reduce using rule 42 (unaryop -> NOT expr .)
    PRINT           reduce using rule 42 (unaryop -> NOT expr .)
    WHILE           reduce using rule 42 (unaryop -> NOT expr .)
    FOR             reduce using rule 42 (unaryop -> NOT expr .)
    IF              reduce using rule 42 (unaryop -> NOT expr .)
    LBRACKET        reduce using rule 42 (unaryop -> NOT expr .)
    LPARENT         reduce using rule 42 (unaryop -> NOT expr .)
    FLOAT           reduce using rule 42 (unaryop -> NOT expr .)
    VAR             reduce using rule 42 (unaryop -> NOT expr .)
    UNARYMINUS      reduce using rule 42 (unaryop -> NOT expr .)
    INC             reduce using rule 42 (unaryop -> NOT expr .)
    DEC             reduce using rule 42 (unaryop -> NOT expr .)
    NOT             reduce using rule 42 (unaryop -> NOT expr .)
    BLTIN           reduce using rule 42 (unaryop -> NOT expr .)
    FUNCTION        reduce using rule 42 (unaryop -> NOT expr .)
    PI              reduce using rule 42 (unaryop -> NOT expr .)
    PHI             reduce using rule 42 (unaryop -> NOT expr .)
    GAMMA           reduce using rule 42 (unaryop -> NOT expr .)
    E               reduce using rule 42 (unaryop -> NOT expr .)
    DEG             reduce using rule 42 (unaryop -> NOT expr .)
    PREC            reduce using rule 42 (unaryop -> NOT expr .)
    ELSE            reduce using rule 42 (unaryop -> NOT expr .)
    COMMA           reduce using rule 42 (unaryop -> NOT expr .)
    RPARENT         reduce using rule 42 (unaryop -> NOT expr .)
    SEMICOLON       reduce using rule 42 (unaryop -> NOT expr .)
    EXP             shift and go to state 81

  ! EXP             [ reduce using rule 42 (unaryop -> NOT expr .) ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 83 ]
  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 89

    (38) unaryop -> INC VAR .

    EXP             reduce using rule 38 (unaryop -> INC VAR .)
    PLUS            reduce using rule 38 (unaryop -> INC VAR .)
    MINUS           reduce using rule 38 (unaryop -> INC VAR .)
    TIMES           reduce using rule 38 (unaryop -> INC VAR .)
    DIVIDE          reduce using rule 38 (unaryop -> INC VAR .)
    MOD             reduce using rule 38 (unaryop -> INC VAR .)
    LT              reduce using rule 38 (unaryop -> INC VAR .)
    GT              reduce using rule 38 (unaryop -> INC VAR .)
    LE              reduce using rule 38 (unaryop -> INC VAR .)
    GE              reduce using rule 38 (unaryop -> INC VAR .)
    EQ              reduce using rule 38 (unaryop -> INC VAR .)
    NE              reduce using rule 38 (unaryop -> INC VAR .)
    OR              reduce using rule 38 (unaryop -> INC VAR .)
    AND             reduce using rule 38 (unaryop -> INC VAR .)
    NEWLINE         reduce using rule 38 (unaryop -> INC VAR .)
    RBRACKET        reduce using rule 38 (unaryop -> INC VAR .)
    RETURN          reduce using rule 38 (unaryop -> INC VAR .)
    PRINT           reduce using rule 38 (unaryop -> INC VAR .)
    WHILE           reduce using rule 38 (unaryop -> INC VAR .)
    FOR             reduce using rule 38 (unaryop -> INC VAR .)
    IF              reduce using rule 38 (unaryop -> INC VAR .)
    LBRACKET        reduce using rule 38 (unaryop -> INC VAR .)
    LPARENT         reduce using rule 38 (unaryop -> INC VAR .)
    FLOAT           reduce using rule 38 (unaryop -> INC VAR .)
    VAR             reduce using rule 38 (unaryop -> INC VAR .)
    UNARYMINUS      reduce using rule 38 (unaryop -> INC VAR .)
    INC             reduce using rule 38 (unaryop -> INC VAR .)
    DEC             reduce using rule 38 (unaryop -> INC VAR .)
    NOT             reduce using rule 38 (unaryop -> INC VAR .)
    BLTIN           reduce using rule 38 (unaryop -> INC VAR .)
    FUNCTION        reduce using rule 38 (unaryop -> INC VAR .)
    PI              reduce using rule 38 (unaryop -> INC VAR .)
    PHI             reduce using rule 38 (unaryop -> INC VAR .)
    GAMMA           reduce using rule 38 (unaryop -> INC VAR .)
    E               reduce using rule 38 (unaryop -> INC VAR .)
    DEG             reduce using rule 38 (unaryop -> INC VAR .)
    PREC            reduce using rule 38 (unaryop -> INC VAR .)
    ELSE            reduce using rule 38 (unaryop -> INC VAR .)
    COMMA           reduce using rule 38 (unaryop -> INC VAR .)
    RPARENT         reduce using rule 38 (unaryop -> INC VAR .)
    SEMICOLON       reduce using rule 38 (unaryop -> INC VAR .)


state 90

    (26) stmtlist -> stmtlist newline .

    RBRACKET        reduce using rule 26 (stmtlist -> stmtlist newline .)
    NEWLINE         reduce using rule 26 (stmtlist -> stmtlist newline .)
    RETURN          reduce using rule 26 (stmtlist -> stmtlist newline .)
    PRINT           reduce using rule 26 (stmtlist -> stmtlist newline .)
    WHILE           reduce using rule 26 (stmtlist -> stmtlist newline .)
    FOR             reduce using rule 26 (stmtlist -> stmtlist newline .)
    IF              reduce using rule 26 (stmtlist -> stmtlist newline .)
    LBRACKET        reduce using rule 26 (stmtlist -> stmtlist newline .)
    LPARENT         reduce using rule 26 (stmtlist -> stmtlist newline .)
    FLOAT           reduce using rule 26 (stmtlist -> stmtlist newline .)
    VAR             reduce using rule 26 (stmtlist -> stmtlist newline .)
    UNARYMINUS      reduce using rule 26 (stmtlist -> stmtlist newline .)
    INC             reduce using rule 26 (stmtlist -> stmtlist newline .)
    DEC             reduce using rule 26 (stmtlist -> stmtlist newline .)
    NOT             reduce using rule 26 (stmtlist -> stmtlist newline .)
    BLTIN           reduce using rule 26 (stmtlist -> stmtlist newline .)
    FUNCTION        reduce using rule 26 (stmtlist -> stmtlist newline .)
    PI              reduce using rule 26 (stmtlist -> stmtlist newline .)
    PHI             reduce using rule 26 (stmtlist -> stmtlist newline .)
    GAMMA           reduce using rule 26 (stmtlist -> stmtlist newline .)
    E               reduce using rule 26 (stmtlist -> stmtlist newline .)
    DEG             reduce using rule 26 (stmtlist -> stmtlist newline .)
    PREC            reduce using rule 26 (stmtlist -> stmtlist newline .)


state 91

    (27) stmtlist -> stmtlist stmt .

    RBRACKET        reduce using rule 27 (stmtlist -> stmtlist stmt .)
    NEWLINE         reduce using rule 27 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 27 (stmtlist -> stmtlist stmt .)
    PRINT           reduce using rule 27 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 27 (stmtlist -> stmtlist stmt .)
    FOR             reduce using rule 27 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 27 (stmtlist -> stmtlist stmt .)
    LBRACKET        reduce using rule 27 (stmtlist -> stmtlist stmt .)
    LPARENT         reduce using rule 27 (stmtlist -> stmtlist stmt .)
    FLOAT           reduce using rule 27 (stmtlist -> stmtlist stmt .)
    VAR             reduce using rule 27 (stmtlist -> stmtlist stmt .)
    UNARYMINUS      reduce using rule 27 (stmtlist -> stmtlist stmt .)
    INC             reduce using rule 27 (stmtlist -> stmtlist stmt .)
    DEC             reduce using rule 27 (stmtlist -> stmtlist stmt .)
    NOT             reduce using rule 27 (stmtlist -> stmtlist stmt .)
    BLTIN           reduce using rule 27 (stmtlist -> stmtlist stmt .)
    FUNCTION        reduce using rule 27 (stmtlist -> stmtlist stmt .)
    PI              reduce using rule 27 (stmtlist -> stmtlist stmt .)
    PHI             reduce using rule 27 (stmtlist -> stmtlist stmt .)
    GAMMA           reduce using rule 27 (stmtlist -> stmtlist stmt .)
    E               reduce using rule 27 (stmtlist -> stmtlist stmt .)
    DEG             reduce using rule 27 (stmtlist -> stmtlist stmt .)
    PREC            reduce using rule 27 (stmtlist -> stmtlist stmt .)


state 92

    (15) stmt -> expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    NEWLINE         reduce using rule 15 (stmt -> expr .)
    RBRACKET        reduce using rule 15 (stmt -> expr .)
    RETURN          reduce using rule 15 (stmt -> expr .)
    PRINT           reduce using rule 15 (stmt -> expr .)
    WHILE           reduce using rule 15 (stmt -> expr .)
    FOR             reduce using rule 15 (stmt -> expr .)
    IF              reduce using rule 15 (stmt -> expr .)
    LBRACKET        reduce using rule 15 (stmt -> expr .)
    LPARENT         reduce using rule 15 (stmt -> expr .)
    FLOAT           reduce using rule 15 (stmt -> expr .)
    VAR             reduce using rule 15 (stmt -> expr .)
    UNARYMINUS      reduce using rule 15 (stmt -> expr .)
    INC             reduce using rule 15 (stmt -> expr .)
    DEC             reduce using rule 15 (stmt -> expr .)
    NOT             reduce using rule 15 (stmt -> expr .)
    BLTIN           reduce using rule 15 (stmt -> expr .)
    FUNCTION        reduce using rule 15 (stmt -> expr .)
    PI              reduce using rule 15 (stmt -> expr .)
    PHI             reduce using rule 15 (stmt -> expr .)
    GAMMA           reduce using rule 15 (stmt -> expr .)
    E               reduce using rule 15 (stmt -> expr .)
    DEG             reduce using rule 15 (stmt -> expr .)
    PREC            reduce using rule 15 (stmt -> expr .)
    ELSE            reduce using rule 15 (stmt -> expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71


state 93

    (23) stmt -> LBRACKET stmtlist RBRACKET .

    NEWLINE         reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    RBRACKET        reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    RETURN          reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    PRINT           reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    WHILE           reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    FOR             reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    IF              reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    LBRACKET        reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    LPARENT         reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    FLOAT           reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    VAR             reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    UNARYMINUS      reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    INC             reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    DEC             reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    NOT             reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    BLTIN           reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    FUNCTION        reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    PI              reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    PHI             reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    GAMMA           reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    E               reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    DEG             reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    PREC            reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)
    ELSE            reduce using rule 23 (stmt -> LBRACKET stmtlist RBRACKET .)


state 94

    (19) stmt -> WHILE LPARENT cond . RPARENT stmt

    RPARENT         shift and go to state 125


state 95

    (24) cond -> expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    SEMICOLON       reduce using rule 24 (cond -> expr .)
    RPARENT         reduce using rule 24 (cond -> expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71


state 96

    (63) prlist -> prlist COMMA . expr
    (64) prlist -> prlist COMMA . STRING
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    STRING          shift and go to state 126
    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 127
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 97

    (32) expr -> LPARENT expr RPARENT .

    EXP             reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    PLUS            reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    MINUS           reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    TIMES           reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    DIVIDE          reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    MOD             reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    LT              reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    GT              reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    LE              reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    GE              reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    EQ              reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    NE              reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    OR              reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    AND             reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    NEWLINE         reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    RBRACKET        reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    RETURN          reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    PRINT           reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    WHILE           reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    FOR             reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    IF              reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    LBRACKET        reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    LPARENT         reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    FLOAT           reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    VAR             reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    UNARYMINUS      reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    INC             reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    DEC             reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    NOT             reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    BLTIN           reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    FUNCTION        reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    PI              reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    PHI             reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    GAMMA           reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    E               reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    DEG             reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    PREC            reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    ELSE            reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    COMMA           reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    RPARENT         reduce using rule 32 (expr -> LPARENT expr RPARENT .)
    SEMICOLON       reduce using rule 32 (expr -> LPARENT expr RPARENT .)


state 98

    (60) callfunc -> FUNCTION LPARENT arglist . RPARENT
    (74) arglist -> arglist . COMMA expr

    RPARENT         shift and go to state 129
    COMMA           shift and go to state 128


state 99

    (73) arglist -> expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    RPARENT         reduce using rule 73 (arglist -> expr .)
    COMMA           reduce using rule 73 (arglist -> expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71


state 100

    (72) arglist -> empty .

    RPARENT         reduce using rule 72 (arglist -> empty .)
    COMMA           reduce using rule 72 (arglist -> empty .)


state 101

    (20) stmt -> FOR LPARENT cond . SEMICOLON cond SEMICOLON cond RPARENT stmt

    SEMICOLON       shift and go to state 130


state 102

    (59) callfunc -> BLTIN LPARENT arglist . RPARENT
    (74) arglist -> arglist . COMMA expr

    RPARENT         shift and go to state 131
    COMMA           shift and go to state 128


state 103

    (65) defn -> FUNC procname LPARENT . formals RPARENT stmt
    (69) formals -> . empty
    (70) formals -> . VAR
    (71) formals -> . formals COMMA VAR
    (75) empty -> .

    VAR             shift and go to state 132
    RPARENT         reduce using rule 75 (empty -> .)
    COMMA           reduce using rule 75 (empty -> .)

    empty                          shift and go to state 133
    formals                        shift and go to state 134

state 104

    (14) asgn -> VAR MODEQ expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    NEWLINE         reduce using rule 14 (asgn -> VAR MODEQ expr .)
    RBRACKET        reduce using rule 14 (asgn -> VAR MODEQ expr .)
    RETURN          reduce using rule 14 (asgn -> VAR MODEQ expr .)
    PRINT           reduce using rule 14 (asgn -> VAR MODEQ expr .)
    WHILE           reduce using rule 14 (asgn -> VAR MODEQ expr .)
    FOR             reduce using rule 14 (asgn -> VAR MODEQ expr .)
    IF              reduce using rule 14 (asgn -> VAR MODEQ expr .)
    LBRACKET        reduce using rule 14 (asgn -> VAR MODEQ expr .)
    LPARENT         reduce using rule 14 (asgn -> VAR MODEQ expr .)
    FLOAT           reduce using rule 14 (asgn -> VAR MODEQ expr .)
    VAR             reduce using rule 14 (asgn -> VAR MODEQ expr .)
    UNARYMINUS      reduce using rule 14 (asgn -> VAR MODEQ expr .)
    INC             reduce using rule 14 (asgn -> VAR MODEQ expr .)
    DEC             reduce using rule 14 (asgn -> VAR MODEQ expr .)
    NOT             reduce using rule 14 (asgn -> VAR MODEQ expr .)
    BLTIN           reduce using rule 14 (asgn -> VAR MODEQ expr .)
    FUNCTION        reduce using rule 14 (asgn -> VAR MODEQ expr .)
    PI              reduce using rule 14 (asgn -> VAR MODEQ expr .)
    PHI             reduce using rule 14 (asgn -> VAR MODEQ expr .)
    GAMMA           reduce using rule 14 (asgn -> VAR MODEQ expr .)
    E               reduce using rule 14 (asgn -> VAR MODEQ expr .)
    DEG             reduce using rule 14 (asgn -> VAR MODEQ expr .)
    PREC            reduce using rule 14 (asgn -> VAR MODEQ expr .)
    ELSE            reduce using rule 14 (asgn -> VAR MODEQ expr .)
    COMMA           reduce using rule 14 (asgn -> VAR MODEQ expr .)
    RPARENT         reduce using rule 14 (asgn -> VAR MODEQ expr .)
    SEMICOLON       reduce using rule 14 (asgn -> VAR MODEQ expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71

  ! EXP             [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! PLUS            [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! MINUS           [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! TIMES           [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! DIVIDE          [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! MOD             [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! LT              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! GT              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! LE              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! GE              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! EQ              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! NE              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! OR              [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]
  ! AND             [ reduce using rule 14 (asgn -> VAR MODEQ expr .) ]


state 105

    (11) asgn -> VAR SUBEQ expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    NEWLINE         reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    RBRACKET        reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    RETURN          reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    PRINT           reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    WHILE           reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    FOR             reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    IF              reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    LBRACKET        reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    LPARENT         reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    FLOAT           reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    VAR             reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    UNARYMINUS      reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    INC             reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    DEC             reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    NOT             reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    BLTIN           reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    FUNCTION        reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    PI              reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    PHI             reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    GAMMA           reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    E               reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    DEG             reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    PREC            reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    ELSE            reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    COMMA           reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    RPARENT         reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    SEMICOLON       reduce using rule 11 (asgn -> VAR SUBEQ expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71

  ! EXP             [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! PLUS            [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! MINUS           [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! TIMES           [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! DIVIDE          [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! MOD             [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! LT              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! GT              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! LE              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! GE              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! EQ              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! NE              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! OR              [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]
  ! AND             [ reduce using rule 11 (asgn -> VAR SUBEQ expr .) ]


state 106

    (12) asgn -> VAR MULEQ expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    NEWLINE         reduce using rule 12 (asgn -> VAR MULEQ expr .)
    RBRACKET        reduce using rule 12 (asgn -> VAR MULEQ expr .)
    RETURN          reduce using rule 12 (asgn -> VAR MULEQ expr .)
    PRINT           reduce using rule 12 (asgn -> VAR MULEQ expr .)
    WHILE           reduce using rule 12 (asgn -> VAR MULEQ expr .)
    FOR             reduce using rule 12 (asgn -> VAR MULEQ expr .)
    IF              reduce using rule 12 (asgn -> VAR MULEQ expr .)
    LBRACKET        reduce using rule 12 (asgn -> VAR MULEQ expr .)
    LPARENT         reduce using rule 12 (asgn -> VAR MULEQ expr .)
    FLOAT           reduce using rule 12 (asgn -> VAR MULEQ expr .)
    VAR             reduce using rule 12 (asgn -> VAR MULEQ expr .)
    UNARYMINUS      reduce using rule 12 (asgn -> VAR MULEQ expr .)
    INC             reduce using rule 12 (asgn -> VAR MULEQ expr .)
    DEC             reduce using rule 12 (asgn -> VAR MULEQ expr .)
    NOT             reduce using rule 12 (asgn -> VAR MULEQ expr .)
    BLTIN           reduce using rule 12 (asgn -> VAR MULEQ expr .)
    FUNCTION        reduce using rule 12 (asgn -> VAR MULEQ expr .)
    PI              reduce using rule 12 (asgn -> VAR MULEQ expr .)
    PHI             reduce using rule 12 (asgn -> VAR MULEQ expr .)
    GAMMA           reduce using rule 12 (asgn -> VAR MULEQ expr .)
    E               reduce using rule 12 (asgn -> VAR MULEQ expr .)
    DEG             reduce using rule 12 (asgn -> VAR MULEQ expr .)
    PREC            reduce using rule 12 (asgn -> VAR MULEQ expr .)
    ELSE            reduce using rule 12 (asgn -> VAR MULEQ expr .)
    COMMA           reduce using rule 12 (asgn -> VAR MULEQ expr .)
    RPARENT         reduce using rule 12 (asgn -> VAR MULEQ expr .)
    SEMICOLON       reduce using rule 12 (asgn -> VAR MULEQ expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71

  ! EXP             [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! PLUS            [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! MINUS           [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! TIMES           [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! DIVIDE          [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! MOD             [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! LT              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! GT              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! LE              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! GE              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! EQ              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! NE              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! OR              [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]
  ! AND             [ reduce using rule 12 (asgn -> VAR MULEQ expr .) ]


state 107

    (10) asgn -> VAR ADDEQ expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    NEWLINE         reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    RBRACKET        reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    RETURN          reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    PRINT           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    WHILE           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    FOR             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    IF              reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    LBRACKET        reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    LPARENT         reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    FLOAT           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    VAR             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    UNARYMINUS      reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    INC             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    DEC             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    NOT             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    BLTIN           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    FUNCTION        reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    PI              reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    PHI             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    GAMMA           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    E               reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    DEG             reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    PREC            reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    ELSE            reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    COMMA           reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    RPARENT         reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    SEMICOLON       reduce using rule 10 (asgn -> VAR ADDEQ expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71

  ! EXP             [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! PLUS            [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! MINUS           [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! TIMES           [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! DIVIDE          [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! MOD             [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! LT              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! GT              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! LE              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! GE              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! EQ              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! NE              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! OR              [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]
  ! AND             [ reduce using rule 10 (asgn -> VAR ADDEQ expr .) ]


state 108

    (9) asgn -> VAR ASSIGN expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    NEWLINE         reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    RBRACKET        reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    RETURN          reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    PRINT           reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    WHILE           reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    FOR             reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    IF              reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    LBRACKET        reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    LPARENT         reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    FLOAT           reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    VAR             reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    UNARYMINUS      reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    INC             reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    DEC             reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    NOT             reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    BLTIN           reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    FUNCTION        reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    PI              reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    PHI             reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    GAMMA           reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    E               reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    DEG             reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    PREC            reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    ELSE            reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    COMMA           reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    RPARENT         reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    SEMICOLON       reduce using rule 9 (asgn -> VAR ASSIGN expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71

  ! EXP             [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! PLUS            [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! MINUS           [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! TIMES           [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! DIVIDE          [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! MOD             [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! LT              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! GT              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! LE              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! GE              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! EQ              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! NE              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! OR              [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]
  ! AND             [ reduce using rule 9 (asgn -> VAR ASSIGN expr .) ]


state 109

    (13) asgn -> VAR DIVEQ expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    NEWLINE         reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    RBRACKET        reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    RETURN          reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    PRINT           reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    WHILE           reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    FOR             reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    IF              reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    LBRACKET        reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    LPARENT         reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    FLOAT           reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    VAR             reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    UNARYMINUS      reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    INC             reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    DEC             reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    NOT             reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    BLTIN           reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    FUNCTION        reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    PI              reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    PHI             reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    GAMMA           reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    E               reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    DEG             reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    PREC            reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    ELSE            reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    COMMA           reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    RPARENT         reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    SEMICOLON       reduce using rule 13 (asgn -> VAR DIVEQ expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71

  ! EXP             [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! PLUS            [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! MINUS           [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! TIMES           [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! DIVIDE          [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! MOD             [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! LT              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! GT              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! LE              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! GE              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! EQ              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! NE              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! OR              [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]
  ! AND             [ reduce using rule 13 (asgn -> VAR DIVEQ expr .) ]


state 110

    (21) stmt -> IF LPARENT cond . RPARENT stmt
    (22) stmt -> IF LPARENT cond . RPARENT stmt ELSE stmt

    RPARENT         shift and go to state 135


state 111

    (58) logicop -> expr AND expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    OR              reduce using rule 58 (logicop -> expr AND expr .)
    AND             reduce using rule 58 (logicop -> expr AND expr .)
    NEWLINE         reduce using rule 58 (logicop -> expr AND expr .)
    RBRACKET        reduce using rule 58 (logicop -> expr AND expr .)
    RETURN          reduce using rule 58 (logicop -> expr AND expr .)
    PRINT           reduce using rule 58 (logicop -> expr AND expr .)
    WHILE           reduce using rule 58 (logicop -> expr AND expr .)
    FOR             reduce using rule 58 (logicop -> expr AND expr .)
    IF              reduce using rule 58 (logicop -> expr AND expr .)
    LBRACKET        reduce using rule 58 (logicop -> expr AND expr .)
    LPARENT         reduce using rule 58 (logicop -> expr AND expr .)
    FLOAT           reduce using rule 58 (logicop -> expr AND expr .)
    VAR             reduce using rule 58 (logicop -> expr AND expr .)
    UNARYMINUS      reduce using rule 58 (logicop -> expr AND expr .)
    INC             reduce using rule 58 (logicop -> expr AND expr .)
    DEC             reduce using rule 58 (logicop -> expr AND expr .)
    NOT             reduce using rule 58 (logicop -> expr AND expr .)
    BLTIN           reduce using rule 58 (logicop -> expr AND expr .)
    FUNCTION        reduce using rule 58 (logicop -> expr AND expr .)
    PI              reduce using rule 58 (logicop -> expr AND expr .)
    PHI             reduce using rule 58 (logicop -> expr AND expr .)
    GAMMA           reduce using rule 58 (logicop -> expr AND expr .)
    E               reduce using rule 58 (logicop -> expr AND expr .)
    DEG             reduce using rule 58 (logicop -> expr AND expr .)
    PREC            reduce using rule 58 (logicop -> expr AND expr .)
    ELSE            reduce using rule 58 (logicop -> expr AND expr .)
    COMMA           reduce using rule 58 (logicop -> expr AND expr .)
    RPARENT         reduce using rule 58 (logicop -> expr AND expr .)
    SEMICOLON       reduce using rule 58 (logicop -> expr AND expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84

  ! EXP             [ reduce using rule 58 (logicop -> expr AND expr .) ]
  ! PLUS            [ reduce using rule 58 (logicop -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 58 (logicop -> expr AND expr .) ]
  ! TIMES           [ reduce using rule 58 (logicop -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 58 (logicop -> expr AND expr .) ]
  ! MOD             [ reduce using rule 58 (logicop -> expr AND expr .) ]
  ! LT              [ reduce using rule 58 (logicop -> expr AND expr .) ]
  ! GT              [ reduce using rule 58 (logicop -> expr AND expr .) ]
  ! LE              [ reduce using rule 58 (logicop -> expr AND expr .) ]
  ! GE              [ reduce using rule 58 (logicop -> expr AND expr .) ]
  ! EQ              [ reduce using rule 58 (logicop -> expr AND expr .) ]
  ! NE              [ reduce using rule 58 (logicop -> expr AND expr .) ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 112

    (57) logicop -> expr OR expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    OR              reduce using rule 57 (logicop -> expr OR expr .)
    NEWLINE         reduce using rule 57 (logicop -> expr OR expr .)
    RBRACKET        reduce using rule 57 (logicop -> expr OR expr .)
    RETURN          reduce using rule 57 (logicop -> expr OR expr .)
    PRINT           reduce using rule 57 (logicop -> expr OR expr .)
    WHILE           reduce using rule 57 (logicop -> expr OR expr .)
    FOR             reduce using rule 57 (logicop -> expr OR expr .)
    IF              reduce using rule 57 (logicop -> expr OR expr .)
    LBRACKET        reduce using rule 57 (logicop -> expr OR expr .)
    LPARENT         reduce using rule 57 (logicop -> expr OR expr .)
    FLOAT           reduce using rule 57 (logicop -> expr OR expr .)
    VAR             reduce using rule 57 (logicop -> expr OR expr .)
    UNARYMINUS      reduce using rule 57 (logicop -> expr OR expr .)
    INC             reduce using rule 57 (logicop -> expr OR expr .)
    DEC             reduce using rule 57 (logicop -> expr OR expr .)
    NOT             reduce using rule 57 (logicop -> expr OR expr .)
    BLTIN           reduce using rule 57 (logicop -> expr OR expr .)
    FUNCTION        reduce using rule 57 (logicop -> expr OR expr .)
    PI              reduce using rule 57 (logicop -> expr OR expr .)
    PHI             reduce using rule 57 (logicop -> expr OR expr .)
    GAMMA           reduce using rule 57 (logicop -> expr OR expr .)
    E               reduce using rule 57 (logicop -> expr OR expr .)
    DEG             reduce using rule 57 (logicop -> expr OR expr .)
    PREC            reduce using rule 57 (logicop -> expr OR expr .)
    ELSE            reduce using rule 57 (logicop -> expr OR expr .)
    COMMA           reduce using rule 57 (logicop -> expr OR expr .)
    RPARENT         reduce using rule 57 (logicop -> expr OR expr .)
    SEMICOLON       reduce using rule 57 (logicop -> expr OR expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    AND             shift and go to state 71

  ! EXP             [ reduce using rule 57 (logicop -> expr OR expr .) ]
  ! PLUS            [ reduce using rule 57 (logicop -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 57 (logicop -> expr OR expr .) ]
  ! TIMES           [ reduce using rule 57 (logicop -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 57 (logicop -> expr OR expr .) ]
  ! MOD             [ reduce using rule 57 (logicop -> expr OR expr .) ]
  ! LT              [ reduce using rule 57 (logicop -> expr OR expr .) ]
  ! GT              [ reduce using rule 57 (logicop -> expr OR expr .) ]
  ! LE              [ reduce using rule 57 (logicop -> expr OR expr .) ]
  ! GE              [ reduce using rule 57 (logicop -> expr OR expr .) ]
  ! EQ              [ reduce using rule 57 (logicop -> expr OR expr .) ]
  ! NE              [ reduce using rule 57 (logicop -> expr OR expr .) ]
  ! AND             [ reduce using rule 57 (logicop -> expr OR expr .) ]
  ! OR              [ shift and go to state 72 ]


state 113

    (52) logicop -> expr GT expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    LT              reduce using rule 52 (logicop -> expr GT expr .)
    GT              reduce using rule 52 (logicop -> expr GT expr .)
    LE              reduce using rule 52 (logicop -> expr GT expr .)
    GE              reduce using rule 52 (logicop -> expr GT expr .)
    EQ              reduce using rule 52 (logicop -> expr GT expr .)
    NE              reduce using rule 52 (logicop -> expr GT expr .)
    OR              reduce using rule 52 (logicop -> expr GT expr .)
    AND             reduce using rule 52 (logicop -> expr GT expr .)
    NEWLINE         reduce using rule 52 (logicop -> expr GT expr .)
    RBRACKET        reduce using rule 52 (logicop -> expr GT expr .)
    RETURN          reduce using rule 52 (logicop -> expr GT expr .)
    PRINT           reduce using rule 52 (logicop -> expr GT expr .)
    WHILE           reduce using rule 52 (logicop -> expr GT expr .)
    FOR             reduce using rule 52 (logicop -> expr GT expr .)
    IF              reduce using rule 52 (logicop -> expr GT expr .)
    LBRACKET        reduce using rule 52 (logicop -> expr GT expr .)
    LPARENT         reduce using rule 52 (logicop -> expr GT expr .)
    FLOAT           reduce using rule 52 (logicop -> expr GT expr .)
    VAR             reduce using rule 52 (logicop -> expr GT expr .)
    UNARYMINUS      reduce using rule 52 (logicop -> expr GT expr .)
    INC             reduce using rule 52 (logicop -> expr GT expr .)
    DEC             reduce using rule 52 (logicop -> expr GT expr .)
    NOT             reduce using rule 52 (logicop -> expr GT expr .)
    BLTIN           reduce using rule 52 (logicop -> expr GT expr .)
    FUNCTION        reduce using rule 52 (logicop -> expr GT expr .)
    PI              reduce using rule 52 (logicop -> expr GT expr .)
    PHI             reduce using rule 52 (logicop -> expr GT expr .)
    GAMMA           reduce using rule 52 (logicop -> expr GT expr .)
    E               reduce using rule 52 (logicop -> expr GT expr .)
    DEG             reduce using rule 52 (logicop -> expr GT expr .)
    PREC            reduce using rule 52 (logicop -> expr GT expr .)
    ELSE            reduce using rule 52 (logicop -> expr GT expr .)
    COMMA           reduce using rule 52 (logicop -> expr GT expr .)
    RPARENT         reduce using rule 52 (logicop -> expr GT expr .)
    SEMICOLON       reduce using rule 52 (logicop -> expr GT expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85

  ! EXP             [ reduce using rule 52 (logicop -> expr GT expr .) ]
  ! PLUS            [ reduce using rule 52 (logicop -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 52 (logicop -> expr GT expr .) ]
  ! TIMES           [ reduce using rule 52 (logicop -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 52 (logicop -> expr GT expr .) ]
  ! MOD             [ reduce using rule 52 (logicop -> expr GT expr .) ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 114

    (49) mathop -> expr DIVIDE expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    PLUS            reduce using rule 49 (mathop -> expr DIVIDE expr .)
    MINUS           reduce using rule 49 (mathop -> expr DIVIDE expr .)
    TIMES           reduce using rule 49 (mathop -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 49 (mathop -> expr DIVIDE expr .)
    MOD             reduce using rule 49 (mathop -> expr DIVIDE expr .)
    LT              reduce using rule 49 (mathop -> expr DIVIDE expr .)
    GT              reduce using rule 49 (mathop -> expr DIVIDE expr .)
    LE              reduce using rule 49 (mathop -> expr DIVIDE expr .)
    GE              reduce using rule 49 (mathop -> expr DIVIDE expr .)
    EQ              reduce using rule 49 (mathop -> expr DIVIDE expr .)
    NE              reduce using rule 49 (mathop -> expr DIVIDE expr .)
    OR              reduce using rule 49 (mathop -> expr DIVIDE expr .)
    AND             reduce using rule 49 (mathop -> expr DIVIDE expr .)
    NEWLINE         reduce using rule 49 (mathop -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 49 (mathop -> expr DIVIDE expr .)
    RETURN          reduce using rule 49 (mathop -> expr DIVIDE expr .)
    PRINT           reduce using rule 49 (mathop -> expr DIVIDE expr .)
    WHILE           reduce using rule 49 (mathop -> expr DIVIDE expr .)
    FOR             reduce using rule 49 (mathop -> expr DIVIDE expr .)
    IF              reduce using rule 49 (mathop -> expr DIVIDE expr .)
    LBRACKET        reduce using rule 49 (mathop -> expr DIVIDE expr .)
    LPARENT         reduce using rule 49 (mathop -> expr DIVIDE expr .)
    FLOAT           reduce using rule 49 (mathop -> expr DIVIDE expr .)
    VAR             reduce using rule 49 (mathop -> expr DIVIDE expr .)
    UNARYMINUS      reduce using rule 49 (mathop -> expr DIVIDE expr .)
    INC             reduce using rule 49 (mathop -> expr DIVIDE expr .)
    DEC             reduce using rule 49 (mathop -> expr DIVIDE expr .)
    NOT             reduce using rule 49 (mathop -> expr DIVIDE expr .)
    BLTIN           reduce using rule 49 (mathop -> expr DIVIDE expr .)
    FUNCTION        reduce using rule 49 (mathop -> expr DIVIDE expr .)
    PI              reduce using rule 49 (mathop -> expr DIVIDE expr .)
    PHI             reduce using rule 49 (mathop -> expr DIVIDE expr .)
    GAMMA           reduce using rule 49 (mathop -> expr DIVIDE expr .)
    E               reduce using rule 49 (mathop -> expr DIVIDE expr .)
    DEG             reduce using rule 49 (mathop -> expr DIVIDE expr .)
    PREC            reduce using rule 49 (mathop -> expr DIVIDE expr .)
    ELSE            reduce using rule 49 (mathop -> expr DIVIDE expr .)
    COMMA           reduce using rule 49 (mathop -> expr DIVIDE expr .)
    RPARENT         reduce using rule 49 (mathop -> expr DIVIDE expr .)
    SEMICOLON       reduce using rule 49 (mathop -> expr DIVIDE expr .)
    EXP             shift and go to state 81

  ! EXP             [ reduce using rule 49 (mathop -> expr DIVIDE expr .) ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 83 ]
  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 115

    (54) logicop -> expr GE expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    LT              reduce using rule 54 (logicop -> expr GE expr .)
    GT              reduce using rule 54 (logicop -> expr GE expr .)
    LE              reduce using rule 54 (logicop -> expr GE expr .)
    GE              reduce using rule 54 (logicop -> expr GE expr .)
    EQ              reduce using rule 54 (logicop -> expr GE expr .)
    NE              reduce using rule 54 (logicop -> expr GE expr .)
    OR              reduce using rule 54 (logicop -> expr GE expr .)
    AND             reduce using rule 54 (logicop -> expr GE expr .)
    NEWLINE         reduce using rule 54 (logicop -> expr GE expr .)
    RBRACKET        reduce using rule 54 (logicop -> expr GE expr .)
    RETURN          reduce using rule 54 (logicop -> expr GE expr .)
    PRINT           reduce using rule 54 (logicop -> expr GE expr .)
    WHILE           reduce using rule 54 (logicop -> expr GE expr .)
    FOR             reduce using rule 54 (logicop -> expr GE expr .)
    IF              reduce using rule 54 (logicop -> expr GE expr .)
    LBRACKET        reduce using rule 54 (logicop -> expr GE expr .)
    LPARENT         reduce using rule 54 (logicop -> expr GE expr .)
    FLOAT           reduce using rule 54 (logicop -> expr GE expr .)
    VAR             reduce using rule 54 (logicop -> expr GE expr .)
    UNARYMINUS      reduce using rule 54 (logicop -> expr GE expr .)
    INC             reduce using rule 54 (logicop -> expr GE expr .)
    DEC             reduce using rule 54 (logicop -> expr GE expr .)
    NOT             reduce using rule 54 (logicop -> expr GE expr .)
    BLTIN           reduce using rule 54 (logicop -> expr GE expr .)
    FUNCTION        reduce using rule 54 (logicop -> expr GE expr .)
    PI              reduce using rule 54 (logicop -> expr GE expr .)
    PHI             reduce using rule 54 (logicop -> expr GE expr .)
    GAMMA           reduce using rule 54 (logicop -> expr GE expr .)
    E               reduce using rule 54 (logicop -> expr GE expr .)
    DEG             reduce using rule 54 (logicop -> expr GE expr .)
    PREC            reduce using rule 54 (logicop -> expr GE expr .)
    ELSE            reduce using rule 54 (logicop -> expr GE expr .)
    COMMA           reduce using rule 54 (logicop -> expr GE expr .)
    RPARENT         reduce using rule 54 (logicop -> expr GE expr .)
    SEMICOLON       reduce using rule 54 (logicop -> expr GE expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85

  ! EXP             [ reduce using rule 54 (logicop -> expr GE expr .) ]
  ! PLUS            [ reduce using rule 54 (logicop -> expr GE expr .) ]
  ! MINUS           [ reduce using rule 54 (logicop -> expr GE expr .) ]
  ! TIMES           [ reduce using rule 54 (logicop -> expr GE expr .) ]
  ! DIVIDE          [ reduce using rule 54 (logicop -> expr GE expr .) ]
  ! MOD             [ reduce using rule 54 (logicop -> expr GE expr .) ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 116

    (48) mathop -> expr TIMES expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    PLUS            reduce using rule 48 (mathop -> expr TIMES expr .)
    MINUS           reduce using rule 48 (mathop -> expr TIMES expr .)
    TIMES           reduce using rule 48 (mathop -> expr TIMES expr .)
    DIVIDE          reduce using rule 48 (mathop -> expr TIMES expr .)
    MOD             reduce using rule 48 (mathop -> expr TIMES expr .)
    LT              reduce using rule 48 (mathop -> expr TIMES expr .)
    GT              reduce using rule 48 (mathop -> expr TIMES expr .)
    LE              reduce using rule 48 (mathop -> expr TIMES expr .)
    GE              reduce using rule 48 (mathop -> expr TIMES expr .)
    EQ              reduce using rule 48 (mathop -> expr TIMES expr .)
    NE              reduce using rule 48 (mathop -> expr TIMES expr .)
    OR              reduce using rule 48 (mathop -> expr TIMES expr .)
    AND             reduce using rule 48 (mathop -> expr TIMES expr .)
    NEWLINE         reduce using rule 48 (mathop -> expr TIMES expr .)
    RBRACKET        reduce using rule 48 (mathop -> expr TIMES expr .)
    RETURN          reduce using rule 48 (mathop -> expr TIMES expr .)
    PRINT           reduce using rule 48 (mathop -> expr TIMES expr .)
    WHILE           reduce using rule 48 (mathop -> expr TIMES expr .)
    FOR             reduce using rule 48 (mathop -> expr TIMES expr .)
    IF              reduce using rule 48 (mathop -> expr TIMES expr .)
    LBRACKET        reduce using rule 48 (mathop -> expr TIMES expr .)
    LPARENT         reduce using rule 48 (mathop -> expr TIMES expr .)
    FLOAT           reduce using rule 48 (mathop -> expr TIMES expr .)
    VAR             reduce using rule 48 (mathop -> expr TIMES expr .)
    UNARYMINUS      reduce using rule 48 (mathop -> expr TIMES expr .)
    INC             reduce using rule 48 (mathop -> expr TIMES expr .)
    DEC             reduce using rule 48 (mathop -> expr TIMES expr .)
    NOT             reduce using rule 48 (mathop -> expr TIMES expr .)
    BLTIN           reduce using rule 48 (mathop -> expr TIMES expr .)
    FUNCTION        reduce using rule 48 (mathop -> expr TIMES expr .)
    PI              reduce using rule 48 (mathop -> expr TIMES expr .)
    PHI             reduce using rule 48 (mathop -> expr TIMES expr .)
    GAMMA           reduce using rule 48 (mathop -> expr TIMES expr .)
    E               reduce using rule 48 (mathop -> expr TIMES expr .)
    DEG             reduce using rule 48 (mathop -> expr TIMES expr .)
    PREC            reduce using rule 48 (mathop -> expr TIMES expr .)
    ELSE            reduce using rule 48 (mathop -> expr TIMES expr .)
    COMMA           reduce using rule 48 (mathop -> expr TIMES expr .)
    RPARENT         reduce using rule 48 (mathop -> expr TIMES expr .)
    SEMICOLON       reduce using rule 48 (mathop -> expr TIMES expr .)
    EXP             shift and go to state 81

  ! EXP             [ reduce using rule 48 (mathop -> expr TIMES expr .) ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 83 ]
  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 117

    (51) logicop -> expr LT expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    LT              reduce using rule 51 (logicop -> expr LT expr .)
    GT              reduce using rule 51 (logicop -> expr LT expr .)
    LE              reduce using rule 51 (logicop -> expr LT expr .)
    GE              reduce using rule 51 (logicop -> expr LT expr .)
    EQ              reduce using rule 51 (logicop -> expr LT expr .)
    NE              reduce using rule 51 (logicop -> expr LT expr .)
    OR              reduce using rule 51 (logicop -> expr LT expr .)
    AND             reduce using rule 51 (logicop -> expr LT expr .)
    NEWLINE         reduce using rule 51 (logicop -> expr LT expr .)
    RBRACKET        reduce using rule 51 (logicop -> expr LT expr .)
    RETURN          reduce using rule 51 (logicop -> expr LT expr .)
    PRINT           reduce using rule 51 (logicop -> expr LT expr .)
    WHILE           reduce using rule 51 (logicop -> expr LT expr .)
    FOR             reduce using rule 51 (logicop -> expr LT expr .)
    IF              reduce using rule 51 (logicop -> expr LT expr .)
    LBRACKET        reduce using rule 51 (logicop -> expr LT expr .)
    LPARENT         reduce using rule 51 (logicop -> expr LT expr .)
    FLOAT           reduce using rule 51 (logicop -> expr LT expr .)
    VAR             reduce using rule 51 (logicop -> expr LT expr .)
    UNARYMINUS      reduce using rule 51 (logicop -> expr LT expr .)
    INC             reduce using rule 51 (logicop -> expr LT expr .)
    DEC             reduce using rule 51 (logicop -> expr LT expr .)
    NOT             reduce using rule 51 (logicop -> expr LT expr .)
    BLTIN           reduce using rule 51 (logicop -> expr LT expr .)
    FUNCTION        reduce using rule 51 (logicop -> expr LT expr .)
    PI              reduce using rule 51 (logicop -> expr LT expr .)
    PHI             reduce using rule 51 (logicop -> expr LT expr .)
    GAMMA           reduce using rule 51 (logicop -> expr LT expr .)
    E               reduce using rule 51 (logicop -> expr LT expr .)
    DEG             reduce using rule 51 (logicop -> expr LT expr .)
    PREC            reduce using rule 51 (logicop -> expr LT expr .)
    ELSE            reduce using rule 51 (logicop -> expr LT expr .)
    COMMA           reduce using rule 51 (logicop -> expr LT expr .)
    RPARENT         reduce using rule 51 (logicop -> expr LT expr .)
    SEMICOLON       reduce using rule 51 (logicop -> expr LT expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85

  ! EXP             [ reduce using rule 51 (logicop -> expr LT expr .) ]
  ! PLUS            [ reduce using rule 51 (logicop -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 51 (logicop -> expr LT expr .) ]
  ! TIMES           [ reduce using rule 51 (logicop -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 51 (logicop -> expr LT expr .) ]
  ! MOD             [ reduce using rule 51 (logicop -> expr LT expr .) ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 118

    (53) logicop -> expr LE expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    LT              reduce using rule 53 (logicop -> expr LE expr .)
    GT              reduce using rule 53 (logicop -> expr LE expr .)
    LE              reduce using rule 53 (logicop -> expr LE expr .)
    GE              reduce using rule 53 (logicop -> expr LE expr .)
    EQ              reduce using rule 53 (logicop -> expr LE expr .)
    NE              reduce using rule 53 (logicop -> expr LE expr .)
    OR              reduce using rule 53 (logicop -> expr LE expr .)
    AND             reduce using rule 53 (logicop -> expr LE expr .)
    NEWLINE         reduce using rule 53 (logicop -> expr LE expr .)
    RBRACKET        reduce using rule 53 (logicop -> expr LE expr .)
    RETURN          reduce using rule 53 (logicop -> expr LE expr .)
    PRINT           reduce using rule 53 (logicop -> expr LE expr .)
    WHILE           reduce using rule 53 (logicop -> expr LE expr .)
    FOR             reduce using rule 53 (logicop -> expr LE expr .)
    IF              reduce using rule 53 (logicop -> expr LE expr .)
    LBRACKET        reduce using rule 53 (logicop -> expr LE expr .)
    LPARENT         reduce using rule 53 (logicop -> expr LE expr .)
    FLOAT           reduce using rule 53 (logicop -> expr LE expr .)
    VAR             reduce using rule 53 (logicop -> expr LE expr .)
    UNARYMINUS      reduce using rule 53 (logicop -> expr LE expr .)
    INC             reduce using rule 53 (logicop -> expr LE expr .)
    DEC             reduce using rule 53 (logicop -> expr LE expr .)
    NOT             reduce using rule 53 (logicop -> expr LE expr .)
    BLTIN           reduce using rule 53 (logicop -> expr LE expr .)
    FUNCTION        reduce using rule 53 (logicop -> expr LE expr .)
    PI              reduce using rule 53 (logicop -> expr LE expr .)
    PHI             reduce using rule 53 (logicop -> expr LE expr .)
    GAMMA           reduce using rule 53 (logicop -> expr LE expr .)
    E               reduce using rule 53 (logicop -> expr LE expr .)
    DEG             reduce using rule 53 (logicop -> expr LE expr .)
    PREC            reduce using rule 53 (logicop -> expr LE expr .)
    ELSE            reduce using rule 53 (logicop -> expr LE expr .)
    COMMA           reduce using rule 53 (logicop -> expr LE expr .)
    RPARENT         reduce using rule 53 (logicop -> expr LE expr .)
    SEMICOLON       reduce using rule 53 (logicop -> expr LE expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85

  ! EXP             [ reduce using rule 53 (logicop -> expr LE expr .) ]
  ! PLUS            [ reduce using rule 53 (logicop -> expr LE expr .) ]
  ! MINUS           [ reduce using rule 53 (logicop -> expr LE expr .) ]
  ! TIMES           [ reduce using rule 53 (logicop -> expr LE expr .) ]
  ! DIVIDE          [ reduce using rule 53 (logicop -> expr LE expr .) ]
  ! MOD             [ reduce using rule 53 (logicop -> expr LE expr .) ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 119

    (46) mathop -> expr PLUS expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    PLUS            reduce using rule 46 (mathop -> expr PLUS expr .)
    MINUS           reduce using rule 46 (mathop -> expr PLUS expr .)
    LT              reduce using rule 46 (mathop -> expr PLUS expr .)
    GT              reduce using rule 46 (mathop -> expr PLUS expr .)
    LE              reduce using rule 46 (mathop -> expr PLUS expr .)
    GE              reduce using rule 46 (mathop -> expr PLUS expr .)
    EQ              reduce using rule 46 (mathop -> expr PLUS expr .)
    NE              reduce using rule 46 (mathop -> expr PLUS expr .)
    OR              reduce using rule 46 (mathop -> expr PLUS expr .)
    AND             reduce using rule 46 (mathop -> expr PLUS expr .)
    NEWLINE         reduce using rule 46 (mathop -> expr PLUS expr .)
    RBRACKET        reduce using rule 46 (mathop -> expr PLUS expr .)
    RETURN          reduce using rule 46 (mathop -> expr PLUS expr .)
    PRINT           reduce using rule 46 (mathop -> expr PLUS expr .)
    WHILE           reduce using rule 46 (mathop -> expr PLUS expr .)
    FOR             reduce using rule 46 (mathop -> expr PLUS expr .)
    IF              reduce using rule 46 (mathop -> expr PLUS expr .)
    LBRACKET        reduce using rule 46 (mathop -> expr PLUS expr .)
    LPARENT         reduce using rule 46 (mathop -> expr PLUS expr .)
    FLOAT           reduce using rule 46 (mathop -> expr PLUS expr .)
    VAR             reduce using rule 46 (mathop -> expr PLUS expr .)
    UNARYMINUS      reduce using rule 46 (mathop -> expr PLUS expr .)
    INC             reduce using rule 46 (mathop -> expr PLUS expr .)
    DEC             reduce using rule 46 (mathop -> expr PLUS expr .)
    NOT             reduce using rule 46 (mathop -> expr PLUS expr .)
    BLTIN           reduce using rule 46 (mathop -> expr PLUS expr .)
    FUNCTION        reduce using rule 46 (mathop -> expr PLUS expr .)
    PI              reduce using rule 46 (mathop -> expr PLUS expr .)
    PHI             reduce using rule 46 (mathop -> expr PLUS expr .)
    GAMMA           reduce using rule 46 (mathop -> expr PLUS expr .)
    E               reduce using rule 46 (mathop -> expr PLUS expr .)
    DEG             reduce using rule 46 (mathop -> expr PLUS expr .)
    PREC            reduce using rule 46 (mathop -> expr PLUS expr .)
    ELSE            reduce using rule 46 (mathop -> expr PLUS expr .)
    COMMA           reduce using rule 46 (mathop -> expr PLUS expr .)
    RPARENT         reduce using rule 46 (mathop -> expr PLUS expr .)
    SEMICOLON       reduce using rule 46 (mathop -> expr PLUS expr .)
    EXP             shift and go to state 81
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85

  ! EXP             [ reduce using rule 46 (mathop -> expr PLUS expr .) ]
  ! TIMES           [ reduce using rule 46 (mathop -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 46 (mathop -> expr PLUS expr .) ]
  ! MOD             [ reduce using rule 46 (mathop -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 83 ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 120

    (45) mathop -> expr EXP expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    EXP             reduce using rule 45 (mathop -> expr EXP expr .)
    PLUS            reduce using rule 45 (mathop -> expr EXP expr .)
    MINUS           reduce using rule 45 (mathop -> expr EXP expr .)
    TIMES           reduce using rule 45 (mathop -> expr EXP expr .)
    DIVIDE          reduce using rule 45 (mathop -> expr EXP expr .)
    MOD             reduce using rule 45 (mathop -> expr EXP expr .)
    LT              reduce using rule 45 (mathop -> expr EXP expr .)
    GT              reduce using rule 45 (mathop -> expr EXP expr .)
    LE              reduce using rule 45 (mathop -> expr EXP expr .)
    GE              reduce using rule 45 (mathop -> expr EXP expr .)
    EQ              reduce using rule 45 (mathop -> expr EXP expr .)
    NE              reduce using rule 45 (mathop -> expr EXP expr .)
    OR              reduce using rule 45 (mathop -> expr EXP expr .)
    AND             reduce using rule 45 (mathop -> expr EXP expr .)
    NEWLINE         reduce using rule 45 (mathop -> expr EXP expr .)
    RBRACKET        reduce using rule 45 (mathop -> expr EXP expr .)
    RETURN          reduce using rule 45 (mathop -> expr EXP expr .)
    PRINT           reduce using rule 45 (mathop -> expr EXP expr .)
    WHILE           reduce using rule 45 (mathop -> expr EXP expr .)
    FOR             reduce using rule 45 (mathop -> expr EXP expr .)
    IF              reduce using rule 45 (mathop -> expr EXP expr .)
    LBRACKET        reduce using rule 45 (mathop -> expr EXP expr .)
    LPARENT         reduce using rule 45 (mathop -> expr EXP expr .)
    FLOAT           reduce using rule 45 (mathop -> expr EXP expr .)
    VAR             reduce using rule 45 (mathop -> expr EXP expr .)
    UNARYMINUS      reduce using rule 45 (mathop -> expr EXP expr .)
    INC             reduce using rule 45 (mathop -> expr EXP expr .)
    DEC             reduce using rule 45 (mathop -> expr EXP expr .)
    NOT             reduce using rule 45 (mathop -> expr EXP expr .)
    BLTIN           reduce using rule 45 (mathop -> expr EXP expr .)
    FUNCTION        reduce using rule 45 (mathop -> expr EXP expr .)
    PI              reduce using rule 45 (mathop -> expr EXP expr .)
    PHI             reduce using rule 45 (mathop -> expr EXP expr .)
    GAMMA           reduce using rule 45 (mathop -> expr EXP expr .)
    E               reduce using rule 45 (mathop -> expr EXP expr .)
    DEG             reduce using rule 45 (mathop -> expr EXP expr .)
    PREC            reduce using rule 45 (mathop -> expr EXP expr .)
    ELSE            reduce using rule 45 (mathop -> expr EXP expr .)
    COMMA           reduce using rule 45 (mathop -> expr EXP expr .)
    RPARENT         reduce using rule 45 (mathop -> expr EXP expr .)
    SEMICOLON       reduce using rule 45 (mathop -> expr EXP expr .)

  ! EXP             [ shift and go to state 81 ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 83 ]
  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 121

    (55) logicop -> expr EQ expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    LT              reduce using rule 55 (logicop -> expr EQ expr .)
    GT              reduce using rule 55 (logicop -> expr EQ expr .)
    LE              reduce using rule 55 (logicop -> expr EQ expr .)
    GE              reduce using rule 55 (logicop -> expr EQ expr .)
    EQ              reduce using rule 55 (logicop -> expr EQ expr .)
    NE              reduce using rule 55 (logicop -> expr EQ expr .)
    OR              reduce using rule 55 (logicop -> expr EQ expr .)
    AND             reduce using rule 55 (logicop -> expr EQ expr .)
    NEWLINE         reduce using rule 55 (logicop -> expr EQ expr .)
    RBRACKET        reduce using rule 55 (logicop -> expr EQ expr .)
    RETURN          reduce using rule 55 (logicop -> expr EQ expr .)
    PRINT           reduce using rule 55 (logicop -> expr EQ expr .)
    WHILE           reduce using rule 55 (logicop -> expr EQ expr .)
    FOR             reduce using rule 55 (logicop -> expr EQ expr .)
    IF              reduce using rule 55 (logicop -> expr EQ expr .)
    LBRACKET        reduce using rule 55 (logicop -> expr EQ expr .)
    LPARENT         reduce using rule 55 (logicop -> expr EQ expr .)
    FLOAT           reduce using rule 55 (logicop -> expr EQ expr .)
    VAR             reduce using rule 55 (logicop -> expr EQ expr .)
    UNARYMINUS      reduce using rule 55 (logicop -> expr EQ expr .)
    INC             reduce using rule 55 (logicop -> expr EQ expr .)
    DEC             reduce using rule 55 (logicop -> expr EQ expr .)
    NOT             reduce using rule 55 (logicop -> expr EQ expr .)
    BLTIN           reduce using rule 55 (logicop -> expr EQ expr .)
    FUNCTION        reduce using rule 55 (logicop -> expr EQ expr .)
    PI              reduce using rule 55 (logicop -> expr EQ expr .)
    PHI             reduce using rule 55 (logicop -> expr EQ expr .)
    GAMMA           reduce using rule 55 (logicop -> expr EQ expr .)
    E               reduce using rule 55 (logicop -> expr EQ expr .)
    DEG             reduce using rule 55 (logicop -> expr EQ expr .)
    PREC            reduce using rule 55 (logicop -> expr EQ expr .)
    ELSE            reduce using rule 55 (logicop -> expr EQ expr .)
    COMMA           reduce using rule 55 (logicop -> expr EQ expr .)
    RPARENT         reduce using rule 55 (logicop -> expr EQ expr .)
    SEMICOLON       reduce using rule 55 (logicop -> expr EQ expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85

  ! EXP             [ reduce using rule 55 (logicop -> expr EQ expr .) ]
  ! PLUS            [ reduce using rule 55 (logicop -> expr EQ expr .) ]
  ! MINUS           [ reduce using rule 55 (logicop -> expr EQ expr .) ]
  ! TIMES           [ reduce using rule 55 (logicop -> expr EQ expr .) ]
  ! DIVIDE          [ reduce using rule 55 (logicop -> expr EQ expr .) ]
  ! MOD             [ reduce using rule 55 (logicop -> expr EQ expr .) ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 122

    (47) mathop -> expr MINUS expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    PLUS            reduce using rule 47 (mathop -> expr MINUS expr .)
    MINUS           reduce using rule 47 (mathop -> expr MINUS expr .)
    LT              reduce using rule 47 (mathop -> expr MINUS expr .)
    GT              reduce using rule 47 (mathop -> expr MINUS expr .)
    LE              reduce using rule 47 (mathop -> expr MINUS expr .)
    GE              reduce using rule 47 (mathop -> expr MINUS expr .)
    EQ              reduce using rule 47 (mathop -> expr MINUS expr .)
    NE              reduce using rule 47 (mathop -> expr MINUS expr .)
    OR              reduce using rule 47 (mathop -> expr MINUS expr .)
    AND             reduce using rule 47 (mathop -> expr MINUS expr .)
    NEWLINE         reduce using rule 47 (mathop -> expr MINUS expr .)
    RBRACKET        reduce using rule 47 (mathop -> expr MINUS expr .)
    RETURN          reduce using rule 47 (mathop -> expr MINUS expr .)
    PRINT           reduce using rule 47 (mathop -> expr MINUS expr .)
    WHILE           reduce using rule 47 (mathop -> expr MINUS expr .)
    FOR             reduce using rule 47 (mathop -> expr MINUS expr .)
    IF              reduce using rule 47 (mathop -> expr MINUS expr .)
    LBRACKET        reduce using rule 47 (mathop -> expr MINUS expr .)
    LPARENT         reduce using rule 47 (mathop -> expr MINUS expr .)
    FLOAT           reduce using rule 47 (mathop -> expr MINUS expr .)
    VAR             reduce using rule 47 (mathop -> expr MINUS expr .)
    UNARYMINUS      reduce using rule 47 (mathop -> expr MINUS expr .)
    INC             reduce using rule 47 (mathop -> expr MINUS expr .)
    DEC             reduce using rule 47 (mathop -> expr MINUS expr .)
    NOT             reduce using rule 47 (mathop -> expr MINUS expr .)
    BLTIN           reduce using rule 47 (mathop -> expr MINUS expr .)
    FUNCTION        reduce using rule 47 (mathop -> expr MINUS expr .)
    PI              reduce using rule 47 (mathop -> expr MINUS expr .)
    PHI             reduce using rule 47 (mathop -> expr MINUS expr .)
    GAMMA           reduce using rule 47 (mathop -> expr MINUS expr .)
    E               reduce using rule 47 (mathop -> expr MINUS expr .)
    DEG             reduce using rule 47 (mathop -> expr MINUS expr .)
    PREC            reduce using rule 47 (mathop -> expr MINUS expr .)
    ELSE            reduce using rule 47 (mathop -> expr MINUS expr .)
    COMMA           reduce using rule 47 (mathop -> expr MINUS expr .)
    RPARENT         reduce using rule 47 (mathop -> expr MINUS expr .)
    SEMICOLON       reduce using rule 47 (mathop -> expr MINUS expr .)
    EXP             shift and go to state 81
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85

  ! EXP             [ reduce using rule 47 (mathop -> expr MINUS expr .) ]
  ! TIMES           [ reduce using rule 47 (mathop -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 47 (mathop -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 47 (mathop -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 83 ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 123

    (56) logicop -> expr NE expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    LT              reduce using rule 56 (logicop -> expr NE expr .)
    GT              reduce using rule 56 (logicop -> expr NE expr .)
    LE              reduce using rule 56 (logicop -> expr NE expr .)
    GE              reduce using rule 56 (logicop -> expr NE expr .)
    EQ              reduce using rule 56 (logicop -> expr NE expr .)
    NE              reduce using rule 56 (logicop -> expr NE expr .)
    OR              reduce using rule 56 (logicop -> expr NE expr .)
    AND             reduce using rule 56 (logicop -> expr NE expr .)
    NEWLINE         reduce using rule 56 (logicop -> expr NE expr .)
    RBRACKET        reduce using rule 56 (logicop -> expr NE expr .)
    RETURN          reduce using rule 56 (logicop -> expr NE expr .)
    PRINT           reduce using rule 56 (logicop -> expr NE expr .)
    WHILE           reduce using rule 56 (logicop -> expr NE expr .)
    FOR             reduce using rule 56 (logicop -> expr NE expr .)
    IF              reduce using rule 56 (logicop -> expr NE expr .)
    LBRACKET        reduce using rule 56 (logicop -> expr NE expr .)
    LPARENT         reduce using rule 56 (logicop -> expr NE expr .)
    FLOAT           reduce using rule 56 (logicop -> expr NE expr .)
    VAR             reduce using rule 56 (logicop -> expr NE expr .)
    UNARYMINUS      reduce using rule 56 (logicop -> expr NE expr .)
    INC             reduce using rule 56 (logicop -> expr NE expr .)
    DEC             reduce using rule 56 (logicop -> expr NE expr .)
    NOT             reduce using rule 56 (logicop -> expr NE expr .)
    BLTIN           reduce using rule 56 (logicop -> expr NE expr .)
    FUNCTION        reduce using rule 56 (logicop -> expr NE expr .)
    PI              reduce using rule 56 (logicop -> expr NE expr .)
    PHI             reduce using rule 56 (logicop -> expr NE expr .)
    GAMMA           reduce using rule 56 (logicop -> expr NE expr .)
    E               reduce using rule 56 (logicop -> expr NE expr .)
    DEG             reduce using rule 56 (logicop -> expr NE expr .)
    PREC            reduce using rule 56 (logicop -> expr NE expr .)
    ELSE            reduce using rule 56 (logicop -> expr NE expr .)
    COMMA           reduce using rule 56 (logicop -> expr NE expr .)
    RPARENT         reduce using rule 56 (logicop -> expr NE expr .)
    SEMICOLON       reduce using rule 56 (logicop -> expr NE expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85

  ! EXP             [ reduce using rule 56 (logicop -> expr NE expr .) ]
  ! PLUS            [ reduce using rule 56 (logicop -> expr NE expr .) ]
  ! MINUS           [ reduce using rule 56 (logicop -> expr NE expr .) ]
  ! TIMES           [ reduce using rule 56 (logicop -> expr NE expr .) ]
  ! DIVIDE          [ reduce using rule 56 (logicop -> expr NE expr .) ]
  ! MOD             [ reduce using rule 56 (logicop -> expr NE expr .) ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 124

    (50) mathop -> expr MOD expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    PLUS            reduce using rule 50 (mathop -> expr MOD expr .)
    MINUS           reduce using rule 50 (mathop -> expr MOD expr .)
    TIMES           reduce using rule 50 (mathop -> expr MOD expr .)
    DIVIDE          reduce using rule 50 (mathop -> expr MOD expr .)
    MOD             reduce using rule 50 (mathop -> expr MOD expr .)
    LT              reduce using rule 50 (mathop -> expr MOD expr .)
    GT              reduce using rule 50 (mathop -> expr MOD expr .)
    LE              reduce using rule 50 (mathop -> expr MOD expr .)
    GE              reduce using rule 50 (mathop -> expr MOD expr .)
    EQ              reduce using rule 50 (mathop -> expr MOD expr .)
    NE              reduce using rule 50 (mathop -> expr MOD expr .)
    OR              reduce using rule 50 (mathop -> expr MOD expr .)
    AND             reduce using rule 50 (mathop -> expr MOD expr .)
    NEWLINE         reduce using rule 50 (mathop -> expr MOD expr .)
    RBRACKET        reduce using rule 50 (mathop -> expr MOD expr .)
    RETURN          reduce using rule 50 (mathop -> expr MOD expr .)
    PRINT           reduce using rule 50 (mathop -> expr MOD expr .)
    WHILE           reduce using rule 50 (mathop -> expr MOD expr .)
    FOR             reduce using rule 50 (mathop -> expr MOD expr .)
    IF              reduce using rule 50 (mathop -> expr MOD expr .)
    LBRACKET        reduce using rule 50 (mathop -> expr MOD expr .)
    LPARENT         reduce using rule 50 (mathop -> expr MOD expr .)
    FLOAT           reduce using rule 50 (mathop -> expr MOD expr .)
    VAR             reduce using rule 50 (mathop -> expr MOD expr .)
    UNARYMINUS      reduce using rule 50 (mathop -> expr MOD expr .)
    INC             reduce using rule 50 (mathop -> expr MOD expr .)
    DEC             reduce using rule 50 (mathop -> expr MOD expr .)
    NOT             reduce using rule 50 (mathop -> expr MOD expr .)
    BLTIN           reduce using rule 50 (mathop -> expr MOD expr .)
    FUNCTION        reduce using rule 50 (mathop -> expr MOD expr .)
    PI              reduce using rule 50 (mathop -> expr MOD expr .)
    PHI             reduce using rule 50 (mathop -> expr MOD expr .)
    GAMMA           reduce using rule 50 (mathop -> expr MOD expr .)
    E               reduce using rule 50 (mathop -> expr MOD expr .)
    DEG             reduce using rule 50 (mathop -> expr MOD expr .)
    PREC            reduce using rule 50 (mathop -> expr MOD expr .)
    ELSE            reduce using rule 50 (mathop -> expr MOD expr .)
    COMMA           reduce using rule 50 (mathop -> expr MOD expr .)
    RPARENT         reduce using rule 50 (mathop -> expr MOD expr .)
    SEMICOLON       reduce using rule 50 (mathop -> expr MOD expr .)
    EXP             shift and go to state 81

  ! EXP             [ reduce using rule 50 (mathop -> expr MOD expr .) ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 83 ]
  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 78 ]
  ! GT              [ shift and go to state 73 ]
  ! LE              [ shift and go to state 79 ]
  ! GE              [ shift and go to state 76 ]
  ! EQ              [ shift and go to state 82 ]
  ! NE              [ shift and go to state 84 ]
  ! OR              [ shift and go to state 72 ]
  ! AND             [ shift and go to state 71 ]


state 125

    (19) stmt -> WHILE LPARENT cond RPARENT . stmt
    (15) stmt -> . expr
    (16) stmt -> . RETURN
    (17) stmt -> . RETURN expr
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt
    (21) stmt -> . IF LPARENT cond RPARENT stmt
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 19
    IF              shift and go to state 28
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    binaryop                       shift and go to state 36
    unaryop                        shift and go to state 20
    expr                           shift and go to state 92
    callfunc                       shift and go to state 31
    stmt                           shift and go to state 136
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 126

    (64) prlist -> prlist COMMA STRING .

    COMMA           reduce using rule 64 (prlist -> prlist COMMA STRING .)
    NEWLINE         reduce using rule 64 (prlist -> prlist COMMA STRING .)
    RBRACKET        reduce using rule 64 (prlist -> prlist COMMA STRING .)
    RETURN          reduce using rule 64 (prlist -> prlist COMMA STRING .)
    PRINT           reduce using rule 64 (prlist -> prlist COMMA STRING .)
    WHILE           reduce using rule 64 (prlist -> prlist COMMA STRING .)
    FOR             reduce using rule 64 (prlist -> prlist COMMA STRING .)
    IF              reduce using rule 64 (prlist -> prlist COMMA STRING .)
    LBRACKET        reduce using rule 64 (prlist -> prlist COMMA STRING .)
    LPARENT         reduce using rule 64 (prlist -> prlist COMMA STRING .)
    FLOAT           reduce using rule 64 (prlist -> prlist COMMA STRING .)
    VAR             reduce using rule 64 (prlist -> prlist COMMA STRING .)
    UNARYMINUS      reduce using rule 64 (prlist -> prlist COMMA STRING .)
    INC             reduce using rule 64 (prlist -> prlist COMMA STRING .)
    DEC             reduce using rule 64 (prlist -> prlist COMMA STRING .)
    NOT             reduce using rule 64 (prlist -> prlist COMMA STRING .)
    BLTIN           reduce using rule 64 (prlist -> prlist COMMA STRING .)
    FUNCTION        reduce using rule 64 (prlist -> prlist COMMA STRING .)
    PI              reduce using rule 64 (prlist -> prlist COMMA STRING .)
    PHI             reduce using rule 64 (prlist -> prlist COMMA STRING .)
    GAMMA           reduce using rule 64 (prlist -> prlist COMMA STRING .)
    E               reduce using rule 64 (prlist -> prlist COMMA STRING .)
    DEG             reduce using rule 64 (prlist -> prlist COMMA STRING .)
    PREC            reduce using rule 64 (prlist -> prlist COMMA STRING .)
    ELSE            reduce using rule 64 (prlist -> prlist COMMA STRING .)


state 127

    (63) prlist -> prlist COMMA expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    COMMA           reduce using rule 63 (prlist -> prlist COMMA expr .)
    NEWLINE         reduce using rule 63 (prlist -> prlist COMMA expr .)
    RBRACKET        reduce using rule 63 (prlist -> prlist COMMA expr .)
    RETURN          reduce using rule 63 (prlist -> prlist COMMA expr .)
    PRINT           reduce using rule 63 (prlist -> prlist COMMA expr .)
    WHILE           reduce using rule 63 (prlist -> prlist COMMA expr .)
    FOR             reduce using rule 63 (prlist -> prlist COMMA expr .)
    IF              reduce using rule 63 (prlist -> prlist COMMA expr .)
    LBRACKET        reduce using rule 63 (prlist -> prlist COMMA expr .)
    LPARENT         reduce using rule 63 (prlist -> prlist COMMA expr .)
    FLOAT           reduce using rule 63 (prlist -> prlist COMMA expr .)
    VAR             reduce using rule 63 (prlist -> prlist COMMA expr .)
    UNARYMINUS      reduce using rule 63 (prlist -> prlist COMMA expr .)
    INC             reduce using rule 63 (prlist -> prlist COMMA expr .)
    DEC             reduce using rule 63 (prlist -> prlist COMMA expr .)
    NOT             reduce using rule 63 (prlist -> prlist COMMA expr .)
    BLTIN           reduce using rule 63 (prlist -> prlist COMMA expr .)
    FUNCTION        reduce using rule 63 (prlist -> prlist COMMA expr .)
    PI              reduce using rule 63 (prlist -> prlist COMMA expr .)
    PHI             reduce using rule 63 (prlist -> prlist COMMA expr .)
    GAMMA           reduce using rule 63 (prlist -> prlist COMMA expr .)
    E               reduce using rule 63 (prlist -> prlist COMMA expr .)
    DEG             reduce using rule 63 (prlist -> prlist COMMA expr .)
    PREC            reduce using rule 63 (prlist -> prlist COMMA expr .)
    ELSE            reduce using rule 63 (prlist -> prlist COMMA expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71


state 128

    (74) arglist -> arglist COMMA . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 137
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 129

    (60) callfunc -> FUNCTION LPARENT arglist RPARENT .

    EXP             reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    PLUS            reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    MINUS           reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    TIMES           reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    DIVIDE          reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    MOD             reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    LT              reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    GT              reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    LE              reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    GE              reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    EQ              reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    NE              reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    OR              reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    AND             reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    NEWLINE         reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    RBRACKET        reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    RETURN          reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    PRINT           reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    WHILE           reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    FOR             reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    IF              reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    LBRACKET        reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    LPARENT         reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    FLOAT           reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    VAR             reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    UNARYMINUS      reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    INC             reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    DEC             reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    NOT             reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    BLTIN           reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    FUNCTION        reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    PI              reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    PHI             reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    GAMMA           reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    E               reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    DEG             reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    PREC            reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    ELSE            reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    COMMA           reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    RPARENT         reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)
    SEMICOLON       reduce using rule 60 (callfunc -> FUNCTION LPARENT arglist RPARENT .)


state 130

    (20) stmt -> FOR LPARENT cond SEMICOLON . cond SEMICOLON cond RPARENT stmt
    (24) cond -> . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 95
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    cond                           shift and go to state 138
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 131

    (59) callfunc -> BLTIN LPARENT arglist RPARENT .

    EXP             reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    PLUS            reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    MINUS           reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    TIMES           reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    DIVIDE          reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    MOD             reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    LT              reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    GT              reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    LE              reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    GE              reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    EQ              reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    NE              reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    OR              reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    AND             reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    NEWLINE         reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    RBRACKET        reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    RETURN          reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    PRINT           reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    WHILE           reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    FOR             reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    IF              reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    LBRACKET        reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    LPARENT         reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    FLOAT           reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    VAR             reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    UNARYMINUS      reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    INC             reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    DEC             reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    NOT             reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    BLTIN           reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    FUNCTION        reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    PI              reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    PHI             reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    GAMMA           reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    E               reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    DEG             reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    PREC            reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    ELSE            reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    COMMA           reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    RPARENT         reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)
    SEMICOLON       reduce using rule 59 (callfunc -> BLTIN LPARENT arglist RPARENT .)


state 132

    (70) formals -> VAR .

    RPARENT         reduce using rule 70 (formals -> VAR .)
    COMMA           reduce using rule 70 (formals -> VAR .)


state 133

    (69) formals -> empty .

    RPARENT         reduce using rule 69 (formals -> empty .)
    COMMA           reduce using rule 69 (formals -> empty .)


state 134

    (65) defn -> FUNC procname LPARENT formals . RPARENT stmt
    (71) formals -> formals . COMMA VAR

    RPARENT         shift and go to state 140
    COMMA           shift and go to state 139


state 135

    (21) stmt -> IF LPARENT cond RPARENT . stmt
    (22) stmt -> IF LPARENT cond RPARENT . stmt ELSE stmt
    (15) stmt -> . expr
    (16) stmt -> . RETURN
    (17) stmt -> . RETURN expr
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt
    (21) stmt -> . IF LPARENT cond RPARENT stmt
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 19
    IF              shift and go to state 28
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    binaryop                       shift and go to state 36
    unaryop                        shift and go to state 20
    expr                           shift and go to state 92
    callfunc                       shift and go to state 31
    stmt                           shift and go to state 141
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 136

    (19) stmt -> WHILE LPARENT cond RPARENT stmt .

    NEWLINE         reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    RBRACKET        reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    RETURN          reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    PRINT           reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    WHILE           reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    FOR             reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    IF              reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    LBRACKET        reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    LPARENT         reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    FLOAT           reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    VAR             reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    UNARYMINUS      reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    INC             reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    DEC             reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    NOT             reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    BLTIN           reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    FUNCTION        reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    PI              reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    PHI             reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    GAMMA           reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    E               reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    DEG             reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    PREC            reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)
    ELSE            reduce using rule 19 (stmt -> WHILE LPARENT cond RPARENT stmt .)


state 137

    (74) arglist -> arglist COMMA expr .
    (45) mathop -> expr . EXP expr
    (46) mathop -> expr . PLUS expr
    (47) mathop -> expr . MINUS expr
    (48) mathop -> expr . TIMES expr
    (49) mathop -> expr . DIVIDE expr
    (50) mathop -> expr . MOD expr
    (51) logicop -> expr . LT expr
    (52) logicop -> expr . GT expr
    (53) logicop -> expr . LE expr
    (54) logicop -> expr . GE expr
    (55) logicop -> expr . EQ expr
    (56) logicop -> expr . NE expr
    (57) logicop -> expr . OR expr
    (58) logicop -> expr . AND expr

    RPARENT         reduce using rule 74 (arglist -> arglist COMMA expr .)
    COMMA           reduce using rule 74 (arglist -> arglist COMMA expr .)
    EXP             shift and go to state 81
    PLUS            shift and go to state 80
    MINUS           shift and go to state 83
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 74
    MOD             shift and go to state 85
    LT              shift and go to state 78
    GT              shift and go to state 73
    LE              shift and go to state 79
    GE              shift and go to state 76
    EQ              shift and go to state 82
    NE              shift and go to state 84
    OR              shift and go to state 72
    AND             shift and go to state 71


state 138

    (20) stmt -> FOR LPARENT cond SEMICOLON cond . SEMICOLON cond RPARENT stmt

    SEMICOLON       shift and go to state 142


state 139

    (71) formals -> formals COMMA . VAR

    VAR             shift and go to state 143


state 140

    (65) defn -> FUNC procname LPARENT formals RPARENT . stmt
    (15) stmt -> . expr
    (16) stmt -> . RETURN
    (17) stmt -> . RETURN expr
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt
    (21) stmt -> . IF LPARENT cond RPARENT stmt
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 19
    IF              shift and go to state 28
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    binaryop                       shift and go to state 36
    unaryop                        shift and go to state 20
    expr                           shift and go to state 92
    callfunc                       shift and go to state 31
    stmt                           shift and go to state 144
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 141

    (21) stmt -> IF LPARENT cond RPARENT stmt .
    (22) stmt -> IF LPARENT cond RPARENT stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    NEWLINE         reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    RBRACKET        reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    RETURN          reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    PRINT           reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    WHILE           reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    FOR             reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    IF              reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    LBRACKET        reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    LPARENT         reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    FLOAT           reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    VAR             reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    UNARYMINUS      reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    INC             reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    DEC             reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    NOT             reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    BLTIN           reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    FUNCTION        reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    PI              reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    PHI             reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    GAMMA           reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    E               reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    DEG             reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    PREC            reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .)
    ELSE            shift and go to state 145

  ! ELSE            [ reduce using rule 21 (stmt -> IF LPARENT cond RPARENT stmt .) ]


state 142

    (20) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON . cond RPARENT stmt
    (24) cond -> . expr
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    unaryop                        shift and go to state 20
    expr                           shift and go to state 95
    callfunc                       shift and go to state 31
    asgn                           shift and go to state 40
    cond                           shift and go to state 146
    mathop                         shift and go to state 35
    binaryop                       shift and go to state 36
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 143

    (71) formals -> formals COMMA VAR .

    RPARENT         reduce using rule 71 (formals -> formals COMMA VAR .)
    COMMA           reduce using rule 71 (formals -> formals COMMA VAR .)


state 144

    (65) defn -> FUNC procname LPARENT formals RPARENT stmt .

    NEWLINE         reduce using rule 65 (defn -> FUNC procname LPARENT formals RPARENT stmt .)


state 145

    (22) stmt -> IF LPARENT cond RPARENT stmt ELSE . stmt
    (15) stmt -> . expr
    (16) stmt -> . RETURN
    (17) stmt -> . RETURN expr
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt
    (21) stmt -> . IF LPARENT cond RPARENT stmt
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 19
    IF              shift and go to state 28
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    binaryop                       shift and go to state 36
    unaryop                        shift and go to state 20
    expr                           shift and go to state 92
    callfunc                       shift and go to state 31
    stmt                           shift and go to state 147
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 146

    (20) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond . RPARENT stmt

    RPARENT         shift and go to state 148


state 147

    (22) stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .

    NEWLINE         reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    RBRACKET        reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    RETURN          reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    PRINT           reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    WHILE           reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    FOR             reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    IF              reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    LBRACKET        reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    LPARENT         reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    FLOAT           reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    VAR             reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    UNARYMINUS      reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    INC             reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    DEC             reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    NOT             reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    BLTIN           reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    FUNCTION        reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    PI              reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    PHI             reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    GAMMA           reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    E               reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    DEG             reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    PREC            reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)
    ELSE            reduce using rule 22 (stmt -> IF LPARENT cond RPARENT stmt ELSE stmt .)


state 148

    (20) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT . stmt
    (15) stmt -> . expr
    (16) stmt -> . RETURN
    (17) stmt -> . RETURN expr
    (18) stmt -> . PRINT prlist
    (19) stmt -> . WHILE LPARENT cond RPARENT stmt
    (20) stmt -> . FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt
    (21) stmt -> . IF LPARENT cond RPARENT stmt
    (22) stmt -> . IF LPARENT cond RPARENT stmt ELSE stmt
    (23) stmt -> . LBRACKET stmtlist RBRACKET
    (28) expr -> . data
    (29) expr -> . asgn
    (30) expr -> . unaryop
    (31) expr -> . binaryop
    (32) expr -> . LPARENT expr RPARENT
    (33) expr -> . callfunc
    (34) data -> . FLOAT
    (35) data -> . constant
    (36) data -> . VAR
    (9) asgn -> . VAR ASSIGN expr
    (10) asgn -> . VAR ADDEQ expr
    (11) asgn -> . VAR SUBEQ expr
    (12) asgn -> . VAR MULEQ expr
    (13) asgn -> . VAR DIVEQ expr
    (14) asgn -> . VAR MODEQ expr
    (37) unaryop -> . UNARYMINUS expr
    (38) unaryop -> . INC VAR
    (39) unaryop -> . DEC VAR
    (40) unaryop -> . VAR INC
    (41) unaryop -> . VAR DEC
    (42) unaryop -> . NOT expr
    (43) binaryop -> . mathop
    (44) binaryop -> . logicop
    (59) callfunc -> . BLTIN LPARENT arglist RPARENT
    (60) callfunc -> . FUNCTION LPARENT arglist RPARENT
    (77) constant -> . PI
    (78) constant -> . PHI
    (79) constant -> . GAMMA
    (80) constant -> . E
    (81) constant -> . DEG
    (82) constant -> . PREC
    (45) mathop -> . expr EXP expr
    (46) mathop -> . expr PLUS expr
    (47) mathop -> . expr MINUS expr
    (48) mathop -> . expr TIMES expr
    (49) mathop -> . expr DIVIDE expr
    (50) mathop -> . expr MOD expr
    (51) logicop -> . expr LT expr
    (52) logicop -> . expr GT expr
    (53) logicop -> . expr LE expr
    (54) logicop -> . expr GE expr
    (55) logicop -> . expr EQ expr
    (56) logicop -> . expr NE expr
    (57) logicop -> . expr OR expr
    (58) logicop -> . expr AND expr

    RETURN          shift and go to state 3
    PRINT           shift and go to state 6
    WHILE           shift and go to state 5
    FOR             shift and go to state 19
    IF              shift and go to state 28
    LBRACKET        shift and go to state 4
    LPARENT         shift and go to state 13
    FLOAT           shift and go to state 32
    VAR             shift and go to state 41
    UNARYMINUS      shift and go to state 34
    INC             shift and go to state 39
    DEC             shift and go to state 8
    NOT             shift and go to state 38
    BLTIN           shift and go to state 23
    FUNCTION        shift and go to state 17
    PI              shift and go to state 16
    PHI             shift and go to state 29
    GAMMA           shift and go to state 10
    E               shift and go to state 18
    DEG             shift and go to state 11
    PREC            shift and go to state 33

    constant                       shift and go to state 7
    binaryop                       shift and go to state 36
    unaryop                        shift and go to state 20
    expr                           shift and go to state 92
    callfunc                       shift and go to state 31
    stmt                           shift and go to state 149
    asgn                           shift and go to state 40
    mathop                         shift and go to state 35
    logicop                        shift and go to state 9
    data                           shift and go to state 26

state 149

    (20) stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .

    NEWLINE         reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    RBRACKET        reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    RETURN          reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    PRINT           reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    WHILE           reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    FOR             reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    IF              reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    LBRACKET        reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    LPARENT         reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    FLOAT           reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    VAR             reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    UNARYMINUS      reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    INC             reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    DEC             reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    NOT             reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    BLTIN           reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    FUNCTION        reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    PI              reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    PHI             reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    GAMMA           reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    E               reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    DEG             reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    PREC            reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)
    ELSE            reduce using rule 20 (stmt -> FOR LPARENT cond SEMICOLON cond SEMICOLON cond RPARENT stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPARENT in state 3 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 3 resolved as shift
WARNING: shift/reduce conflict for VAR in state 3 resolved as shift
WARNING: shift/reduce conflict for UNARYMINUS in state 3 resolved as shift
WARNING: shift/reduce conflict for INC in state 3 resolved as shift
WARNING: shift/reduce conflict for DEC in state 3 resolved as shift
WARNING: shift/reduce conflict for NOT in state 3 resolved as shift
WARNING: shift/reduce conflict for BLTIN in state 3 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 3 resolved as shift
WARNING: shift/reduce conflict for PI in state 3 resolved as shift
WARNING: shift/reduce conflict for PHI in state 3 resolved as shift
WARNING: shift/reduce conflict for GAMMA in state 3 resolved as shift
WARNING: shift/reduce conflict for E in state 3 resolved as shift
WARNING: shift/reduce conflict for DEG in state 3 resolved as shift
WARNING: shift/reduce conflict for PREC in state 3 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 15 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 30 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 141 resolved as shift
